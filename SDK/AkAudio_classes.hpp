#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AkAudio

#include "Basic.hpp"

#include "AkAudio_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "SlateCore_structs.hpp"
#include "UMG_classes.hpp"
#include "MovieScene_classes.hpp"


namespace SDK
{

// Class AkAudio.AkComponent
// 0x01E8 (0x0420 - 0x0238)
class UAkComponent : public USceneComponent
{
public:
	bool                                          bUseSpatialAudio;                                  // 0x0238(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAuxBus*                              EarlyReflectionAuxBus;                             // 0x0240(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EarlyReflectionAuxBusName;                         // 0x0248(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EarlyReflectionOrder;                              // 0x0258(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EarlyReflectionBusSendGain;                        // 0x025C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EarlyReflectionMaxPathLength;                      // 0x0260(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             OcclusionCollisionChannel;                         // 0x0264(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_265[0x7];                                      // 0x0265(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         EnableSpotReflectors : 1;                          // 0x026C(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_26D[0x3];                                      // 0x026D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         RoomReverbAuxBusGain;                              // 0x0270(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffractionMaxEdges;                               // 0x0274(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DiffractionMaxPaths;                               // 0x0278(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DiffractionMaxPathLength;                          // 0x027C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         DrawFirstOrderReflections : 1;                     // 0x0280(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DrawSecondOrderReflections : 1;                    // 0x0280(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DrawHigherOrderReflections : 1;                    // 0x0280(0x0001)(BitIndex: 0x02, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DrawGeometricDiffraction : 1;                      // 0x0280(0x0001)(BitIndex: 0x03, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         DrawSoundPropagation : 1;                          // 0x0280(0x0001)(BitIndex: 0x04, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_281[0x3];                                      // 0x0281(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          StopWhenOwnerDestroyed;                            // 0x0284(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_285[0x3];                                      // 0x0285(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         AttenuationScalingFactor;                          // 0x0288(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OcclusionRefreshInterval;                          // 0x028C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x0290(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EventName;                                         // 0x0298(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A8[0x178];                                    // 0x02A8(0x0178)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 PostAkEvent(class UAkAudioEvent* AkEvent, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, const class FString& In_EventName);
	int32 PostAkEventAndWaitForEnd(class UAkAudioEvent* AkEvent, const class FString& In_EventName, const struct FLatentActionInfo& LatentInfo);
	int32 PostAkEventByName(const class FString& In_EventName);
	int32 PostAssociatedAkEvent(int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback);
	int32 PostAssociatedAkEventAndWaitForEnd(const struct FLatentActionInfo& LatentInfo);
	void PostTrigger(const class FString& Trigger);
	void SetAttenuationScalingFactor(float Value);
	void SetListeners(const TArray<class UAkComponent*>& Listeners);
	void SetOutputBusVolume(float BusVolume);
	void SetRTPCValue(const class FString& RTPC, float Value, int32 InterpolationTimeMs);
	void SetStopWhenOwnerDestroyed(bool bStopWhenOwnerDestroyed);
	void SetSwitch(const class FString& SwitchGroup, const class FString& SwitchState);
	void SetUseSpatialAudio(const bool bNewValue);
	void Stop();
	void UseEarlyReflections(class UAkAuxBus* AuxBus, int32 Order, float BusSendGain, float MaxPathLength, bool SpotReflectors, const class FString& AuxBusName);
	void UseReverbVolumes(bool InUseReverbVolumes);

	float GetAttenuationRadius() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkComponent">();
	}
	static class UAkComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkComponent>();
	}
};
static_assert(alignof(UAkComponent) == 0x000008, "Wrong alignment on UAkComponent");
static_assert(sizeof(UAkComponent) == 0x000420, "Wrong size on UAkComponent");
static_assert(offsetof(UAkComponent, bUseSpatialAudio) == 0x000238, "Member 'UAkComponent::bUseSpatialAudio' has a wrong offset!");
static_assert(offsetof(UAkComponent, EarlyReflectionAuxBus) == 0x000240, "Member 'UAkComponent::EarlyReflectionAuxBus' has a wrong offset!");
static_assert(offsetof(UAkComponent, EarlyReflectionAuxBusName) == 0x000248, "Member 'UAkComponent::EarlyReflectionAuxBusName' has a wrong offset!");
static_assert(offsetof(UAkComponent, EarlyReflectionOrder) == 0x000258, "Member 'UAkComponent::EarlyReflectionOrder' has a wrong offset!");
static_assert(offsetof(UAkComponent, EarlyReflectionBusSendGain) == 0x00025C, "Member 'UAkComponent::EarlyReflectionBusSendGain' has a wrong offset!");
static_assert(offsetof(UAkComponent, EarlyReflectionMaxPathLength) == 0x000260, "Member 'UAkComponent::EarlyReflectionMaxPathLength' has a wrong offset!");
static_assert(offsetof(UAkComponent, OcclusionCollisionChannel) == 0x000264, "Member 'UAkComponent::OcclusionCollisionChannel' has a wrong offset!");
static_assert(offsetof(UAkComponent, RoomReverbAuxBusGain) == 0x000270, "Member 'UAkComponent::RoomReverbAuxBusGain' has a wrong offset!");
static_assert(offsetof(UAkComponent, DiffractionMaxEdges) == 0x000274, "Member 'UAkComponent::DiffractionMaxEdges' has a wrong offset!");
static_assert(offsetof(UAkComponent, DiffractionMaxPaths) == 0x000278, "Member 'UAkComponent::DiffractionMaxPaths' has a wrong offset!");
static_assert(offsetof(UAkComponent, DiffractionMaxPathLength) == 0x00027C, "Member 'UAkComponent::DiffractionMaxPathLength' has a wrong offset!");
static_assert(offsetof(UAkComponent, StopWhenOwnerDestroyed) == 0x000284, "Member 'UAkComponent::StopWhenOwnerDestroyed' has a wrong offset!");
static_assert(offsetof(UAkComponent, AttenuationScalingFactor) == 0x000288, "Member 'UAkComponent::AttenuationScalingFactor' has a wrong offset!");
static_assert(offsetof(UAkComponent, OcclusionRefreshInterval) == 0x00028C, "Member 'UAkComponent::OcclusionRefreshInterval' has a wrong offset!");
static_assert(offsetof(UAkComponent, AkAudioEvent) == 0x000290, "Member 'UAkComponent::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(UAkComponent, EventName) == 0x000298, "Member 'UAkComponent::EventName' has a wrong offset!");

// Class AkAudio.AkAcousticPortal
// 0x0090 (0x03F0 - 0x0360)
class AAkAcousticPortal final : public AVolume
{
public:
	EAkAcousticPortalState                        InitialState;                                      // 0x0360(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_361[0x3];                                      // 0x0361(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ObstructionRefreshInterval;                        // 0x0364(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             ObstructionCollisionChannel;                       // 0x0368(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_369[0x87];                                     // 0x0369(0x0087)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ClosePortal();
	void OpenPortal();

	EAkAcousticPortalState GetCurrentState() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAcousticPortal">();
	}
	static class AAkAcousticPortal* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkAcousticPortal>();
	}
};
static_assert(alignof(AAkAcousticPortal) == 0x000008, "Wrong alignment on AAkAcousticPortal");
static_assert(sizeof(AAkAcousticPortal) == 0x0003F0, "Wrong size on AAkAcousticPortal");
static_assert(offsetof(AAkAcousticPortal, InitialState) == 0x000360, "Member 'AAkAcousticPortal::InitialState' has a wrong offset!");
static_assert(offsetof(AAkAcousticPortal, ObstructionRefreshInterval) == 0x000364, "Member 'AAkAcousticPortal::ObstructionRefreshInterval' has a wrong offset!");
static_assert(offsetof(AAkAcousticPortal, ObstructionCollisionChannel) == 0x000368, "Member 'AAkAcousticPortal::ObstructionCollisionChannel' has a wrong offset!");

// Class AkAudio.AkPortalComponent
// 0x0008 (0x0240 - 0x0238)
class UAkPortalComponent final : public USceneComponent
{
public:
	uint8                                         Pad_238[0x8];                                      // 0x0238(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkPortalComponent">();
	}
	static class UAkPortalComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkPortalComponent>();
	}
};
static_assert(alignof(UAkPortalComponent) == 0x000008, "Wrong alignment on UAkPortalComponent");
static_assert(sizeof(UAkPortalComponent) == 0x000240, "Wrong size on UAkPortalComponent");

// Class AkAudio.AkAcousticTexture
// 0x0000 (0x0080 - 0x0080)
class UAkAcousticTexture final : public UPhysicalMaterial
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAcousticTexture">();
	}
	static class UAkAcousticTexture* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAcousticTexture>();
	}
};
static_assert(alignof(UAkAcousticTexture) == 0x000008, "Wrong alignment on UAkAcousticTexture");
static_assert(sizeof(UAkAcousticTexture) == 0x000080, "Wrong size on UAkAcousticTexture");

// Class AkAudio.AkAmbientSound
// 0x0040 (0x0368 - 0x0328)
class AAkAmbientSound final : public AActor
{
public:
	class UAkAudioEvent*                          AkAudioEvent;                                      // 0x0328(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkComponent*                           AkComponent;                                       // 0x0330(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          StopWhenOwnerIsDestroyed;                          // 0x0338(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, SimpleDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          AutoPost;                                          // 0x0339(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, SimpleDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_33A[0x2E];                                     // 0x033A(0x002E)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void StartAmbientSound();
	void StopAmbientSound();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAmbientSound">();
	}
	static class AAkAmbientSound* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkAmbientSound>();
	}
};
static_assert(alignof(AAkAmbientSound) == 0x000008, "Wrong alignment on AAkAmbientSound");
static_assert(sizeof(AAkAmbientSound) == 0x000368, "Wrong size on AAkAmbientSound");
static_assert(offsetof(AAkAmbientSound, AkAudioEvent) == 0x000328, "Member 'AAkAmbientSound::AkAudioEvent' has a wrong offset!");
static_assert(offsetof(AAkAmbientSound, AkComponent) == 0x000330, "Member 'AAkAmbientSound::AkComponent' has a wrong offset!");
static_assert(offsetof(AAkAmbientSound, StopWhenOwnerIsDestroyed) == 0x000338, "Member 'AAkAmbientSound::StopWhenOwnerIsDestroyed' has a wrong offset!");
static_assert(offsetof(AAkAmbientSound, AutoPost) == 0x000339, "Member 'AAkAmbientSound::AutoPost' has a wrong offset!");

// Class AkAudio.AkAudioBank
// 0x0008 (0x0030 - 0x0028)
class UAkAudioBank final : public UObject
{
public:
	bool                                          AutoLoad;                                          // 0x0028(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAudioBank">();
	}
	static class UAkAudioBank* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAudioBank>();
	}
};
static_assert(alignof(UAkAudioBank) == 0x000008, "Wrong alignment on UAkAudioBank");
static_assert(sizeof(UAkAudioBank) == 0x000030, "Wrong size on UAkAudioBank");
static_assert(offsetof(UAkAudioBank, AutoLoad) == 0x000028, "Member 'UAkAudioBank::AutoLoad' has a wrong offset!");

// Class AkAudio.AkAudioEvent
// 0x0018 (0x0040 - 0x0028)
class UAkAudioEvent final : public UObject
{
public:
	class UAkAudioBank*                           RequiredBank;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaxAttenuationRadius;                              // 0x0030(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsInfinite;                                        // 0x0034(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_35[0x3];                                       // 0x0035(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MinimumDuration;                                   // 0x0038(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MaximumDuration;                                   // 0x003C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAudioEvent">();
	}
	static class UAkAudioEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAudioEvent>();
	}
};
static_assert(alignof(UAkAudioEvent) == 0x000008, "Wrong alignment on UAkAudioEvent");
static_assert(sizeof(UAkAudioEvent) == 0x000040, "Wrong size on UAkAudioEvent");
static_assert(offsetof(UAkAudioEvent, RequiredBank) == 0x000028, "Member 'UAkAudioEvent::RequiredBank' has a wrong offset!");
static_assert(offsetof(UAkAudioEvent, MaxAttenuationRadius) == 0x000030, "Member 'UAkAudioEvent::MaxAttenuationRadius' has a wrong offset!");
static_assert(offsetof(UAkAudioEvent, IsInfinite) == 0x000034, "Member 'UAkAudioEvent::IsInfinite' has a wrong offset!");
static_assert(offsetof(UAkAudioEvent, MinimumDuration) == 0x000038, "Member 'UAkAudioEvent::MinimumDuration' has a wrong offset!");
static_assert(offsetof(UAkAudioEvent, MaximumDuration) == 0x00003C, "Member 'UAkAudioEvent::MaximumDuration' has a wrong offset!");

// Class AkAudio.AkAudioInputComponent
// 0x0010 (0x0430 - 0x0420)
class UAkAudioInputComponent final : public UAkComponent
{
public:
	uint8                                         Pad_420[0x10];                                     // 0x0420(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	int32 PostAssociatedAudioInputEvent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAudioInputComponent">();
	}
	static class UAkAudioInputComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAudioInputComponent>();
	}
};
static_assert(alignof(UAkAudioInputComponent) == 0x000008, "Wrong alignment on UAkAudioInputComponent");
static_assert(sizeof(UAkAudioInputComponent) == 0x000430, "Wrong size on UAkAudioInputComponent");

// Class AkAudio.AkAuxBus
// 0x0010 (0x0038 - 0x0028)
class UAkAuxBus final : public UObject
{
public:
	class UAkAudioBank*                           RequiredBank;                                      // 0x0028(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_30[0x8];                                       // 0x0030(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkAuxBus">();
	}
	static class UAkAuxBus* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkAuxBus>();
	}
};
static_assert(alignof(UAkAuxBus) == 0x000008, "Wrong alignment on UAkAuxBus");
static_assert(sizeof(UAkAuxBus) == 0x000038, "Wrong size on UAkAuxBus");
static_assert(offsetof(UAkAuxBus, RequiredBank) == 0x000028, "Member 'UAkAuxBus::RequiredBank' has a wrong offset!");

// Class AkAudio.AkCheckBox
// 0x0958 (0x0A70 - 0x0118)
class UAkCheckBox final : public UContentWidget
{
public:
	uint8                                         Pad_118[0x2E8];                                    // 0x0118(0x02E8)(Fixing Size After Last Property [ Dumper-7 ])
	ECheckBoxState                                CheckedState;                                      // 0x0400(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_401[0x7];                                      // 0x0401(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             CheckedStateDelegate;                              // 0x0408(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FCheckBoxStyle                         WidgetStyle;                                       // 0x0418(0x0580)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EHorizontalAlignment                          HorizontalAlignment;                               // 0x0998(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x0999(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99A[0x6];                                      // 0x099A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkBoolPropertyToControl               ThePropertyToControl;                              // 0x09A0(0x0010)(Edit, NativeAccessSpecifierPublic)
	struct FAkWwiseItemToControl                  ItemToControl;                                     // 0x09B0(0x0040)(Edit, Config, EditConst, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   AkOnCheckStateChanged;                             // 0x09F0(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemDropped;                                     // 0x0A00(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPropertyDropped;                                 // 0x0A10(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_A20[0x50];                                     // 0x0A20(0x0050)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAkBoolProperty(const class FString& ItemProperty);
	void SetAkItemId(const struct FGuid& ItemId);
	void SetCheckedState(ECheckBoxState InCheckedState);
	void SetIsChecked(bool InIsChecked);

	const struct FGuid GetAkItemId() const;
	const class FString GetAkProperty() const;
	ECheckBoxState GetCheckedState() const;
	bool IsChecked() const;
	bool IsPressed() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkCheckBox">();
	}
	static class UAkCheckBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkCheckBox>();
	}
};
static_assert(alignof(UAkCheckBox) == 0x000008, "Wrong alignment on UAkCheckBox");
static_assert(sizeof(UAkCheckBox) == 0x000A70, "Wrong size on UAkCheckBox");
static_assert(offsetof(UAkCheckBox, CheckedState) == 0x000400, "Member 'UAkCheckBox::CheckedState' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, CheckedStateDelegate) == 0x000408, "Member 'UAkCheckBox::CheckedStateDelegate' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, WidgetStyle) == 0x000418, "Member 'UAkCheckBox::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, HorizontalAlignment) == 0x000998, "Member 'UAkCheckBox::HorizontalAlignment' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, IsFocusable) == 0x000999, "Member 'UAkCheckBox::IsFocusable' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, ThePropertyToControl) == 0x0009A0, "Member 'UAkCheckBox::ThePropertyToControl' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, ItemToControl) == 0x0009B0, "Member 'UAkCheckBox::ItemToControl' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, AkOnCheckStateChanged) == 0x0009F0, "Member 'UAkCheckBox::AkOnCheckStateChanged' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, OnItemDropped) == 0x000A00, "Member 'UAkCheckBox::OnItemDropped' has a wrong offset!");
static_assert(offsetof(UAkCheckBox, OnPropertyDropped) == 0x000A10, "Member 'UAkCheckBox::OnPropertyDropped' has a wrong offset!");

// Class AkAudio.AkGameplayStatics
// 0x0000 (0x0028 - 0x0028)
class UAkGameplayStatics final : public UBlueprintFunctionLibrary
{
public:
	static void AddOutputCaptureMarker(const class FString& MarkerText);
	static void CancelEventCallback(const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback);
	static void ClearBanks();
	static void ExecuteActionOnEvent(class UAkAudioEvent* AkEvent, EAkActionOnEventType ActionType, class AActor* Actor, int32 TransitionDuration, EAkCurveInterpolation FadeCurve, int32 PlayingID);
	static class UAkComponent* GetAkComponent(class USceneComponent* AttachToComponent, class FName AttachPointName, const struct FVector& Location, EAttachLocation LocationType);
	static float GetOcclusionScalingFactor();
	static void GetSpeakerAngles(TArray<float>* SpeakerAngles, float* HeightAngle, const class FString& DeviceShareset);
	static bool IsEditor();
	static bool IsGame(class UObject* WorldContextObject);
	static void LoadBank(class UAkAudioBank* Bank, const class FString& BankName, const struct FLatentActionInfo& LatentInfo, class UObject* WorldContextObject);
	static void LoadBankAsync(class UAkAudioBank* Bank, const TDelegate<void(EAkResult Result)>& BankLoadedCallback);
	static void LoadBankByName(const class FString& BankName);
	static void LoadBanks(const TArray<class UAkAudioBank*>& SoundBanks, bool SynchronizeSoundBanks);
	static void LoadInitBank();
	static int32 PostAndWaitForEndOfEvent(class UAkAudioEvent* AkEvent, class AActor* Actor, bool bStopWhenAttachedToDestroyed, const class FString& EventName, const struct FLatentActionInfo& LatentInfo);
	static int32 PostEvent(class UAkAudioEvent* AkEvent, class AActor* Actor, int32 CallbackMask, const TDelegate<void(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)>& PostEventCallback, bool bStopWhenAttachedToDestroyed, const class FString& EventName);
	static int32 PostEventAtLocation(class UAkAudioEvent* AkEvent, const struct FVector& Location, const struct FRotator& Orientation, const class FString& EventName, class UObject* WorldContextObject);
	static void PostEventAtLocationByName(const class FString& EventName, const struct FVector& Location, const struct FRotator& Orientation, class UObject* WorldContextObject);
	static int32 PostEventAttached(class UAkAudioEvent* AkEvent, class AActor* Actor, class FName AttachPointName, bool bStopWhenAttachedToDestroyed, const class FString& EventName);
	static void PostEventByName(const class FString& EventName, class AActor* Actor, bool bStopWhenAttachedToDestroyed);
	static void PostTrigger(class FName Trigger, class AActor* Actor);
	static void SetBusConfig(const class FString& BusName, EAkChannelConfiguration ChannelConfiguration);
	static void SetMultipleChannelEmitterPositions(class UAkComponent* GameObjectAkComponent, const TArray<EAkChannelConfiguration>& ChannelMasks, const TArray<struct FTransform>& Positions, EAkMultiPositionType MultiPositionType);
	static void SetMultiplePositions(class UAkComponent* GameObjectAkComponent, const TArray<struct FTransform>& Positions, EAkMultiPositionType MultiPositionType);
	static void SetOcclusionRefreshInterval(float RefreshInterval, class AActor* Actor);
	static void SetOcclusionScalingFactor(float ScalingFactor);
	static void SetOutputBusVolume(float BusVolume, class AActor* Actor);
	static void SetPanningRule(EPanningRule PanRule);
	static void SetRTPCValue(class FName RTPC, float Value, int32 InterpolationTimeMs, class AActor* Actor);
	static void SetSpeakerAngles(const TArray<float>& SpeakerAngles, float HeightAngle, const class FString& DeviceShareset);
	static void SetState(class FName StateGroup, class FName State);
	static void SetSwitch(class FName SwitchGroup, class FName SwitchState, class AActor* Actor);
	static void SetWwiseCulture(const class FString& Language);
	static class UAkComponent* SpawnAkComponentAtLocation(class UObject* WorldContextObject, class UAkAudioEvent* AkEvent, class UAkAuxBus* EarlyReflectionsBus, const struct FVector& Location, const struct FRotator& Orientation, bool AutoPost, const class FString& EventName, const class FString& EarlyReflectionsBusName, bool AutoDestroy);
	static void StartAllAmbientSounds(class UObject* WorldContextObject);
	static void StartOutputCapture(const class FString& Filename);
	static void StartProfilerCapture(const class FString& Filename);
	static void StopActor(class AActor* Actor);
	static void StopAll();
	static void StopAllAmbientSounds(class UObject* WorldContextObject);
	static void StopOutputCapture();
	static void StopPlayingID(int32 PlayingID);
	static void StopProfilerCapture();
	static void UnloadBank(class UAkAudioBank* Bank, const class FString& BankName, const struct FLatentActionInfo& LatentInfo, class UObject* WorldContextObject);
	static void UnloadBankAsync(class UAkAudioBank* Bank, const TDelegate<void(EAkResult Result)>& BankUnloadedCallback);
	static void UnloadBankByName(const class FString& BankName);
	static void UseEarlyReflections(class AActor* Actor, class UAkAuxBus* AuxBus, int32 Order, float BusSendGain, float MaxPathLength, bool SpotReflectors, const class FString& AuxBusName);
	static void UseReverbVolumes(bool InUseReverbVolumes, class AActor* Actor);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkGameplayStatics">();
	}
	static class UAkGameplayStatics* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkGameplayStatics>();
	}
};
static_assert(alignof(UAkGameplayStatics) == 0x000008, "Wrong alignment on UAkGameplayStatics");
static_assert(sizeof(UAkGameplayStatics) == 0x000028, "Wrong size on UAkGameplayStatics");

// Class AkAudio.AkCallbackInfo
// 0x0008 (0x0030 - 0x0028)
class UAkCallbackInfo : public UObject
{
public:
	class UAkComponent*                           AkComponent;                                       // 0x0028(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkCallbackInfo">();
	}
	static class UAkCallbackInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkCallbackInfo>();
	}
};
static_assert(alignof(UAkCallbackInfo) == 0x000008, "Wrong alignment on UAkCallbackInfo");
static_assert(sizeof(UAkCallbackInfo) == 0x000030, "Wrong size on UAkCallbackInfo");
static_assert(offsetof(UAkCallbackInfo, AkComponent) == 0x000028, "Member 'UAkCallbackInfo::AkComponent' has a wrong offset!");

// Class AkAudio.AkEventCallbackInfo
// 0x0008 (0x0038 - 0x0030)
class UAkEventCallbackInfo : public UAkCallbackInfo
{
public:
	int32                                         PlayingID;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EventID;                                           // 0x0034(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkEventCallbackInfo">();
	}
	static class UAkEventCallbackInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkEventCallbackInfo>();
	}
};
static_assert(alignof(UAkEventCallbackInfo) == 0x000008, "Wrong alignment on UAkEventCallbackInfo");
static_assert(sizeof(UAkEventCallbackInfo) == 0x000038, "Wrong size on UAkEventCallbackInfo");
static_assert(offsetof(UAkEventCallbackInfo, PlayingID) == 0x000030, "Member 'UAkEventCallbackInfo::PlayingID' has a wrong offset!");
static_assert(offsetof(UAkEventCallbackInfo, EventID) == 0x000034, "Member 'UAkEventCallbackInfo::EventID' has a wrong offset!");

// Class AkAudio.AkMIDIEventCallbackInfo
// 0x0008 (0x0040 - 0x0038)
class UAkMIDIEventCallbackInfo final : public UAkEventCallbackInfo
{
public:
	uint8                                         Pad_38[0x8];                                       // 0x0038(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool GetCc(struct FAkMidiCc* AsCc);
	uint8 GetChannel();
	bool GetChannelAftertouch(struct FAkMidiChannelAftertouch* AsChannelAftertouch);
	bool GetGeneric(struct FAkMidiGeneric* AsGeneric);
	bool GetNoteAftertouch(struct FAkMidiNoteAftertouch* AsNoteAftertouch);
	bool GetNoteOff(struct FAkMidiNoteOnOff* AsNoteOff);
	bool GetNoteOn(struct FAkMidiNoteOnOff* AsNoteOn);
	bool GetPitchBend(struct FAkMidiPitchBend* AsPitchBend);
	bool GetProgramChange(struct FAkMidiProgramChange* AsProgramChange);
	EAkMidiEventType GetType();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkMIDIEventCallbackInfo">();
	}
	static class UAkMIDIEventCallbackInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkMIDIEventCallbackInfo>();
	}
};
static_assert(alignof(UAkMIDIEventCallbackInfo) == 0x000008, "Wrong alignment on UAkMIDIEventCallbackInfo");
static_assert(sizeof(UAkMIDIEventCallbackInfo) == 0x000040, "Wrong size on UAkMIDIEventCallbackInfo");

// Class AkAudio.AkMarkerCallbackInfo
// 0x0018 (0x0050 - 0x0038)
class UAkMarkerCallbackInfo final : public UAkEventCallbackInfo
{
public:
	int32                                         Identifier;                                        // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Position;                                          // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Label;                                             // 0x0040(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkMarkerCallbackInfo">();
	}
	static class UAkMarkerCallbackInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkMarkerCallbackInfo>();
	}
};
static_assert(alignof(UAkMarkerCallbackInfo) == 0x000008, "Wrong alignment on UAkMarkerCallbackInfo");
static_assert(sizeof(UAkMarkerCallbackInfo) == 0x000050, "Wrong size on UAkMarkerCallbackInfo");
static_assert(offsetof(UAkMarkerCallbackInfo, Identifier) == 0x000038, "Member 'UAkMarkerCallbackInfo::Identifier' has a wrong offset!");
static_assert(offsetof(UAkMarkerCallbackInfo, Position) == 0x00003C, "Member 'UAkMarkerCallbackInfo::Position' has a wrong offset!");
static_assert(offsetof(UAkMarkerCallbackInfo, Label) == 0x000040, "Member 'UAkMarkerCallbackInfo::Label' has a wrong offset!");

// Class AkAudio.AkDurationCallbackInfo
// 0x0018 (0x0050 - 0x0038)
class UAkDurationCallbackInfo final : public UAkEventCallbackInfo
{
public:
	float                                         Duration;                                          // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         EstimatedDuration;                                 // 0x003C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AudioNodeID;                                       // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MediaID;                                           // 0x0044(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bStreaming;                                        // 0x0048(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkDurationCallbackInfo">();
	}
	static class UAkDurationCallbackInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkDurationCallbackInfo>();
	}
};
static_assert(alignof(UAkDurationCallbackInfo) == 0x000008, "Wrong alignment on UAkDurationCallbackInfo");
static_assert(sizeof(UAkDurationCallbackInfo) == 0x000050, "Wrong size on UAkDurationCallbackInfo");
static_assert(offsetof(UAkDurationCallbackInfo, Duration) == 0x000038, "Member 'UAkDurationCallbackInfo::Duration' has a wrong offset!");
static_assert(offsetof(UAkDurationCallbackInfo, EstimatedDuration) == 0x00003C, "Member 'UAkDurationCallbackInfo::EstimatedDuration' has a wrong offset!");
static_assert(offsetof(UAkDurationCallbackInfo, AudioNodeID) == 0x000040, "Member 'UAkDurationCallbackInfo::AudioNodeID' has a wrong offset!");
static_assert(offsetof(UAkDurationCallbackInfo, MediaID) == 0x000044, "Member 'UAkDurationCallbackInfo::MediaID' has a wrong offset!");
static_assert(offsetof(UAkDurationCallbackInfo, bStreaming) == 0x000048, "Member 'UAkDurationCallbackInfo::bStreaming' has a wrong offset!");

// Class AkAudio.AkMusicSyncCallbackInfo
// 0x0040 (0x0070 - 0x0030)
class UAkMusicSyncCallbackInfo final : public UAkCallbackInfo
{
public:
	int32                                         PlayingID;                                         // 0x0030(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAkSegmentInfo                         SegmentInfo;                                       // 0x0034(0x0024)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	EAkCallbackType                               MusicSyncType;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 UserCueName;                                       // 0x0060(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkMusicSyncCallbackInfo">();
	}
	static class UAkMusicSyncCallbackInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkMusicSyncCallbackInfo>();
	}
};
static_assert(alignof(UAkMusicSyncCallbackInfo) == 0x000008, "Wrong alignment on UAkMusicSyncCallbackInfo");
static_assert(sizeof(UAkMusicSyncCallbackInfo) == 0x000070, "Wrong size on UAkMusicSyncCallbackInfo");
static_assert(offsetof(UAkMusicSyncCallbackInfo, PlayingID) == 0x000030, "Member 'UAkMusicSyncCallbackInfo::PlayingID' has a wrong offset!");
static_assert(offsetof(UAkMusicSyncCallbackInfo, SegmentInfo) == 0x000034, "Member 'UAkMusicSyncCallbackInfo::SegmentInfo' has a wrong offset!");
static_assert(offsetof(UAkMusicSyncCallbackInfo, MusicSyncType) == 0x000058, "Member 'UAkMusicSyncCallbackInfo::MusicSyncType' has a wrong offset!");
static_assert(offsetof(UAkMusicSyncCallbackInfo, UserCueName) == 0x000060, "Member 'UAkMusicSyncCallbackInfo::UserCueName' has a wrong offset!");

// Class AkAudio.AkItemBoolPropertiesConv
// 0x0000 (0x0028 - 0x0028)
class UAkItemBoolPropertiesConv final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_FAkBoolPropertyToControlToString(const struct FAkBoolPropertyToControl& INAkBoolPropertyToControl);
	static class FText Conv_FAkBoolPropertyToControlToText(const struct FAkBoolPropertyToControl& INAkBoolPropertyToControl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkItemBoolPropertiesConv">();
	}
	static class UAkItemBoolPropertiesConv* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkItemBoolPropertiesConv>();
	}
};
static_assert(alignof(UAkItemBoolPropertiesConv) == 0x000008, "Wrong alignment on UAkItemBoolPropertiesConv");
static_assert(sizeof(UAkItemBoolPropertiesConv) == 0x000028, "Wrong size on UAkItemBoolPropertiesConv");

// Class AkAudio.AkItemBoolProperties
// 0x0040 (0x0140 - 0x0100)
class UAkItemBoolProperties final : public UWidget
{
public:
	UMulticastDelegateProperty_                   OnSelectionChanged;                                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPropertyDragged;                                 // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSearchText(const class FString& NewText);

	class FString GetSearchText() const;
	class FString GetSelectedProperty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkItemBoolProperties">();
	}
	static class UAkItemBoolProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkItemBoolProperties>();
	}
};
static_assert(alignof(UAkItemBoolProperties) == 0x000008, "Wrong alignment on UAkItemBoolProperties");
static_assert(sizeof(UAkItemBoolProperties) == 0x000140, "Wrong size on UAkItemBoolProperties");
static_assert(offsetof(UAkItemBoolProperties, OnSelectionChanged) == 0x000100, "Member 'UAkItemBoolProperties::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UAkItemBoolProperties, OnPropertyDragged) == 0x000110, "Member 'UAkItemBoolProperties::OnPropertyDragged' has a wrong offset!");

// Class AkAudio.AkItemPropertiesConv
// 0x0000 (0x0028 - 0x0028)
class UAkItemPropertiesConv final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_FAkPropertyToControlToString(const struct FAkPropertyToControl& INAkPropertyToControl);
	static class FText Conv_FAkPropertyToControlToText(const struct FAkPropertyToControl& INAkPropertyToControl);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkItemPropertiesConv">();
	}
	static class UAkItemPropertiesConv* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkItemPropertiesConv>();
	}
};
static_assert(alignof(UAkItemPropertiesConv) == 0x000008, "Wrong alignment on UAkItemPropertiesConv");
static_assert(sizeof(UAkItemPropertiesConv) == 0x000028, "Wrong size on UAkItemPropertiesConv");

// Class AkAudio.AkItemProperties
// 0x0040 (0x0140 - 0x0100)
class UAkItemProperties final : public UWidget
{
public:
	UMulticastDelegateProperty_                   OnSelectionChanged;                                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPropertyDragged;                                 // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSearchText(const class FString& NewText);

	class FString GetSearchText() const;
	class FString GetSelectedProperty() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkItemProperties">();
	}
	static class UAkItemProperties* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkItemProperties>();
	}
};
static_assert(alignof(UAkItemProperties) == 0x000008, "Wrong alignment on UAkItemProperties");
static_assert(sizeof(UAkItemProperties) == 0x000140, "Wrong size on UAkItemProperties");
static_assert(offsetof(UAkItemProperties, OnSelectionChanged) == 0x000100, "Member 'UAkItemProperties::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UAkItemProperties, OnPropertyDragged) == 0x000110, "Member 'UAkItemProperties::OnPropertyDragged' has a wrong offset!");

// Class AkAudio.AkLateReverbComponent
// 0x0048 (0x0280 - 0x0238)
class UAkLateReverbComponent final : public USceneComponent
{
public:
	uint8                                         bEnable : 1;                                       // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAuxBus*                              AuxBus;                                            // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuxBusName;                                        // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendLevel;                                         // 0x0258(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x025C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0260(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_264[0x4];                                      // 0x0264(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkLateReverbComponent*                 NextLowerPriorityComponent;                        // 0x0268(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_270[0x10];                                     // 0x0270(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkLateReverbComponent">();
	}
	static class UAkLateReverbComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkLateReverbComponent>();
	}
};
static_assert(alignof(UAkLateReverbComponent) == 0x000008, "Wrong alignment on UAkLateReverbComponent");
static_assert(sizeof(UAkLateReverbComponent) == 0x000280, "Wrong size on UAkLateReverbComponent");
static_assert(offsetof(UAkLateReverbComponent, AuxBus) == 0x000240, "Member 'UAkLateReverbComponent::AuxBus' has a wrong offset!");
static_assert(offsetof(UAkLateReverbComponent, AuxBusName) == 0x000248, "Member 'UAkLateReverbComponent::AuxBusName' has a wrong offset!");
static_assert(offsetof(UAkLateReverbComponent, SendLevel) == 0x000258, "Member 'UAkLateReverbComponent::SendLevel' has a wrong offset!");
static_assert(offsetof(UAkLateReverbComponent, FadeRate) == 0x00025C, "Member 'UAkLateReverbComponent::FadeRate' has a wrong offset!");
static_assert(offsetof(UAkLateReverbComponent, Priority) == 0x000260, "Member 'UAkLateReverbComponent::Priority' has a wrong offset!");
static_assert(offsetof(UAkLateReverbComponent, NextLowerPriorityComponent) == 0x000268, "Member 'UAkLateReverbComponent::NextLowerPriorityComponent' has a wrong offset!");

// Class AkAudio.AkReverbVolume
// 0x0038 (0x0398 - 0x0360)
class AAkReverbVolume final : public AVolume
{
public:
	uint8                                         bEnabled : 1;                                      // 0x0360(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Deprecated, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_361[0x7];                                      // 0x0361(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAuxBus*                              AuxBus;                                            // 0x0368(0x0008)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuxBusName;                                        // 0x0370(0x0010)(ZeroConstructor, Deprecated, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         SendLevel;                                         // 0x0380(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FadeRate;                                          // 0x0384(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0388(0x0004)(ZeroConstructor, Deprecated, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38C[0x4];                                      // 0x038C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkLateReverbComponent*                 LateReverbComponent;                               // 0x0390(0x0008)(Edit, BlueprintVisible, ExportObject, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkReverbVolume">();
	}
	static class AAkReverbVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkReverbVolume>();
	}
};
static_assert(alignof(AAkReverbVolume) == 0x000008, "Wrong alignment on AAkReverbVolume");
static_assert(sizeof(AAkReverbVolume) == 0x000398, "Wrong size on AAkReverbVolume");
static_assert(offsetof(AAkReverbVolume, AuxBus) == 0x000368, "Member 'AAkReverbVolume::AuxBus' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, AuxBusName) == 0x000370, "Member 'AAkReverbVolume::AuxBusName' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, SendLevel) == 0x000380, "Member 'AAkReverbVolume::SendLevel' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, FadeRate) == 0x000384, "Member 'AAkReverbVolume::FadeRate' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, Priority) == 0x000388, "Member 'AAkReverbVolume::Priority' has a wrong offset!");
static_assert(offsetof(AAkReverbVolume, LateReverbComponent) == 0x000390, "Member 'AAkReverbVolume::LateReverbComponent' has a wrong offset!");

// Class AkAudio.AkRoomComponent
// 0x0028 (0x0260 - 0x0238)
class UAkRoomComponent final : public USceneComponent
{
public:
	uint8                                         bEnable : 1;                                       // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkRoomComponent*                       NextLowerPriorityComponent;                        // 0x0240(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Priority;                                          // 0x0248(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         WallOcclusion;                                     // 0x024C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_250[0x10];                                     // 0x0250(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkRoomComponent">();
	}
	static class UAkRoomComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkRoomComponent>();
	}
};
static_assert(alignof(UAkRoomComponent) == 0x000008, "Wrong alignment on UAkRoomComponent");
static_assert(sizeof(UAkRoomComponent) == 0x000260, "Wrong size on UAkRoomComponent");
static_assert(offsetof(UAkRoomComponent, NextLowerPriorityComponent) == 0x000240, "Member 'UAkRoomComponent::NextLowerPriorityComponent' has a wrong offset!");
static_assert(offsetof(UAkRoomComponent, Priority) == 0x000248, "Member 'UAkRoomComponent::Priority' has a wrong offset!");
static_assert(offsetof(UAkRoomComponent, WallOcclusion) == 0x00024C, "Member 'UAkRoomComponent::WallOcclusion' has a wrong offset!");

// Class AkAudio.AkSettings
// 0x0080 (0x00A8 - 0x0028)
class UAkSettings final : public UObject
{
public:
	uint8                                         MaxSimultaneousReverbVolumes;                      // 0x0028(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FFilePath                              WwiseProjectPath;                                  // 0x0030(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FDirectoryPath                         WwiseSoundBankFolder;                              // 0x0040(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          bAutoConnectToWAAPI;                               // 0x0050(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableMultiCoreRendering;                         // 0x0051(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECollisionChannel                             DefaultOcclusionCollisionChannel;                  // 0x0052(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53[0x5];                                       // 0x0053(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDirectoryPath                         WwiseWindowsInstallationPath;                      // 0x0058(0x0010)(Config, Deprecated, NativeAccessSpecifierPublic)
	struct FFilePath                              WwiseMacInstallationPath;                          // 0x0068(0x0010)(Config, Deprecated, NativeAccessSpecifierPublic)
	uint8                                         Pad_78[0x30];                                      // 0x0078(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkSettings">();
	}
	static class UAkSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkSettings>();
	}
};
static_assert(alignof(UAkSettings) == 0x000008, "Wrong alignment on UAkSettings");
static_assert(sizeof(UAkSettings) == 0x0000A8, "Wrong size on UAkSettings");
static_assert(offsetof(UAkSettings, MaxSimultaneousReverbVolumes) == 0x000028, "Member 'UAkSettings::MaxSimultaneousReverbVolumes' has a wrong offset!");
static_assert(offsetof(UAkSettings, WwiseProjectPath) == 0x000030, "Member 'UAkSettings::WwiseProjectPath' has a wrong offset!");
static_assert(offsetof(UAkSettings, WwiseSoundBankFolder) == 0x000040, "Member 'UAkSettings::WwiseSoundBankFolder' has a wrong offset!");
static_assert(offsetof(UAkSettings, bAutoConnectToWAAPI) == 0x000050, "Member 'UAkSettings::bAutoConnectToWAAPI' has a wrong offset!");
static_assert(offsetof(UAkSettings, bEnableMultiCoreRendering) == 0x000051, "Member 'UAkSettings::bEnableMultiCoreRendering' has a wrong offset!");
static_assert(offsetof(UAkSettings, DefaultOcclusionCollisionChannel) == 0x000052, "Member 'UAkSettings::DefaultOcclusionCollisionChannel' has a wrong offset!");
static_assert(offsetof(UAkSettings, WwiseWindowsInstallationPath) == 0x000058, "Member 'UAkSettings::WwiseWindowsInstallationPath' has a wrong offset!");
static_assert(offsetof(UAkSettings, WwiseMacInstallationPath) == 0x000068, "Member 'UAkSettings::WwiseMacInstallationPath' has a wrong offset!");

// Class AkAudio.AkSettingsPerUser
// 0x0028 (0x0050 - 0x0028)
class UAkSettingsPerUser final : public UObject
{
public:
	struct FDirectoryPath                         WwiseWindowsInstallationPath;                      // 0x0028(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	struct FFilePath                              WwiseMacInstallationPath;                          // 0x0038(0x0010)(Edit, Config, NativeAccessSpecifierPublic)
	bool                                          SuppressWwiseProjectPathWarnings;                  // 0x0048(0x0001)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_49[0x7];                                       // 0x0049(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkSettingsPerUser">();
	}
	static class UAkSettingsPerUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkSettingsPerUser>();
	}
};
static_assert(alignof(UAkSettingsPerUser) == 0x000008, "Wrong alignment on UAkSettingsPerUser");
static_assert(sizeof(UAkSettingsPerUser) == 0x000050, "Wrong size on UAkSettingsPerUser");
static_assert(offsetof(UAkSettingsPerUser, WwiseWindowsInstallationPath) == 0x000028, "Member 'UAkSettingsPerUser::WwiseWindowsInstallationPath' has a wrong offset!");
static_assert(offsetof(UAkSettingsPerUser, WwiseMacInstallationPath) == 0x000038, "Member 'UAkSettingsPerUser::WwiseMacInstallationPath' has a wrong offset!");
static_assert(offsetof(UAkSettingsPerUser, SuppressWwiseProjectPathWarnings) == 0x000048, "Member 'UAkSettingsPerUser::SuppressWwiseProjectPathWarnings' has a wrong offset!");

// Class AkAudio.AkSlider
// 0x0318 (0x0418 - 0x0100)
class UAkSlider final : public UWidget
{
public:
	float                                         Value;                                             // 0x0100(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_104[0x4];                                      // 0x0104(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TDelegate<void()>                             ValueDelegate;                                     // 0x0108(0x0010)(ZeroConstructor, InstancedReference, NoDestructor, NativeAccessSpecifierPublic)
	struct FSliderStyle                           WidgetStyle;                                       // 0x0118(0x0230)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	EOrientation                                  Orientation;                                       // 0x0348(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_349[0x3];                                      // 0x0349(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FLinearColor                           SliderBarColor;                                    // 0x034C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FLinearColor                           SliderHandleColor;                                 // 0x035C(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IndentHandle;                                      // 0x036C(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          Locked;                                            // 0x036D(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36E[0x2];                                      // 0x036E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StepSize;                                          // 0x0370(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsFocusable;                                       // 0x0374(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_375[0x3];                                      // 0x0375(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAkPropertyToControl                   ThePropertyToControl;                              // 0x0378(0x0010)(Edit, EditConst, NativeAccessSpecifierPublic)
	struct FAkWwiseItemToControl                  ItemToControl;                                     // 0x0388(0x0040)(Edit, Config, EditConst, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnValueChanged;                                    // 0x03C8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemDropped;                                     // 0x03D8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnPropertyDropped;                                 // 0x03E8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F8[0x20];                                     // 0x03F8(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetAkSliderItemId(const struct FGuid& ItemId);
	void SetAkSliderItemProperty(const class FString& ItemProperty);
	void SetIndentHandle(bool InValue);
	void SetLocked(bool InValue);
	void SetSliderBarColor(const struct FLinearColor& InValue);
	void SetSliderHandleColor(const struct FLinearColor& InValue);
	void SetStepSize(float InValue);
	void SetValue(float InValue);

	const struct FGuid GetAkSliderItemId() const;
	const class FString GetAkSliderItemProperty() const;
	float GetValue() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkSlider">();
	}
	static class UAkSlider* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkSlider>();
	}
};
static_assert(alignof(UAkSlider) == 0x000008, "Wrong alignment on UAkSlider");
static_assert(sizeof(UAkSlider) == 0x000418, "Wrong size on UAkSlider");
static_assert(offsetof(UAkSlider, Value) == 0x000100, "Member 'UAkSlider::Value' has a wrong offset!");
static_assert(offsetof(UAkSlider, ValueDelegate) == 0x000108, "Member 'UAkSlider::ValueDelegate' has a wrong offset!");
static_assert(offsetof(UAkSlider, WidgetStyle) == 0x000118, "Member 'UAkSlider::WidgetStyle' has a wrong offset!");
static_assert(offsetof(UAkSlider, Orientation) == 0x000348, "Member 'UAkSlider::Orientation' has a wrong offset!");
static_assert(offsetof(UAkSlider, SliderBarColor) == 0x00034C, "Member 'UAkSlider::SliderBarColor' has a wrong offset!");
static_assert(offsetof(UAkSlider, SliderHandleColor) == 0x00035C, "Member 'UAkSlider::SliderHandleColor' has a wrong offset!");
static_assert(offsetof(UAkSlider, IndentHandle) == 0x00036C, "Member 'UAkSlider::IndentHandle' has a wrong offset!");
static_assert(offsetof(UAkSlider, Locked) == 0x00036D, "Member 'UAkSlider::Locked' has a wrong offset!");
static_assert(offsetof(UAkSlider, StepSize) == 0x000370, "Member 'UAkSlider::StepSize' has a wrong offset!");
static_assert(offsetof(UAkSlider, IsFocusable) == 0x000374, "Member 'UAkSlider::IsFocusable' has a wrong offset!");
static_assert(offsetof(UAkSlider, ThePropertyToControl) == 0x000378, "Member 'UAkSlider::ThePropertyToControl' has a wrong offset!");
static_assert(offsetof(UAkSlider, ItemToControl) == 0x000388, "Member 'UAkSlider::ItemToControl' has a wrong offset!");
static_assert(offsetof(UAkSlider, OnValueChanged) == 0x0003C8, "Member 'UAkSlider::OnValueChanged' has a wrong offset!");
static_assert(offsetof(UAkSlider, OnItemDropped) == 0x0003D8, "Member 'UAkSlider::OnItemDropped' has a wrong offset!");
static_assert(offsetof(UAkSlider, OnPropertyDropped) == 0x0003E8, "Member 'UAkSlider::OnPropertyDropped' has a wrong offset!");

// Class AkAudio.AkSpatialAudioVolume
// 0x0018 (0x0378 - 0x0360)
class AAkSpatialAudioVolume final : public AVolume
{
public:
	class UAkSurfaceReflectorSetComponent*        SurfaceReflectorSet;                               // 0x0360(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkLateReverbComponent*                 LateReverb;                                        // 0x0368(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkRoomComponent*                       Room;                                              // 0x0370(0x0008)(Edit, BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, EditConst, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkSpatialAudioVolume">();
	}
	static class AAkSpatialAudioVolume* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkSpatialAudioVolume>();
	}
};
static_assert(alignof(AAkSpatialAudioVolume) == 0x000008, "Wrong alignment on AAkSpatialAudioVolume");
static_assert(sizeof(AAkSpatialAudioVolume) == 0x000378, "Wrong size on AAkSpatialAudioVolume");
static_assert(offsetof(AAkSpatialAudioVolume, SurfaceReflectorSet) == 0x000360, "Member 'AAkSpatialAudioVolume::SurfaceReflectorSet' has a wrong offset!");
static_assert(offsetof(AAkSpatialAudioVolume, LateReverb) == 0x000368, "Member 'AAkSpatialAudioVolume::LateReverb' has a wrong offset!");
static_assert(offsetof(AAkSpatialAudioVolume, Room) == 0x000370, "Member 'AAkSpatialAudioVolume::Room' has a wrong offset!");

// Class AkAudio.AkSpotReflector
// 0x0030 (0x0358 - 0x0328)
class AAkSpotReflector final : public AActor
{
public:
	class UAkAuxBus*                              AuxBus;                                            // 0x0328(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuxBusName;                                        // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAkAcousticTexture*                     AcousticTexture;                                   // 0x0340(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceScalingFactor;                             // 0x0348(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         Level;                                             // 0x034C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_350[0x8];                                      // 0x0350(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkSpotReflector">();
	}
	static class AAkSpotReflector* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAkSpotReflector>();
	}
};
static_assert(alignof(AAkSpotReflector) == 0x000008, "Wrong alignment on AAkSpotReflector");
static_assert(sizeof(AAkSpotReflector) == 0x000358, "Wrong size on AAkSpotReflector");
static_assert(offsetof(AAkSpotReflector, AuxBus) == 0x000328, "Member 'AAkSpotReflector::AuxBus' has a wrong offset!");
static_assert(offsetof(AAkSpotReflector, AuxBusName) == 0x000330, "Member 'AAkSpotReflector::AuxBusName' has a wrong offset!");
static_assert(offsetof(AAkSpotReflector, AcousticTexture) == 0x000340, "Member 'AAkSpotReflector::AcousticTexture' has a wrong offset!");
static_assert(offsetof(AAkSpotReflector, DistanceScalingFactor) == 0x000348, "Member 'AAkSpotReflector::DistanceScalingFactor' has a wrong offset!");
static_assert(offsetof(AAkSpotReflector, Level) == 0x00034C, "Member 'AAkSpotReflector::Level' has a wrong offset!");

// Class AkAudio.AkSurfaceReflectorSetComponent
// 0x0038 (0x0270 - 0x0238)
class UAkSurfaceReflectorSetComponent final : public USceneComponent
{
public:
	uint8                                         bEnableSurfaceReflectors : 1;                      // 0x0238(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_239[0x7];                                      // 0x0239(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAkPoly>                        AcousticPolys;                                     // 0x0240(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bEnableDiffraction : 1;                            // 0x0250(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bEnableDiffractionOnBoundaryEdges : 1;             // 0x0250(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_251[0x1F];                                     // 0x0251(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RemoveSurfaceReflectorSet();
	void SendSurfaceReflectorSet();
	void UpdateSurfaceReflectorSet();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkSurfaceReflectorSetComponent">();
	}
	static class UAkSurfaceReflectorSetComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkSurfaceReflectorSetComponent>();
	}
};
static_assert(alignof(UAkSurfaceReflectorSetComponent) == 0x000008, "Wrong alignment on UAkSurfaceReflectorSetComponent");
static_assert(sizeof(UAkSurfaceReflectorSetComponent) == 0x000270, "Wrong size on UAkSurfaceReflectorSetComponent");
static_assert(offsetof(UAkSurfaceReflectorSetComponent, AcousticPolys) == 0x000240, "Member 'UAkSurfaceReflectorSetComponent::AcousticPolys' has a wrong offset!");

// Class AkAudio.AkWaapiCalls
// 0x0000 (0x0028 - 0x0028)
class UAkWaapiCalls final : public UBlueprintFunctionLibrary
{
public:
	static struct FAKWaapiJsonObject CallWaapi(const struct FAkWaapiUri& WaapiUri, const struct FAKWaapiJsonObject& WaapiArgs, const struct FAKWaapiJsonObject& WaapiOptions);
	static class FString Conv_FAkWaapiSubscriptionIdToString(const struct FAkWaapiSubscriptionId& INAkWaapiSubscriptionId);
	static class FText Conv_FAkWaapiSubscriptionIdToText(const struct FAkWaapiSubscriptionId& INAkWaapiSubscriptionId);
	static int32 GetSubscriptionID(const struct FAkWaapiSubscriptionId& Subscription);
	static bool RegisterWaapiConnectionLostCallback(const TDelegate<void()>& Callback);
	static bool RegisterWaapiProjectLoadedCallback(const TDelegate<void()>& Callback);
	static void SetSubscriptionID(const struct FAkWaapiSubscriptionId& Subscription, int32 ID);
	static struct FAKWaapiJsonObject SubscribeToWaapi(const struct FAkWaapiUri& WaapiUri, const struct FAKWaapiJsonObject& WaapiOptions, const TDelegate<void(const struct FAkWaapiSubscriptionId& SubscriptionId, const struct FAKWaapiJsonObject& WaapiJsonObject)>& Callback, struct FAkWaapiSubscriptionId* SubscriptionId, bool* SubscriptionDone);
	static struct FAKWaapiJsonObject Unsubscribe(const struct FAkWaapiSubscriptionId& SubscriptionId, bool* UnsubscriptionDone);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkWaapiCalls">();
	}
	static class UAkWaapiCalls* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkWaapiCalls>();
	}
};
static_assert(alignof(UAkWaapiCalls) == 0x000008, "Wrong alignment on UAkWaapiCalls");
static_assert(sizeof(UAkWaapiCalls) == 0x000028, "Wrong size on UAkWaapiCalls");

// Class AkAudio.SAkWaapiFieldNamesConv
// 0x0000 (0x0028 - 0x0028)
class USAkWaapiFieldNamesConv final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_FAkWaapiFieldNamesToString(const struct FAkWaapiFieldNames& INAkWaapiFieldNames);
	static class FText Conv_FAkWaapiFieldNamesToText(const struct FAkWaapiFieldNames& INAkWaapiFieldNames);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"SAkWaapiFieldNamesConv">();
	}
	static class USAkWaapiFieldNamesConv* GetDefaultObj()
	{
		return GetDefaultObjImpl<USAkWaapiFieldNamesConv>();
	}
};
static_assert(alignof(USAkWaapiFieldNamesConv) == 0x000008, "Wrong alignment on USAkWaapiFieldNamesConv");
static_assert(sizeof(USAkWaapiFieldNamesConv) == 0x000028, "Wrong size on USAkWaapiFieldNamesConv");

// Class AkAudio.AkWaapiJsonManager
// 0x0000 (0x0028 - 0x0028)
class UAkWaapiJsonManager final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_FAKWaapiJsonObjectToString(const struct FAKWaapiJsonObject& INAKWaapiJsonObject);
	static class FText Conv_FAKWaapiJsonObjectToText(const struct FAKWaapiJsonObject& INAKWaapiJsonObject);
	static const TArray<struct FAKWaapiJsonObject> GetArrayField(const struct FAkWaapiFieldNames& FieldName, const struct FAKWaapiJsonObject& Target);
	static bool GetBoolField(const struct FAkWaapiFieldNames& FieldName, const struct FAKWaapiJsonObject& Target);
	static int32 GetIntegerField(const struct FAkWaapiFieldNames& FieldName, const struct FAKWaapiJsonObject& Target);
	static float GetNumberField(const struct FAkWaapiFieldNames& FieldName, const struct FAKWaapiJsonObject& Target);
	static struct FAKWaapiJsonObject GetObjectField(const struct FAkWaapiFieldNames& FieldName, const struct FAKWaapiJsonObject& Target);
	static class FString GetStringField(const struct FAkWaapiFieldNames& FieldName, const struct FAKWaapiJsonObject& Target);
	static struct FAKWaapiJsonObject SetArrayObjectFields(const struct FAkWaapiFieldNames& FieldName, const TArray<struct FAKWaapiJsonObject>& FieldObjectValues, const struct FAKWaapiJsonObject& Target);
	static struct FAKWaapiJsonObject SetArrayStringFields(const struct FAkWaapiFieldNames& FieldName, const TArray<class FString>& FieldStringValues, const struct FAKWaapiJsonObject& Target);
	static struct FAKWaapiJsonObject SetBoolField(const struct FAkWaapiFieldNames& FieldName, bool FieldValue, const struct FAKWaapiJsonObject& Target);
	static struct FAKWaapiJsonObject SetNumberField(const struct FAkWaapiFieldNames& FieldName, float FieldValue, const struct FAKWaapiJsonObject& Target);
	static struct FAKWaapiJsonObject SetObjectField(const struct FAkWaapiFieldNames& FieldName, const struct FAKWaapiJsonObject& FieldValue, const struct FAKWaapiJsonObject& Target);
	static struct FAKWaapiJsonObject SetStringField(const struct FAkWaapiFieldNames& FieldName, const class FString& FieldValue, const struct FAKWaapiJsonObject& Target);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkWaapiJsonManager">();
	}
	static class UAkWaapiJsonManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkWaapiJsonManager>();
	}
};
static_assert(alignof(UAkWaapiJsonManager) == 0x000008, "Wrong alignment on UAkWaapiJsonManager");
static_assert(sizeof(UAkWaapiJsonManager) == 0x000028, "Wrong size on UAkWaapiJsonManager");

// Class AkAudio.AkWaapiUriConv
// 0x0000 (0x0028 - 0x0028)
class UAkWaapiUriConv final : public UBlueprintFunctionLibrary
{
public:
	static class FString Conv_FAkWaapiUriToString(const struct FAkWaapiUri& INAkWaapiUri);
	static class FText Conv_FAkWaapiUriToText(const struct FAkWaapiUri& INAkWaapiUri);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkWaapiUriConv">();
	}
	static class UAkWaapiUriConv* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkWaapiUriConv>();
	}
};
static_assert(alignof(UAkWaapiUriConv) == 0x000008, "Wrong alignment on UAkWaapiUriConv");
static_assert(sizeof(UAkWaapiUriConv) == 0x000028, "Wrong size on UAkWaapiUriConv");

// Class AkAudio.AkWwiseTree
// 0x0040 (0x0140 - 0x0100)
class UAkWwiseTree final : public UWidget
{
public:
	UMulticastDelegateProperty_                   OnSelectionChanged;                                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemDragged;                                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x20];                                     // 0x0120(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetSearchText(const class FString& NewText);

	class FString GetSearchText() const;
	struct FAkWwiseObjectDetails GetSelectedItem() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkWwiseTree">();
	}
	static class UAkWwiseTree* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkWwiseTree>();
	}
};
static_assert(alignof(UAkWwiseTree) == 0x000008, "Wrong alignment on UAkWwiseTree");
static_assert(sizeof(UAkWwiseTree) == 0x000140, "Wrong size on UAkWwiseTree");
static_assert(offsetof(UAkWwiseTree, OnSelectionChanged) == 0x000100, "Member 'UAkWwiseTree::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UAkWwiseTree, OnItemDragged) == 0x000110, "Member 'UAkWwiseTree::OnItemDragged' has a wrong offset!");

// Class AkAudio.AkWwiseTreeSelector
// 0x0060 (0x0160 - 0x0100)
class UAkWwiseTreeSelector final : public UWidget
{
public:
	UMulticastDelegateProperty_                   OnSelectionChanged;                                // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnItemDragged;                                     // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_120[0x40];                                     // 0x0120(0x0040)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AkWwiseTreeSelector">();
	}
	static class UAkWwiseTreeSelector* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAkWwiseTreeSelector>();
	}
};
static_assert(alignof(UAkWwiseTreeSelector) == 0x000008, "Wrong alignment on UAkWwiseTreeSelector");
static_assert(sizeof(UAkWwiseTreeSelector) == 0x000160, "Wrong size on UAkWwiseTreeSelector");
static_assert(offsetof(UAkWwiseTreeSelector, OnSelectionChanged) == 0x000100, "Member 'UAkWwiseTreeSelector::OnSelectionChanged' has a wrong offset!");
static_assert(offsetof(UAkWwiseTreeSelector, OnItemDragged) == 0x000110, "Member 'UAkWwiseTreeSelector::OnItemDragged' has a wrong offset!");

// Class AkAudio.InterpTrackAkAudioEvent
// 0x0018 (0x00A8 - 0x0090)
class UInterpTrackAkAudioEvent final : public UInterpTrackVectorBase
{
public:
	TArray<struct FAkAudioEventTrackKey>          Events;                                            // 0x0090(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         bContinueEventOnMatineeEnd : 1;                    // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackAkAudioEvent">();
	}
	static class UInterpTrackAkAudioEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackAkAudioEvent>();
	}
};
static_assert(alignof(UInterpTrackAkAudioEvent) == 0x000008, "Wrong alignment on UInterpTrackAkAudioEvent");
static_assert(sizeof(UInterpTrackAkAudioEvent) == 0x0000A8, "Wrong size on UInterpTrackAkAudioEvent");
static_assert(offsetof(UInterpTrackAkAudioEvent, Events) == 0x000090, "Member 'UInterpTrackAkAudioEvent::Events' has a wrong offset!");

// Class AkAudio.InterpTrackAkAudioRTPC
// 0x0018 (0x00A8 - 0x0090)
class UInterpTrackAkAudioRTPC final : public UInterpTrackFloatBase
{
public:
	class FString                                 Param;                                             // 0x0090(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         bPlayOnReverse : 1;                                // 0x00A0(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         bContinueRTPCOnMatineeEnd : 1;                     // 0x00A0(0x0001)(BitIndex: 0x01, PropSize: 0x0001 (Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic))
	uint8                                         Pad_A1[0x7];                                       // 0x00A1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackAkAudioRTPC">();
	}
	static class UInterpTrackAkAudioRTPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackAkAudioRTPC>();
	}
};
static_assert(alignof(UInterpTrackAkAudioRTPC) == 0x000008, "Wrong alignment on UInterpTrackAkAudioRTPC");
static_assert(sizeof(UInterpTrackAkAudioRTPC) == 0x0000A8, "Wrong size on UInterpTrackAkAudioRTPC");
static_assert(offsetof(UInterpTrackAkAudioRTPC, Param) == 0x000090, "Member 'UInterpTrackAkAudioRTPC::Param' has a wrong offset!");

// Class AkAudio.InterpTrackInstAkAudioEvent
// 0x0008 (0x0030 - 0x0028)
class UInterpTrackInstAkAudioEvent final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstAkAudioEvent">();
	}
	static class UInterpTrackInstAkAudioEvent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstAkAudioEvent>();
	}
};
static_assert(alignof(UInterpTrackInstAkAudioEvent) == 0x000008, "Wrong alignment on UInterpTrackInstAkAudioEvent");
static_assert(sizeof(UInterpTrackInstAkAudioEvent) == 0x000030, "Wrong size on UInterpTrackInstAkAudioEvent");
static_assert(offsetof(UInterpTrackInstAkAudioEvent, LastUpdatePosition) == 0x000028, "Member 'UInterpTrackInstAkAudioEvent::LastUpdatePosition' has a wrong offset!");

// Class AkAudio.InterpTrackInstAkAudioRTPC
// 0x0008 (0x0030 - 0x0028)
class UInterpTrackInstAkAudioRTPC final : public UInterpTrackInst
{
public:
	float                                         LastUpdatePosition;                                // 0x0028(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"InterpTrackInstAkAudioRTPC">();
	}
	static class UInterpTrackInstAkAudioRTPC* GetDefaultObj()
	{
		return GetDefaultObjImpl<UInterpTrackInstAkAudioRTPC>();
	}
};
static_assert(alignof(UInterpTrackInstAkAudioRTPC) == 0x000008, "Wrong alignment on UInterpTrackInstAkAudioRTPC");
static_assert(sizeof(UInterpTrackInstAkAudioRTPC) == 0x000030, "Wrong size on UInterpTrackInstAkAudioRTPC");
static_assert(offsetof(UInterpTrackInstAkAudioRTPC, LastUpdatePosition) == 0x000028, "Member 'UInterpTrackInstAkAudioRTPC::LastUpdatePosition' has a wrong offset!");

// Class AkAudio.MovieSceneAkAudioEventSection
// 0x00E8 (0x01C8 - 0x00E0)
class UMovieSceneAkAudioEventSection final : public UMovieSceneSection
{
public:
	uint8                                         Pad_E0[0x40];                                      // 0x00E0(0x0040)(Fixing Size After Last Property [ Dumper-7 ])
	class UAkAudioEvent*                          Event;                                             // 0x0120(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          RetriggerEvent;                                    // 0x0128(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         ScrubTailLengthMs;                                 // 0x012C(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          StopAtSectionEnd;                                  // 0x0130(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_131[0x7];                                      // 0x0131(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EventName;                                         // 0x0138(0x0010)(Edit, ZeroConstructor, AdvancedDisplay, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_148[0x20];                                     // 0x0148(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MaxSourceDuration;                                 // 0x0168(0x0004)(Edit, ZeroConstructor, EditConst, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MaxDurationSourceID;                               // 0x0170(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_180[0x48];                                     // 0x0180(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneAkAudioEventSection">();
	}
	static class UMovieSceneAkAudioEventSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneAkAudioEventSection>();
	}
};
static_assert(alignof(UMovieSceneAkAudioEventSection) == 0x000008, "Wrong alignment on UMovieSceneAkAudioEventSection");
static_assert(sizeof(UMovieSceneAkAudioEventSection) == 0x0001C8, "Wrong size on UMovieSceneAkAudioEventSection");
static_assert(offsetof(UMovieSceneAkAudioEventSection, Event) == 0x000120, "Member 'UMovieSceneAkAudioEventSection::Event' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioEventSection, RetriggerEvent) == 0x000128, "Member 'UMovieSceneAkAudioEventSection::RetriggerEvent' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioEventSection, ScrubTailLengthMs) == 0x00012C, "Member 'UMovieSceneAkAudioEventSection::ScrubTailLengthMs' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioEventSection, StopAtSectionEnd) == 0x000130, "Member 'UMovieSceneAkAudioEventSection::StopAtSectionEnd' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioEventSection, EventName) == 0x000138, "Member 'UMovieSceneAkAudioEventSection::EventName' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioEventSection, MaxSourceDuration) == 0x000168, "Member 'UMovieSceneAkAudioEventSection::MaxSourceDuration' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioEventSection, MaxDurationSourceID) == 0x000170, "Member 'UMovieSceneAkAudioEventSection::MaxDurationSourceID' has a wrong offset!");

// Class AkAudio.MovieSceneAkTrack
// 0x0018 (0x0070 - 0x0058)
class UMovieSceneAkTrack : public UMovieSceneTrack
{
public:
	TArray<class UMovieSceneSection*>             Sections;                                          // 0x0058(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, Protected, NativeAccessSpecifierProtected)
	uint8                                         bIsAMasterTrack : 1;                               // 0x0068(0x0001)(BitIndex: 0x00, PropSize: 0x0001 (NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected))
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneAkTrack">();
	}
	static class UMovieSceneAkTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneAkTrack>();
	}
};
static_assert(alignof(UMovieSceneAkTrack) == 0x000008, "Wrong alignment on UMovieSceneAkTrack");
static_assert(sizeof(UMovieSceneAkTrack) == 0x000070, "Wrong size on UMovieSceneAkTrack");
static_assert(offsetof(UMovieSceneAkTrack, Sections) == 0x000058, "Member 'UMovieSceneAkTrack::Sections' has a wrong offset!");

// Class AkAudio.MovieSceneAkAudioEventTrack
// 0x0000 (0x0070 - 0x0070)
class UMovieSceneAkAudioEventTrack final : public UMovieSceneAkTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneAkAudioEventTrack">();
	}
	static class UMovieSceneAkAudioEventTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneAkAudioEventTrack>();
	}
};
static_assert(alignof(UMovieSceneAkAudioEventTrack) == 0x000008, "Wrong alignment on UMovieSceneAkAudioEventTrack");
static_assert(sizeof(UMovieSceneAkAudioEventTrack) == 0x000070, "Wrong size on UMovieSceneAkAudioEventTrack");

// Class AkAudio.MovieSceneAkAudioRTPCSection
// 0x0150 (0x0230 - 0x00E0)
class UMovieSceneAkAudioRTPCSection final : public UMovieSceneSection
{
public:
	class FString                                 Name_0;                                            // 0x00E0(0x0010)(Edit, ZeroConstructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	struct FRichCurve                             FloatCurve;                                        // 0x00F0(0x0070)(Protected, NativeAccessSpecifierProtected)
	struct FMovieSceneFloatChannelSerializationHelper FloatChannelSerializationHelper;                   // 0x0160(0x0030)(Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_190[0xA0];                                     // 0x0190(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneAkAudioRTPCSection">();
	}
	static class UMovieSceneAkAudioRTPCSection* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneAkAudioRTPCSection>();
	}
};
static_assert(alignof(UMovieSceneAkAudioRTPCSection) == 0x000008, "Wrong alignment on UMovieSceneAkAudioRTPCSection");
static_assert(sizeof(UMovieSceneAkAudioRTPCSection) == 0x000230, "Wrong size on UMovieSceneAkAudioRTPCSection");
static_assert(offsetof(UMovieSceneAkAudioRTPCSection, Name_0) == 0x0000E0, "Member 'UMovieSceneAkAudioRTPCSection::Name_0' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioRTPCSection, FloatCurve) == 0x0000F0, "Member 'UMovieSceneAkAudioRTPCSection::FloatCurve' has a wrong offset!");
static_assert(offsetof(UMovieSceneAkAudioRTPCSection, FloatChannelSerializationHelper) == 0x000160, "Member 'UMovieSceneAkAudioRTPCSection::FloatChannelSerializationHelper' has a wrong offset!");

// Class AkAudio.MovieSceneAkAudioRTPCTrack
// 0x0000 (0x0070 - 0x0070)
class UMovieSceneAkAudioRTPCTrack final : public UMovieSceneAkTrack
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"MovieSceneAkAudioRTPCTrack">();
	}
	static class UMovieSceneAkAudioRTPCTrack* GetDefaultObj()
	{
		return GetDefaultObjImpl<UMovieSceneAkAudioRTPCTrack>();
	}
};
static_assert(alignof(UMovieSceneAkAudioRTPCTrack) == 0x000008, "Wrong alignment on UMovieSceneAkAudioRTPCTrack");
static_assert(sizeof(UMovieSceneAkAudioRTPCTrack) == 0x000070, "Wrong size on UMovieSceneAkAudioRTPCTrack");

}

