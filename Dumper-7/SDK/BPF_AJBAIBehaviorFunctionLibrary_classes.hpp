#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPF_AJBAIBehaviorFunctionLibrary

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BPF_AJBAIBehaviorFunctionLibrary.BPF_AJBAIBehaviorFunctionLibrary_C
// 0x0000 (0x0028 - 0x0028)
class UBPF_AJBAIBehaviorFunctionLibrary_C final : public UBlueprintFunctionLibrary
{
public:
	static bool BeingDamagedFromUnfocusingEnemy(class AAIController* AI_Controller, const struct FBlackboardKeySelector& RO_FocusingEnemy, class UObject* __WorldContext);
	static class ABP_AJBAIGionSource_C* FindAttackingGionToPayAttention(class AAIController* AI_Controller, const struct FBlackboardKeySelector& FocusingEnemyKey, float AttackGionRadiusThresh, class UObject* __WorldContext);
	static struct FVector CalcRelativeLocationForFakeAttack(class AAIController* AI_Controller, const struct FBlackboardKeySelector& TargetEnemyKey, class UObject* __WorldContext);
	static struct FVector AI_DirectionOfCharacters(class ABP_AJBInGameAIImaginaryCharacter_C* From, class ABP_AJBInGameAIImaginaryCharacter_C* To, class UObject* __WorldContext);
	static struct FVector AI_DiffOfCharacters(class ABP_AJBInGameAIImaginaryCharacter_C* From, class ABP_AJBInGameAIImaginaryCharacter_C* To, class UObject* __WorldContext);
	static bool AI_IsRightwardVector(const struct FVector& BaseDirection, const struct FVector& TargetDirection, class UObject* __WorldContext);
	static struct FVector AI_RemoveZ(const struct FVector& Vector, class UObject* __WorldContext);
	static bool AI_IsTargetCharacterRightward(class ABP_AJBInGameAIImaginaryCharacter_C* SelfCharacter, class ABP_AJBInGameAIImaginaryCharacter_C* TargetCharacter, class UObject* __WorldContext);
	static struct FVector AI_RightwardDirectionToDiff(class ABP_AJBInGameAIImaginaryCharacter_C* SelfCharacter, class ABP_AJBInGameAIImaginaryCharacter_C* TargetCharacter, class UObject* __WorldContext);
	static float AI_GetFloatValueWithDeviation(float Base, float Deviation, class UObject* __WorldContext);
	static class AActor* GetRawActorFromBlackboardCharacterValue(class UObject* CharacterObject, class UObject* __WorldContext);
	static struct FVector AI_ProjectVectorOnCharacterForwardRightZero(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryCharacter, const struct FVector& V, class UObject* __WorldContext);
	static float AI_ProjectedVectorSignedLength(const struct FVector& V, const struct FVector& Target, class UObject* __WorldContext);
	static TArray<class AActor*> FindHouseInfosInRange(class AAIController* AIController, float MaxDistance, float CullingRadiusRatioByBlockUnitSize, class UObject* __WorldContext);
	static float AI_VectorDiffSq(const struct FVector& v1, const struct FVector& v2, class UObject* __WorldContext);
	static float AI_VectorDiffXYSq(const struct FVector& v1, const struct FVector& v2, class UObject* __WorldContext);
	static class AActor* AI_GetNearestXYActor(class AAIController* AI_Controller, TArray<class AActor*>& Actors, class UObject* __WorldContext);
	static float AI_VectorNormalizeAndDot(const struct FVector& v1, const struct FVector& v2, class UObject* __WorldContext);
	static bool IsPathValidAndReachable(class UBP_AJBInGameAIRecognition_C* Recognition, class UNavigationPath* NavigationPath, const struct FVector& Destination, float DistanceThreshold, class UObject* __WorldContext);
	static void GetGateInteractLocations(class AActor* GateActor, class UObject* __WorldContext, struct FVector* Location1, struct FVector* Location2, bool* bIsLocation1InHouse, bool* bIsLocation2InHouse);
	static void FindNearestSpotInEnvironmentBlocks(class UBP_AJBInGameAIRecognition_C* Recognition, const struct FVector& LocationToPayAttention, float MaxDistanceFromHouseCenter, bool bExceptBlockOfLocationToPayAttention, class UObject* __WorldContext, bool* WaySpotFound, struct FVector* WaySpotLocation, class AActor** House);
	static void AI_TrapExistsForward(class AAIController* AI_Controller, float DistanceXYThreshold, float ForwardDegreeThreshold, class UObject* __WorldContext, class AActor** TrapActor);
	static struct FVector AI_RemoveZNormalize(const struct FVector& Vector, class UObject* __WorldContext);
	static class ABP_AJBInGameAIImaginaryCharacter_C* GetControllingImaginaryCharacter(class AAIController* AIController, class UObject* __WorldContext);
	static class ABP_AJBInGameAIImaginaryCharacter_C* GetImaginaryCharacterBody(class AAIController* AIController, class UObject* __WorldContext);
	static class ABP_AJBInGameAIImaginaryCharacter_C* GetImaginaryCharacterMovableStand(class AAIController* AIController, class UObject* __WorldContext);
	static struct FVector AI_AddZ(const struct FVector& Vector, float Z, class UObject* __WorldContext);
	static void FindSpotAroundInEnvironmentBlocks(class UBP_AJBInGameAIRecognition_C* Recognition, float MaxDistanceFromHouseCenter, bool bExceptBlockOfLocationToPayAttention, class UObject* __WorldContext, struct FVector* WaySpotLocation, class AActor** House);
	static struct FVector AI_RandomVectorInRangeXY(const struct FVector& VMin, const struct FVector& VMax, class UObject* __WorldContext);
	static float AI_CyclicFloatBySineCurve(float MinValue, float MaxValue, float DeltaSeconds, float TimeOfOneCycle, class UObject* __WorldContext);
	static bool IsAIGionOwnerPlayer(class AAIController* AI_Controller, class ABP_AJBAIGionSource_C* AI_GionSource, class UObject* __WorldContext);
	static struct FGameplayTag CheckNaviTagAboutSafeArea(class UBP_AJBInGameAIRecognition_C* Recognition, class UObject* __WorldContext);
	static struct FVector AI_ChooseXYNearerLocation(const struct FVector& BaseLocation, const struct FVector& Location1, const struct FVector& Location2, class UObject* __WorldContext);
	static void AI_XYNearer(const struct FVector& BaseLocation, const struct FVector& Location1, const struct FVector& Location2, class UObject* __WorldContext, bool* IfLocation1Nearer);
	static struct FVector GetInteractDirectionForGate(class UBP_AJBInGameAIRecognition_C* Recognition, class AActor* GateActor, const struct FVector& StandPoint, class UObject* __WorldContext);
	static struct FVector AI_FindVacantDirectionAround(class UBP_AJBInGameAIRecognition_C* Recognition, const struct FVector& OriginalDirection, float Distance, bool bDebugDraw, class UObject* __WorldContext, bool* Found);
	static bool AI_IsHitSomethingForDestination(class UBP_AJBInGameAIRecognition_C* Recognition, float JumpOffset, const struct FVector& Destination, bool bDebugDraw, class UObject* __WorldContext, struct FVector* DestinationOut);
	static bool AI_IsHitSomethingForDestinationByImaginaryCharacter(class ABP_AJBInGameAIImaginaryCharacter_C* ControllingImaginaryCharacter, float JumpOffset, const struct FVector& Destination, bool bDebugDraw, class UObject* __WorldContext, struct FVector* DestinationOut);
	static TArray<class ABP_AJBInGameItemSpawner_C*> GetReachableItemSpawners(class UBP_AJBInGameAIRecognition_C* Recognition, TArray<class ABP_AJBInGameItemSpawner_C*>& ItemSpawnersIn, class UObject* __WorldContext);
	static void FindHouseInfoInEnvironmentBlock(class UAJBAIEnvironmentBlock* EnvironmentBlock, class AActor* House, class UObject* __WorldContext, class ABP_AJBAIHouseInfo_C** AsHouseInfo);
	static struct FVector AI_DirectionXYOfCharacters(class ABP_AJBInGameAIImaginaryCharacter_C* From, class ABP_AJBInGameAIImaginaryCharacter_C* To, class UObject* __WorldContext);
	static struct FVector AI_DiffXYOfCharacters(class ABP_AJBInGameAIImaginaryCharacter_C* From, class ABP_AJBInGameAIImaginaryCharacter_C* To, class UObject* __WorldContext);
	static void AI_CanReachEnemyIfJumpOver(class UBP_AJBInGameAIRecognition_C* Recognition, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginarySelf, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryEnemy, float DistanceThreshToObstacle, class UObject* __WorldContext, struct FGameplayTag* JumpTagOrEmpty);
	static void AI_CanSHAReachEnemyIfJumpOver(class UBP_AJBInGameAIRecognition_C* Recognition, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginarySelf, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryEnemy, float DistanceThreshToObstacle, class UObject* __WorldContext, struct FGameplayTag* JumpTypeOrEmpty);
	static class ABP_AJBAIHouseInfo_C* FindHouseCharacterOn(class UBP_AJBInGameAIRecognition_C* Recognition, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryCharacter, class UObject* __WorldContext);
	static void AI_CanReachLocationIfJumpOver(class UBP_AJBInGameAIRecognition_C* Recognition, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginarySelf, const struct FVector& TargetLocation, float DistanceThreshToObstacle, class UObject* __WorldContext, struct FGameplayTag* JumpTagOrEmpty);
	static class ABP_AJBAIHouseInfo_C* FindHouseOnLocation(class UBP_AJBInGameAIRecognition_C* Recognition, const struct FVector& BreastLocation, class UObject* __WorldContext);
	static void AI_CanSHAReachLocationIfJumpOver(class UBP_AJBInGameAIRecognition_C* Recognition, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginarySelf, const struct FVector& TargetLocation, float DistanceThreshToObstacle, class UObject* __WorldContext, struct FGameplayTag* JumpTypeOrEmpty);
	static void CollideIfJumpHere(const struct FGameplayTag& TraceInfoTag, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginarySelf, float JumpHeight, class UObject* __WorldContext, struct FHitResult* HitResult, bool* IsCollided);
	static void ExpectedToCollideEvenIfJump(const struct FGameplayTag& TraceInfoTag, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginarySelf, float JumpHeight, const struct FVector& TargetLocation, class UObject* __WorldContext, struct FHitResult* HitResult, bool* IsCollided);
	static void IsReachableWithFalling(const struct FGameplayTag& TraceInfoTag, class ABP_AJBInGameAIImaginaryCharacter_C* ImaginarySelf, float JumpHeight, const struct FVector& TargetLocation, class UObject* __WorldContext, bool* IsReachable);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BPF_AJBAIBehaviorFunctionLibrary_C">();
	}
	static class UBPF_AJBAIBehaviorFunctionLibrary_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPF_AJBAIBehaviorFunctionLibrary_C>();
	}
};
static_assert(alignof(UBPF_AJBAIBehaviorFunctionLibrary_C) == 0x000008, "Wrong alignment on UBPF_AJBAIBehaviorFunctionLibrary_C");
static_assert(sizeof(UBPF_AJBAIBehaviorFunctionLibrary_C) == 0x000028, "Wrong size on UBPF_AJBAIBehaviorFunctionLibrary_C");

}

