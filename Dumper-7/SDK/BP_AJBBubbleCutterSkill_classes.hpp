#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBBubbleCutterSkill

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AJB_structs.hpp"
#include "BP_AJBChargeSnipeSkill_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_AJBBubbleCutterSkill.BP_AJBBubbleCutterSkill_C
// 0x0100 (0x0448 - 0x0348)
class UBP_AJBBubbleCutterSkill_C final : public UBP_AJBChargeSnipeSkill_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_AJBBubbleCutterSkill_C;          // 0x0348(0x0008)(Transient, DuplicateTransient)
	float                                         DamageRateToVampire___;                            // 0x0350(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHamonRateEnabled;                                // 0x0354(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_355[0x3];                                      // 0x0355(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class AActor*>                         LockOnTargetableActors;                            // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, DisableEditOnInstance, AdvancedDisplay)
	float                                         LockOnRange_cm_;                                   // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EObjectTypeQuery>                      LockOnTraceObjectTypes;                            // 0x0370(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	TArray<struct FAJBLockOnTargetInfo>           LockingOnTargetsQueue;                             // 0x0380(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, AdvancedDisplay)
	float                                         LockOnFocusTime_s_;                                // 0x0390(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_394[0x4];                                      // 0x0394(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAJBLockOnTargetInfo>           RemovingReserved_LockingOnTargetsQueue;            // 0x0398(0x0010)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, AdvancedDisplay)
	TArray<class AActor*>                         LockedOnTargets_Server;                            // 0x03A8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, DisableEditOnInstance, AdvancedDisplay)
	float                                         OccludedTimeBuffer_s_;                             // 0x03B8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         OutOfScreenTimeBuffer_s_;                          // 0x03BC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LockOnRectSizeX;                                   // 0x03C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LockOnRectSizeY;                                   // 0x03C4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_AJBBubbleCutterLockOnChaseWidgetActor_C*> UsedChaseActorCache;                  // 0x03C8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, DisableEditOnInstance, AdvancedDisplay)
	bool                                          IsCutterDebugDisplayEnabled;                       // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	uint8                                         Pad_3D9[0x7];                                      // 0x03D9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           ShootingNormalProjectileSETag;                     // 0x03E0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           ShootingHamonProjectileSETag;                      // 0x03E8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           ProjectileShockWaveSETag;                          // 0x03F0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         FocusingOccludedTimeBuffer_s_;                     // 0x03F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3FC[0x4];                                      // 0x03FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<TSoftObjectPtr<class AActor>>          Rep_LockingOnTargets;                              // 0x0400(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, DisableEditOnInstance, RepNotify, AdvancedDisplay)
	TArray<EAJBLockOnState>                       Rep_LockingOnTargetsState;                         // 0x0410(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, DisableEditOnInstance, AdvancedDisplay)
	struct FGameplayTagContainer                  IgnoreingUnderWaterMaskTags;                       // 0x0420(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance)
	bool                                          HasRestoredLockingOnState;                         // 0x0440(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	uint8                                         Pad_441[0x3];                                      // 0x0441(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnderWaterBuffer_cm_;                              // 0x0444(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ExecuteUbergraph_BP_AJBBubbleCutterSkill(int32 EntryPoint);
	void ROC_OnUpdatedLockOnTargetableActors(const TArray<class AActor*>& LockOnTargetableActors_0);
	void InitLockOnTargets();
	void OnFinishedCharacterSetup(const struct FGameplayTag& PrevState);
	void OnReadyControlledCharacter(class AAJBInGameCharacterBase* TargetCharacter);
	void OnTargetSpawned_Server(const class ABP_AJBInGameCharacter_C* Actor);
	void BindCharacterSpawnedEvent();
	void ROS_SpawnProjectile(const struct FVector& Location, const struct FRotator& Rotation, int32 ProjectileIndex);
	void ROS_SetRockedOnTargets(const TArray<class AActor*>& LockedOnTargets);
	void DebugPrint_ScanLog(const class FText& Text);
	void SetDebugPrintPrefix(int32 Index_0, class AActor* Actor);
	void Close_DebugPrint_ScanResult();
	void Open_DebugPrint_ScanResult();
	void DebugPrint_ScanResult(const class FText& Text);
	void Debug_Tick();
	void Debug_BeginPlay();
	void OnInactivate_LockOn();
	void Resolve_ReservedRemoving_LockingOnTargetsQueue();
	void ShootProjectileEffect_Local(int32 ShootProjectileIndex);
	void OnChargeCompleted_Client(int32 ChargingPointCount, bool ShouldShowNextEffect);
	void Hide_ChargeSnipeSkillGuideUI();
	void Show_ChargeSnipeSkillGuideUI();
	void ReserveRemoving_LockingOnTargetsQueue(const struct FAJBLockOnTargetInfo& Info);
	void Tick_LockedOnTimer(float DeltaTime);
	void ScanLockedOnTargets();
	void ROS_Run_LockOnEffectSpecified(const struct FAJBLockOnTargetInfo& Info, EAJBLockOnState NewState);
	void MC_Run_LockOnEffectSpecified(const struct FAJBLockOnTargetInfo& Info, EAJBLockOnState NewState);
	void RestoreLockingOnState_SimulatedClient();
	void ClearLockingOnRepCache_Server();
	void OnRun_LockOnEffectSpecified_Server(const struct FAJBLockOnTargetInfo& Info, EAJBLockOnState NewState);
	void Run_EndLockOnEffect(const struct FAJBLockOnTargetInfo& Info);
	void Run_LockOnEffectSpecified_Local(const struct FAJBLockOnTargetInfo& Info, EAJBLockOnState NewState);
	void Run_LockOnEffectSpecified_OnAll(const struct FAJBLockOnTargetInfo& Info, EAJBLockOnState NewState);
	void Play_ShootProjectileGion(class USceneComponent* ChargingPoint);
	void Run_CancelLockOnEffect(const struct FAJBLockOnTargetInfo& Info);
	void Run_PreLockOnEffect(const struct FAJBLockOnTargetInfo& Info);
	void Run_LockOnEffect(const struct FAJBLockOnTargetInfo& Info);
	void RefreshAllLockOnQueueWidgetState();
	void Run_LockOnAttackEffectByIndex(int32 Index_0);
	void Run_LockOnAttackEffect(const struct FAJBLockOnTargetInfo& Info);
	void CancelAllLockOnWidget();
	void RefreshLockOnWidgetStateByIndex(int32 Index_0);
	void GetChargePoints(TArray<class USceneComponent*>* ChargingPoints);
	void GetOwnerHamonStatus(bool* bIsHamonMode);
	void CollectAllLockOnTargetableActors(TArray<class AActor*>* Targets);
	void IsLockOnTargetableActor(class AActor* Target, bool* IsTargetableActor);
	void GetLockOnScreenRect(struct FBox2D* ScreenRect);
	void CollectSamplingPoints(class AActor* Target, TArray<struct FVector>* SamplingPoints);
	void RefreshLockOnTargets();
	void EnqueueLockingOnTarget(const class AActor*& Target, struct FAJBLockOnTargetInfo* Output);
	void FindLockedOnTarget(class AActor* Target, bool* WasFound, struct FAJBLockOnTargetInfo* LockOnTargetInfo, int32* Index_0);
	void CollectLockedOnTargets(TArray<class AActor*>* LockedOnTarget);
	void IsFocusedOn(const struct FAJBLockOnTargetInfo& Info, bool* IsFocusedOn_0);
	void MakeLockOnTargetInfo(class AActor* Target, struct FAJBLockOnTargetInfo* Info);
	void GetLockedOnTarget_Server(int32 BulletIndex, class AActor** LockedOnTarget);
	void GetLockOnFocusTimeDefault(float* LockOnFocusTime);
	void GetOccludedTimeBufferDefault(float* OccludedTimeBuffer);
	void GetOutOfScreenTimeBufferDefault(float* OutOfScreenTimeBuffer);
	void GetLockOnRectSize(struct FVector2D* LockOnRectSize);
	void FindLockOnChaseActor(class AActor* Target, bool* WasFound, class ABP_AJBBubbleCutterLockOnChaseWidgetActor_C** ChaseActor);
	void CreateLockOnChaseActor(class AActor* Target, class ABP_AJBBubbleCutterLockOnChaseWidgetActor_C** ChaseActor);
	void FindOrCreateLockOnChaseActor(class AActor* Target, class ABP_AJBBubbleCutterLockOnChaseWidgetActor_C** ChaseActor);
	void GetLockOnTargetableActors(TArray<class AActor*>* LockOnTargetableActors_0);
	void ReduceInvalidLockOnTargets();
	void MakeLockOnState(const struct FAJBLockOnTargetInfo& Info, EAJBLockOnState* LockOnState);
	void GetShootingProjectileSETag(struct FGameplayTag* ShootProjectileSETag_0);
	void GetFocusingOccludedTimeBufferDefault(float* FocusingOccludedTimeBuffer);
	void Process_FocusedTimer(int32 InfoIndex, float DeltaTime);
	void Process_OccludedTimer(int32 InfoIndex, float DeltaTime);
	void Process_OutOfScreenTimer(int32 InfoIndex, float DeltaTime);
	void IsOccluded(const struct FAJBLockOnTargetInfo& Info, bool* IsOccluded_0);
	void IsOutOfScreen(const struct FAJBLockOnTargetInfo& Info, bool* IsOutOfScreen_0);
	void IsOccludedOverFocusingBuffer(const struct FAJBLockOnTargetInfo& Info, bool* IsOccluded);
	void ShouldLostTarget(class AActor* Target, bool* ShouldLost);
	void ProcessLostTarget(int32 InfoIndex);
	void OnRep_Rep_LockingOnTargets();
	void FindUnderWaterVisibleRadius(bool* IsMasked, float* Radius);
	void GetVampireDamageRate(float* VampireDamageRate);
	void ShouldApplyHamonRateDirectly(bool* ShouldApplyDirectly);
	void IsHamonRateEnabledSkill(bool* IsEnabled);
	void OnStateAction();
	void StateBeginPlay(bool bShouldRestore);
	void ReceiveBeginPlay();
	void OnInactive();
	void NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty);
	void ReceiveTick(float DeltaSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_AJBBubbleCutterSkill_C">();
	}
	static class UBP_AJBBubbleCutterSkill_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_AJBBubbleCutterSkill_C>();
	}
};
static_assert(alignof(UBP_AJBBubbleCutterSkill_C) == 0x000008, "Wrong alignment on UBP_AJBBubbleCutterSkill_C");
static_assert(sizeof(UBP_AJBBubbleCutterSkill_C) == 0x000448, "Wrong size on UBP_AJBBubbleCutterSkill_C");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, UberGraphFrame_BP_AJBBubbleCutterSkill_C) == 0x000348, "Member 'UBP_AJBBubbleCutterSkill_C::UberGraphFrame_BP_AJBBubbleCutterSkill_C' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, DamageRateToVampire___) == 0x000350, "Member 'UBP_AJBBubbleCutterSkill_C::DamageRateToVampire___' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, IsHamonRateEnabled) == 0x000354, "Member 'UBP_AJBBubbleCutterSkill_C::IsHamonRateEnabled' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockOnTargetableActors) == 0x000358, "Member 'UBP_AJBBubbleCutterSkill_C::LockOnTargetableActors' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockOnRange_cm_) == 0x000368, "Member 'UBP_AJBBubbleCutterSkill_C::LockOnRange_cm_' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockOnTraceObjectTypes) == 0x000370, "Member 'UBP_AJBBubbleCutterSkill_C::LockOnTraceObjectTypes' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockingOnTargetsQueue) == 0x000380, "Member 'UBP_AJBBubbleCutterSkill_C::LockingOnTargetsQueue' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockOnFocusTime_s_) == 0x000390, "Member 'UBP_AJBBubbleCutterSkill_C::LockOnFocusTime_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, RemovingReserved_LockingOnTargetsQueue) == 0x000398, "Member 'UBP_AJBBubbleCutterSkill_C::RemovingReserved_LockingOnTargetsQueue' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockedOnTargets_Server) == 0x0003A8, "Member 'UBP_AJBBubbleCutterSkill_C::LockedOnTargets_Server' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, OccludedTimeBuffer_s_) == 0x0003B8, "Member 'UBP_AJBBubbleCutterSkill_C::OccludedTimeBuffer_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, OutOfScreenTimeBuffer_s_) == 0x0003BC, "Member 'UBP_AJBBubbleCutterSkill_C::OutOfScreenTimeBuffer_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockOnRectSizeX) == 0x0003C0, "Member 'UBP_AJBBubbleCutterSkill_C::LockOnRectSizeX' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, LockOnRectSizeY) == 0x0003C4, "Member 'UBP_AJBBubbleCutterSkill_C::LockOnRectSizeY' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, UsedChaseActorCache) == 0x0003C8, "Member 'UBP_AJBBubbleCutterSkill_C::UsedChaseActorCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, IsCutterDebugDisplayEnabled) == 0x0003D8, "Member 'UBP_AJBBubbleCutterSkill_C::IsCutterDebugDisplayEnabled' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, ShootingNormalProjectileSETag) == 0x0003E0, "Member 'UBP_AJBBubbleCutterSkill_C::ShootingNormalProjectileSETag' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, ShootingHamonProjectileSETag) == 0x0003E8, "Member 'UBP_AJBBubbleCutterSkill_C::ShootingHamonProjectileSETag' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, ProjectileShockWaveSETag) == 0x0003F0, "Member 'UBP_AJBBubbleCutterSkill_C::ProjectileShockWaveSETag' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, FocusingOccludedTimeBuffer_s_) == 0x0003F8, "Member 'UBP_AJBBubbleCutterSkill_C::FocusingOccludedTimeBuffer_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, Rep_LockingOnTargets) == 0x000400, "Member 'UBP_AJBBubbleCutterSkill_C::Rep_LockingOnTargets' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, Rep_LockingOnTargetsState) == 0x000410, "Member 'UBP_AJBBubbleCutterSkill_C::Rep_LockingOnTargetsState' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, IgnoreingUnderWaterMaskTags) == 0x000420, "Member 'UBP_AJBBubbleCutterSkill_C::IgnoreingUnderWaterMaskTags' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, HasRestoredLockingOnState) == 0x000440, "Member 'UBP_AJBBubbleCutterSkill_C::HasRestoredLockingOnState' has a wrong offset!");
static_assert(offsetof(UBP_AJBBubbleCutterSkill_C, UnderWaterBuffer_cm_) == 0x000444, "Member 'UBP_AJBBubbleCutterSkill_C::UnderWaterBuffer_cm_' has a wrong offset!");

}

