#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AJB

#include "Basic.hpp"

#include "AJB_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "CoreUObject_classes.hpp"
#include "OnlineSubsystemUtils_classes.hpp"
#include "SlateCore_structs.hpp"
#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "GameplayTags_structs.hpp"
#include "UMG_structs.hpp"
#include "UMG_classes.hpp"
#include "GameDataStorage_classes.hpp"
#include "AIModule_classes.hpp"
#include "LevelSequence_classes.hpp"


namespace SDK
{

// Class AJB.AJBInGame2DGeoManager
// 0x0050 (0x0378 - 0x0328)
class AAJBInGame2DGeoManager : public AActor
{
public:
	float                                         StageSizeBuffer;                                   // 0x0328(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GridSize;                                          // 0x032C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageSize;                                         // 0x0330(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_334[0x4];                                      // 0x0334(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<bool>                                  GeoMap;                                            // 0x0338(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<float>                                 GeoDistanceMap;                                    // 0x0348(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	float                                         DebugDrawDistanceThreshold;                        // 0x0358(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugPointColorForTargetGeoType;                   // 0x035C(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugPointColorForNearTargetGeoType;               // 0x0360(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FColor                                 DebugPointColorForFarTargetGeoType;                // 0x0364(0x0004)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                DebugDisplayOffset;                                // 0x0368(0x000C)(Edit, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_374[0x4];                                      // 0x0374(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void UpdateGeographicData();
	void UpdateStageSize();

	float FindDistance(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGame2DGeoManager">();
	}
	static class AAJBInGame2DGeoManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGame2DGeoManager>();
	}
};
static_assert(alignof(AAJBInGame2DGeoManager) == 0x000008, "Wrong alignment on AAJBInGame2DGeoManager");
static_assert(sizeof(AAJBInGame2DGeoManager) == 0x000378, "Wrong size on AAJBInGame2DGeoManager");
static_assert(offsetof(AAJBInGame2DGeoManager, StageSizeBuffer) == 0x000328, "Member 'AAJBInGame2DGeoManager::StageSizeBuffer' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, GridSize) == 0x00032C, "Member 'AAJBInGame2DGeoManager::GridSize' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, StageSize) == 0x000330, "Member 'AAJBInGame2DGeoManager::StageSize' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, GeoMap) == 0x000338, "Member 'AAJBInGame2DGeoManager::GeoMap' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, GeoDistanceMap) == 0x000348, "Member 'AAJBInGame2DGeoManager::GeoDistanceMap' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, DebugDrawDistanceThreshold) == 0x000358, "Member 'AAJBInGame2DGeoManager::DebugDrawDistanceThreshold' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, DebugPointColorForTargetGeoType) == 0x00035C, "Member 'AAJBInGame2DGeoManager::DebugPointColorForTargetGeoType' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, DebugPointColorForNearTargetGeoType) == 0x000360, "Member 'AAJBInGame2DGeoManager::DebugPointColorForNearTargetGeoType' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, DebugPointColorForFarTargetGeoType) == 0x000364, "Member 'AAJBInGame2DGeoManager::DebugPointColorForFarTargetGeoType' has a wrong offset!");
static_assert(offsetof(AAJBInGame2DGeoManager, DebugDisplayOffset) == 0x000368, "Member 'AAJBInGame2DGeoManager::DebugDisplayOffset' has a wrong offset!");

// Class AJB.ActorCluster
// 0x0020 (0x0348 - 0x0328)
class AActorCluster final : public AActor
{
public:
	TArray<class AActor*>                         Actors;                                            // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                CenterLocation;                                    // 0x0338(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_344[0x4];                                      // 0x0344(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	struct FVector CalcCenterLocationOfActors() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorCluster">();
	}
	static class AActorCluster* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorCluster>();
	}
};
static_assert(alignof(AActorCluster) == 0x000008, "Wrong alignment on AActorCluster");
static_assert(sizeof(AActorCluster) == 0x000348, "Wrong size on AActorCluster");
static_assert(offsetof(AActorCluster, Actors) == 0x000328, "Member 'AActorCluster::Actors' has a wrong offset!");
static_assert(offsetof(AActorCluster, CenterLocation) == 0x000338, "Member 'AActorCluster::CenterLocation' has a wrong offset!");

// Class AJB.ActorClusterHost
// 0x0018 (0x0340 - 0x0328)
class AActorClusterHost final : public AActor
{
public:
	TArray<class AActorCluster*>                  Clusters;                                          // 0x0328(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bLocationXYOnly;                                   // 0x0338(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Clear();
	void ClusterKMeansPPByLocation(const TArray<class AActor*>& Actors, int32 CountOfCluster, int32 CountOfClusteringMax, bool bLocationXYOnlyArg);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ActorClusterHost">();
	}
	static class AActorClusterHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AActorClusterHost>();
	}
};
static_assert(alignof(AActorClusterHost) == 0x000008, "Wrong alignment on AActorClusterHost");
static_assert(sizeof(AActorClusterHost) == 0x000340, "Wrong size on AActorClusterHost");
static_assert(offsetof(AActorClusterHost, Clusters) == 0x000328, "Member 'AActorClusterHost::Clusters' has a wrong offset!");
static_assert(offsetof(AActorClusterHost, bLocationXYOnly) == 0x000338, "Member 'AActorClusterHost::bLocationXYOnly' has a wrong offset!");

// Class AJB.AJBInGameAIController
// 0x0000 (0x0438 - 0x0438)
class AAJBInGameAIController : public AAIController
{
public:
	class AActor* GetContextActor();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameAIController">();
	}
	static class AAJBInGameAIController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameAIController>();
	}
};
static_assert(alignof(AAJBInGameAIController) == 0x000008, "Wrong alignment on AAJBInGameAIController");
static_assert(sizeof(AAJBInGameAIController) == 0x000438, "Wrong size on AAJBInGameAIController");

// Class AJB.AJBAIEnvironmentBlock
// 0x00A8 (0x00D0 - 0x0028)
class UAJBAIEnvironmentBlock final : public UObject
{
public:
	TArray<struct FVector>                        StartPoints;                                       // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FVector>                        WaySpots;                                          // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         HouseInfos;                                        // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Doors;                                             // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         DoorsNotInHouse;                                   // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         WINDOWS;                                           // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Gates;                                             // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         Traps;                                             // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         BurningActors;                                     // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FVector                                Min;                                               // 0x00B8(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                Max;                                               // 0x00C4(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void AddBurningActor(class AActor* Actor);
	void AddDoor(class AActor* Actor, bool bIsNotInHouse);
	void AddGate(class AActor* Actor);
	void AddHouseInfo(class AActor* Actor);
	void AddStartPoint(const struct FVector& Location);
	void AddTrap(class AActor* Actor);
	void AddWaySpotByActor(const class AActor* Actor);
	void AddWaySpotByLocation(const struct FVector& Location);
	void AddWindow(class AActor* Actor);
	void RemoveBurningActor(class AActor* Actor);
	void RemoveTrap(class AActor* Actor);
	void ShrinkHalfOfWaySpots();

	struct FVector GetCenterLocation() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAIEnvironmentBlock">();
	}
	static class UAJBAIEnvironmentBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAIEnvironmentBlock>();
	}
};
static_assert(alignof(UAJBAIEnvironmentBlock) == 0x000008, "Wrong alignment on UAJBAIEnvironmentBlock");
static_assert(sizeof(UAJBAIEnvironmentBlock) == 0x0000D0, "Wrong size on UAJBAIEnvironmentBlock");
static_assert(offsetof(UAJBAIEnvironmentBlock, StartPoints) == 0x000028, "Member 'UAJBAIEnvironmentBlock::StartPoints' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, WaySpots) == 0x000038, "Member 'UAJBAIEnvironmentBlock::WaySpots' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, HouseInfos) == 0x000048, "Member 'UAJBAIEnvironmentBlock::HouseInfos' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, Doors) == 0x000058, "Member 'UAJBAIEnvironmentBlock::Doors' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, DoorsNotInHouse) == 0x000068, "Member 'UAJBAIEnvironmentBlock::DoorsNotInHouse' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, WINDOWS) == 0x000078, "Member 'UAJBAIEnvironmentBlock::WINDOWS' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, Gates) == 0x000088, "Member 'UAJBAIEnvironmentBlock::Gates' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, Traps) == 0x000098, "Member 'UAJBAIEnvironmentBlock::Traps' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, BurningActors) == 0x0000A8, "Member 'UAJBAIEnvironmentBlock::BurningActors' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, Min) == 0x0000B8, "Member 'UAJBAIEnvironmentBlock::Min' has a wrong offset!");
static_assert(offsetof(UAJBAIEnvironmentBlock, Max) == 0x0000C4, "Member 'UAJBAIEnvironmentBlock::Max' has a wrong offset!");

// Class AJB.AJBInGameAIDirectorComponent
// 0x0000 (0x00F0 - 0x00F0)
class UAJBInGameAIDirectorComponent : public UActorComponent
{
public:
	void DebugRequestAddNPCFromDebugActor(class AActor* Actor);
	void DebugRequestAddNPCFromDebugArgs(const struct FVector& Location, const struct FRotator& Rotation, const struct FGameplayTagContainer& AddInfoTags, int32 AILevel);
	void DebugRequestByGameplayTags(class APlayerController* PlayerController, const struct FGameplayTagContainer& Tags, const struct FVector& VectorIn);
	void DebugRequestHideDebugInfo(class APlayerController* PlayerController);
	void DebugRequestNPCAllLog(class APlayerController* PlayerController, int32 NPCId);
	void DebugRequestRestartBehavior(int32 DebugMenuIndex);
	void DebugRequestShowDebugInfo(class APlayerController* PlayerController);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameAIDirectorComponent">();
	}
	static class UAJBInGameAIDirectorComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameAIDirectorComponent>();
	}
};
static_assert(alignof(UAJBInGameAIDirectorComponent) == 0x000008, "Wrong alignment on UAJBInGameAIDirectorComponent");
static_assert(sizeof(UAJBInGameAIDirectorComponent) == 0x0000F0, "Wrong size on UAJBInGameAIDirectorComponent");

// Class AJB.AJBAIFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAJBAIFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool AabbContainsAabb(const struct FBox& Box, const struct FBox& Other);
	static bool AabbContainsPoint(const struct FBox& Box, const struct FVector& Point);
	static bool DeprojectScreenPositionToWorldForAI(float ScreenX, float ScreenY, const struct FVector& Location, const struct FRotator& Rotation, float FOV, const struct FVector2D& ViewSize, struct FVector* WorldLocation, struct FVector* WorldDirection);
	static class FName GetBlackboardKeyName(const struct FBlackboardKeySelector& Key);
	static struct FVector GetClosestPointOnAabb(const struct FBox& Box, const struct FVector& Point);
	static struct FVector InvalidLocation();
	static bool IsFinite(float Value);
	static bool IsNaN(float Value);
	static bool IsSameParentBTNode(class UBTDecorator_BlueprintBase* Decorator, class UBTService_BlueprintBase* Service);
	static bool LineAabbIntersection(const struct FBox& Box, const struct FVector& Start, const struct FVector& End);
	static void MakeBoundingBoxFromLocations(const TArray<struct FVector>& Locations, struct FBox* OutBox);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAIFunctionLibrary">();
	}
	static class UAJBAIFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAIFunctionLibrary>();
	}
};
static_assert(alignof(UAJBAIFunctionLibrary) == 0x000008, "Wrong alignment on UAJBAIFunctionLibrary");
static_assert(sizeof(UAJBAIFunctionLibrary) == 0x000028, "Wrong size on UAJBAIFunctionLibrary");

// Class AJB.AJBInGameAIEnvironmentComponent
// 0x0038 (0x0128 - 0x00F0)
class UAJBInGameAIEnvironmentComponent : public UActorComponent
{
public:
	TArray<class UAJBAIEnvironmentBlock*>         EnvironmentBlocks;                                 // 0x00F0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         BlockUnitSize;                                     // 0x0100(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockCountX;                                       // 0x0104(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BlockCountY;                                       // 0x0108(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NavMeshVolumeMin;                                  // 0x010C(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                NavMeshVolumeMax;                                  // 0x0118(0x000C)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestAddBurningActor(class AActor* Actor);
	void RequestAddSpawnedItem(class AActor* Item);
	void RequestAddTrap(class AActor* Trap);
	void RequestAIGion(const struct FGameplayTag& GionEffectType, class AActor* GionOwner, const struct FVector& Location);
	void SetupEnvironmentBlocks(class AActor* NavMeshVolume, float BlockUnitSizeIn);

	int32 GetBlockIndex(const struct FVector& Location) const;
	int32 GetBlockIndexAround(int32 BlockIndexCenter, int32 OffsetCountX, int32 OffsetCountY) const;
	bool IsInNavMeshVolume(const struct FVector& Location) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameAIEnvironmentComponent">();
	}
	static class UAJBInGameAIEnvironmentComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameAIEnvironmentComponent>();
	}
};
static_assert(alignof(UAJBInGameAIEnvironmentComponent) == 0x000008, "Wrong alignment on UAJBInGameAIEnvironmentComponent");
static_assert(sizeof(UAJBInGameAIEnvironmentComponent) == 0x000128, "Wrong size on UAJBInGameAIEnvironmentComponent");
static_assert(offsetof(UAJBInGameAIEnvironmentComponent, EnvironmentBlocks) == 0x0000F0, "Member 'UAJBInGameAIEnvironmentComponent::EnvironmentBlocks' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIEnvironmentComponent, BlockUnitSize) == 0x000100, "Member 'UAJBInGameAIEnvironmentComponent::BlockUnitSize' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIEnvironmentComponent, BlockCountX) == 0x000104, "Member 'UAJBInGameAIEnvironmentComponent::BlockCountX' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIEnvironmentComponent, BlockCountY) == 0x000108, "Member 'UAJBInGameAIEnvironmentComponent::BlockCountY' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIEnvironmentComponent, NavMeshVolumeMin) == 0x00010C, "Member 'UAJBInGameAIEnvironmentComponent::NavMeshVolumeMin' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIEnvironmentComponent, NavMeshVolumeMax) == 0x000118, "Member 'UAJBInGameAIEnvironmentComponent::NavMeshVolumeMax' has a wrong offset!");

// Class AJB.AJBAMErrorObserverActor
// 0x0008 (0x0330 - 0x0328)
class AAJBAMErrorObserverActor : public AActor
{
public:
	EAJBErrorID                                   ShowErrorID;                                       // 0x0328(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsWaitCheck;                                      // 0x0329(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32A[0x6];                                      // 0x032A(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void FinishAmwSystemErrorCheck();
	void FinishGameServerCheck(EAJBTestModeGameServerError Result);
	void FinishLocalNetworkCheck();
	void FinishUploapErrorLog(bool bSuccess);
	void FinishUploapHeadClerk(bool bSuccess);
	void OnHideErrorWindow();
	void OnRequestGameServerCheck();
	void OnRequestLocalNetworkCheck();
	void OnRequestUploadErrorLog();
	void OnRequestUploadHeadClerk();
	void OnShowErrorWindow(EAJBErrorID ErrorID);
	void OnStartAmwSystemErrorCheck();
	void SetEnableErrorCheck(bool bIsEnable);
	void SetEnableUpload(bool bIsEnable);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAMErrorObserverActor">();
	}
	static class AAJBAMErrorObserverActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBAMErrorObserverActor>();
	}
};
static_assert(alignof(AAJBAMErrorObserverActor) == 0x000008, "Wrong alignment on AAJBAMErrorObserverActor");
static_assert(sizeof(AAJBAMErrorObserverActor) == 0x000330, "Wrong size on AAJBAMErrorObserverActor");
static_assert(offsetof(AAJBAMErrorObserverActor, ShowErrorID) == 0x000328, "Member 'AAJBAMErrorObserverActor::ShowErrorID' has a wrong offset!");
static_assert(offsetof(AAJBAMErrorObserverActor, bIsWaitCheck) == 0x000329, "Member 'AAJBAMErrorObserverActor::bIsWaitCheck' has a wrong offset!");

// Class AJB.AJBInGameAIInputProxyComponent
// 0x0028 (0x0118 - 0x00F0)
class UAJBInGameAIInputProxyComponent : public UActorComponent
{
public:
	float                                         ForwardValue;                                      // 0x00F0(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         RightValue;                                        // 0x00F4(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         TurnValue;                                         // 0x00F8(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LookUpValue;                                       // 0x00FC(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_100[0x1];                                      // 0x0100(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bIfUpdateInput;                                    // 0x0101(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_102[0x16];                                     // 0x0102(0x0016)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DebugResetOwnerController(class AController* OwnerControllerIn);
	void PressCrouch();
	void PressEmote();
	void PressInteract();
	void PressJump();
	void PressL1();
	void PressL2();
	void PressMap();
	void PressR1();
	void PressR2();
	void ReleaseCrouch();
	void ReleaseEmote();
	void ReleaseInteract();
	void ReleaseJump();
	void ReleaseL1();
	void ReleaseL2();
	void ReleaseMap();
	void ReleaseR1();
	void ReleaseR2();
	void SetMovement(float Forward, float Right, float Turn, float LookUp);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameAIInputProxyComponent">();
	}
	static class UAJBInGameAIInputProxyComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameAIInputProxyComponent>();
	}
};
static_assert(alignof(UAJBInGameAIInputProxyComponent) == 0x000008, "Wrong alignment on UAJBInGameAIInputProxyComponent");
static_assert(sizeof(UAJBInGameAIInputProxyComponent) == 0x000118, "Wrong size on UAJBInGameAIInputProxyComponent");
static_assert(offsetof(UAJBInGameAIInputProxyComponent, ForwardValue) == 0x0000F0, "Member 'UAJBInGameAIInputProxyComponent::ForwardValue' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIInputProxyComponent, RightValue) == 0x0000F4, "Member 'UAJBInGameAIInputProxyComponent::RightValue' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIInputProxyComponent, TurnValue) == 0x0000F8, "Member 'UAJBInGameAIInputProxyComponent::TurnValue' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIInputProxyComponent, LookUpValue) == 0x0000FC, "Member 'UAJBInGameAIInputProxyComponent::LookUpValue' has a wrong offset!");
static_assert(offsetof(UAJBInGameAIInputProxyComponent, bIfUpdateInput) == 0x000101, "Member 'UAJBInGameAIInputProxyComponent::bIfUpdateInput' has a wrong offset!");

// Class AJB.AJBAMLED
// 0x0000 (0x0028 - 0x0028)
class UAJBAMLED final : public UBlueprintFunctionLibrary
{
public:
	static void ALLOffLED(const class UObject* WorldContextObject);
	static void SetAJBBoardLEDPattern(const class UObject* WorldContextObject, EAJBBoardLEDPattern Pattern);
	static void SetBoardBackLEDColor(const struct FLinearColor& Color);
	static void SetBoardCenterLEDColor(const struct FLinearColor& Color);
	static void SetBoardFrontLEDColor(int32 bright);
	static void SetQRCameraLED(bool bOn);
	static void SetSideLEDColor(const struct FLinearColor& Color);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAMLED">();
	}
	static class UAJBAMLED* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAMLED>();
	}
};
static_assert(alignof(UAJBAMLED) == 0x000008, "Wrong alignment on UAJBAMLED");
static_assert(sizeof(UAJBAMLED) == 0x000028, "Wrong size on UAJBAMLED");

// Class AJB.AJBInGameAIRecognitionComponent
// 0x0000 (0x00F0 - 0x00F0)
class UAJBInGameAIRecognitionComponent : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameAIRecognitionComponent">();
	}
	static class UAJBInGameAIRecognitionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameAIRecognitionComponent>();
	}
};
static_assert(alignof(UAJBInGameAIRecognitionComponent) == 0x000008, "Wrong alignment on UAJBInGameAIRecognitionComponent");
static_assert(sizeof(UAJBInGameAIRecognitionComponent) == 0x0000F0, "Wrong size on UAJBInGameAIRecognitionComponent");

// Class AJB.AJBAMSystemObject
// 0x0120 (0x0148 - 0x0028)
class UAJBAMSystemObject final : public UObject
{
public:
	uint8                                         Pad_28[0x20];                                      // 0x0028(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CoinCredit;                                        // 0x0048(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmoneyCredit;                                      // 0x004C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServiceCredit;                                     // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnCoinCredit;                                      // 0x0058(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnServiceCredit;                                   // 0x0068(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUpdateCreditUI;                                  // 0x0078(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bServicePlay;                                      // 0x0088(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_89[0x3];                                       // 0x0089(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         OnePlayCoinCount;                                  // 0x008C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCoinLock;                                       // 0x0090(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEmoneyTouchWait;                                // 0x0091(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsUSIOCoinLock;                                   // 0x0092(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_93[0x1];                                       // 0x0093(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         PP;                                                // 0x0094(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_98[0x8];                                       // 0x0098(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bConsumePP;                                        // 0x00A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A1[0x3];                                       // 0x00A1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         FreePPTimeSecond;                                  // 0x00A4(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUpdatePPUI;                                      // 0x00A8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnAddPP;                                           // 0x00B8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	int32                                         ConsumedPP;                                        // 0x00C8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxConsumPP;                                       // 0x00CC(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsingPP;                                           // 0x00D0(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAMStatus                                     AMStatus;                                          // 0x00D4(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSkipNOTICE;                                       // 0x00D5(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTestSwitch;                                       // 0x00D6(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_D7[0x1];                                       // 0x00D7(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<EAJBErrorID>                           ActiveAJBErrors;                                   // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<EAJBNetAPIResult>                      NoticeNetErrors;                                   // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	bool                                          bIsAMSystemErrorMode;                              // 0x00F8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasDongleError;                                   // 0x00F9(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasNetworkError;                                  // 0x00FA(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bHasLocalNetworkError;                             // 0x00FB(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FC[0x4];                                       // 0x00FC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              NextCheckGameServerTime;                           // 0x0100(0x0008)(NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_108[0x8];                                      // 0x0108(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<class FString>                         TestModeTransitionHindrances;                      // 0x0110(0x0010)(ZeroConstructor, Protected, NativeAccessSpecifierProtected)
	UMulticastDelegateProperty_                   OnTryToTransitTestModeDelegate;                    // 0x0120(0x0010)(ZeroConstructor, InstancedReference, Protected, NativeAccessSpecifierProtected)
	struct FTimerHandle                           TimerHandle_TestModeTransitionFailSafe;            // 0x0130(0x0008)(NoDestructor, Protected, NativeAccessSpecifierProtected)
	uint8                                         Pad_138[0x10];                                     // 0x0138(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void ActiveAJBError(class UAJBGameInstance* GameInstance, EAJBErrorID ErrorID, const class FString& DetailLog);
	static void AddAJBError(class UAJBGameInstance* GameInstance, EAJBErrorID ErrorID, const class FString& DetailLog);
	static void AddNoticeNetError(class UObject* WorldContextObject, EAJBNetAPIResult Result);
	static void ChangeAMStatus(const class UObject* WorldContextObject, EAMStatus ChangeStatus);
	static void CheckAJBDongleError(const class UObject* WorldContextObject);
	static EAJBErrorID CheckAJBSerialNumber(bool Repossession, class FString* outSerialNumber);
	static EAJBErrorID CheckAJBSerialNumberAndNetID(const class UObject* WorldContextObject, bool Repossession, class FString* outSerialNumber);
	static EAJBErrorID GetActiveDongleError(class UObject* WorldContextObject);
	static void InactiveAJBError(class UAJBGameInstance* GameInstance, EAJBErrorID ErrorID);
	static void InactiveAMErrorFromList(class UAJBGameInstance* GameInstance, const TArray<EAJBErrorID>& ErrorList);
	static bool IsAMSystemErrorMode(class UObject* WorldContextObject);
	static EAJBNetAPIResult OutNoticeNetError(class UObject* WorldContextObject);
	static void SetAJBCoinLock(const class UObject* WorldContextObject, bool Lock);
	static void SetAJBEmoneyTouchWaitStatus(const class UObject* WorldContextObject, bool bIsWait);
	static void UpdateAMErrorFromList(class UAJBGameInstance* GameInstance, EAJBErrorID ErrorID, const TArray<EAJBErrorID>& ErrorList);

	EAJBErrorID FindFistAMSystemErrorMode();
	EAJBErrorID FindFistLocalNetworkError();
	EAJBErrorID FindFistNetworkError();
	bool IsActiveAJBError(EAJBErrorID ErrorID);
	void ReserveTestModeTransition(const class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAMSystemObject">();
	}
	static class UAJBAMSystemObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAMSystemObject>();
	}
};
static_assert(alignof(UAJBAMSystemObject) == 0x000008, "Wrong alignment on UAJBAMSystemObject");
static_assert(sizeof(UAJBAMSystemObject) == 0x000148, "Wrong size on UAJBAMSystemObject");
static_assert(offsetof(UAJBAMSystemObject, CoinCredit) == 0x000048, "Member 'UAJBAMSystemObject::CoinCredit' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, EmoneyCredit) == 0x00004C, "Member 'UAJBAMSystemObject::EmoneyCredit' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, ServiceCredit) == 0x000050, "Member 'UAJBAMSystemObject::ServiceCredit' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, OnCoinCredit) == 0x000058, "Member 'UAJBAMSystemObject::OnCoinCredit' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, OnServiceCredit) == 0x000068, "Member 'UAJBAMSystemObject::OnServiceCredit' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, OnUpdateCreditUI) == 0x000078, "Member 'UAJBAMSystemObject::OnUpdateCreditUI' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bServicePlay) == 0x000088, "Member 'UAJBAMSystemObject::bServicePlay' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, OnePlayCoinCount) == 0x00008C, "Member 'UAJBAMSystemObject::OnePlayCoinCount' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bIsCoinLock) == 0x000090, "Member 'UAJBAMSystemObject::bIsCoinLock' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bIsEmoneyTouchWait) == 0x000091, "Member 'UAJBAMSystemObject::bIsEmoneyTouchWait' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bIsUSIOCoinLock) == 0x000092, "Member 'UAJBAMSystemObject::bIsUSIOCoinLock' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, PP) == 0x000094, "Member 'UAJBAMSystemObject::PP' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bConsumePP) == 0x0000A0, "Member 'UAJBAMSystemObject::bConsumePP' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, FreePPTimeSecond) == 0x0000A4, "Member 'UAJBAMSystemObject::FreePPTimeSecond' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, OnUpdatePPUI) == 0x0000A8, "Member 'UAJBAMSystemObject::OnUpdatePPUI' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, OnAddPP) == 0x0000B8, "Member 'UAJBAMSystemObject::OnAddPP' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, ConsumedPP) == 0x0000C8, "Member 'UAJBAMSystemObject::ConsumedPP' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, MaxConsumPP) == 0x0000CC, "Member 'UAJBAMSystemObject::MaxConsumPP' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, UsingPP) == 0x0000D0, "Member 'UAJBAMSystemObject::UsingPP' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, AMStatus) == 0x0000D4, "Member 'UAJBAMSystemObject::AMStatus' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bSkipNOTICE) == 0x0000D5, "Member 'UAJBAMSystemObject::bSkipNOTICE' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bTestSwitch) == 0x0000D6, "Member 'UAJBAMSystemObject::bTestSwitch' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, ActiveAJBErrors) == 0x0000D8, "Member 'UAJBAMSystemObject::ActiveAJBErrors' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, NoticeNetErrors) == 0x0000E8, "Member 'UAJBAMSystemObject::NoticeNetErrors' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bIsAMSystemErrorMode) == 0x0000F8, "Member 'UAJBAMSystemObject::bIsAMSystemErrorMode' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bHasDongleError) == 0x0000F9, "Member 'UAJBAMSystemObject::bHasDongleError' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bHasNetworkError) == 0x0000FA, "Member 'UAJBAMSystemObject::bHasNetworkError' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, bHasLocalNetworkError) == 0x0000FB, "Member 'UAJBAMSystemObject::bHasLocalNetworkError' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, NextCheckGameServerTime) == 0x000100, "Member 'UAJBAMSystemObject::NextCheckGameServerTime' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, TestModeTransitionHindrances) == 0x000110, "Member 'UAJBAMSystemObject::TestModeTransitionHindrances' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, OnTryToTransitTestModeDelegate) == 0x000120, "Member 'UAJBAMSystemObject::OnTryToTransitTestModeDelegate' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemObject, TimerHandle_TestModeTransitionFailSafe) == 0x000130, "Member 'UAJBAMSystemObject::TimerHandle_TestModeTransitionFailSafe' has a wrong offset!");

// Class AJB.AJBInGameCharacterBase
// 0x0050 (0x0790 - 0x0740)
class AAJBInGameCharacterBase : public ACharacter
{
public:
	class AController*                            SharedController;                                  // 0x0740(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAJBInGameCharacterBase*                PairCharacter;                                     // 0x0748(0x0008)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PairID;                                            // 0x0750(0x0010)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchingPlayerIndex;                               // 0x0760(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_764[0x4];                                      // 0x0764(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnPawnClientRestarted;                             // 0x0768(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	float                                         DefaultHearingAbilityRate;                         // 0x0778(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HearingAbilityRate;                                // 0x077C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMin;                                      // 0x0780(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ViewPitchMax;                                      // 0x0784(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InputPitchScale;                                   // 0x0788(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bFinishedSkinChange;                               // 0x078C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseOwnerAsRootCharacterBase;                      // 0x078D(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_78E[0x2];                                      // 0x078E(0x0002)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CleanUp(bool bShouldDestroy);
	void LookupRate(float Value);
	void MoveForward(float Value);
	void MoveRight(float Value);
	void OnPlayerControllerDestroyed();
	void OnPressedCrouch();
	void OnPressedEmote();
	void OnPressedInteract();
	void OnPressedJump();
	void OnPressedL1();
	void OnPressedL2();
	void OnPressedL3();
	void OnPressedR1();
	void OnPressedR2();
	void OnPressedShoot();
	void OnReleasedCrouch();
	void OnReleasedEmote();
	void OnReleasedInteract();
	void OnReleasedJump();
	void OnReleasedL1();
	void OnReleasedL2();
	void OnReleasedL3();
	void OnReleasedR1();
	void OnReleasedR2();
	void OnRep_MatchingPlayerIndex();
	void OnRep_PairCharacter();
	void PostInitializeComponentsBP();
	void PreInitializeComponentsBP();
	void SetMatchingPlayerIndex(int32 NewMatchingPlayerIndex);
	void SetPairCharacter(class AAJBInGameCharacterBase* InPairCharacter);
	void SetPairID(const class FString& InPairID);
	void SetRole(ENetRole NewRole);
	void SetSharedController(class AController* InController);
	class UAnimMontage* TryGetEmoteAnimMontageByIndex(const int32 Index_0);
	int32 TryGetEmoteVoiceByIndex(const int32 Index_0);
	bool TryGetMatchingPlayerInfo(struct FMatchingPlayerInfo* Out);
	bool TryGetPlayerCustomData(int32* OutCharacterId, struct FCustomData* Out);
	void TurnRate(float Value);

	ENetRole GetRole() const;
	bool HasLocalSharedController() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameCharacterBase">();
	}
	static class AAJBInGameCharacterBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameCharacterBase>();
	}
};
static_assert(alignof(AAJBInGameCharacterBase) == 0x000010, "Wrong alignment on AAJBInGameCharacterBase");
static_assert(sizeof(AAJBInGameCharacterBase) == 0x000790, "Wrong size on AAJBInGameCharacterBase");
static_assert(offsetof(AAJBInGameCharacterBase, SharedController) == 0x000740, "Member 'AAJBInGameCharacterBase::SharedController' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, PairCharacter) == 0x000748, "Member 'AAJBInGameCharacterBase::PairCharacter' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, PairID) == 0x000750, "Member 'AAJBInGameCharacterBase::PairID' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, MatchingPlayerIndex) == 0x000760, "Member 'AAJBInGameCharacterBase::MatchingPlayerIndex' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, OnPawnClientRestarted) == 0x000768, "Member 'AAJBInGameCharacterBase::OnPawnClientRestarted' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, DefaultHearingAbilityRate) == 0x000778, "Member 'AAJBInGameCharacterBase::DefaultHearingAbilityRate' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, HearingAbilityRate) == 0x00077C, "Member 'AAJBInGameCharacterBase::HearingAbilityRate' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, ViewPitchMin) == 0x000780, "Member 'AAJBInGameCharacterBase::ViewPitchMin' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, ViewPitchMax) == 0x000784, "Member 'AAJBInGameCharacterBase::ViewPitchMax' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, InputPitchScale) == 0x000788, "Member 'AAJBInGameCharacterBase::InputPitchScale' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, bFinishedSkinChange) == 0x00078C, "Member 'AAJBInGameCharacterBase::bFinishedSkinChange' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacterBase, bUseOwnerAsRootCharacterBase) == 0x00078D, "Member 'AAJBInGameCharacterBase::bUseOwnerAsRootCharacterBase' has a wrong offset!");

// Class AJB.AJBAMSystemObserver
// 0x0020 (0x0048 - 0x0028)
class UAJBAMSystemObserver final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAJBGameInstance*                       RefGameInstance;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_38[0x10];                                      // 0x0038(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAMSystemObserver">();
	}
	static class UAJBAMSystemObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAMSystemObserver>();
	}
};
static_assert(alignof(UAJBAMSystemObserver) == 0x000008, "Wrong alignment on UAJBAMSystemObserver");
static_assert(sizeof(UAJBAMSystemObserver) == 0x000048, "Wrong size on UAJBAMSystemObserver");
static_assert(offsetof(UAJBAMSystemObserver, RefGameInstance) == 0x000030, "Member 'UAJBAMSystemObserver::RefGameInstance' has a wrong offset!");

// Class AJB.AJBInGameCameraman
// 0x0000 (0x0790 - 0x0790)
class AAJBInGameCameraman : public AAJBInGameCharacterBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameCameraman">();
	}
	static class AAJBInGameCameraman* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameCameraman>();
	}
};
static_assert(alignof(AAJBInGameCameraman) == 0x000010, "Wrong alignment on AAJBInGameCameraman");
static_assert(sizeof(AAJBInGameCameraman) == 0x000790, "Wrong size on AAJBInGameCameraman");

// Class AJB.AJBAMSystemSettings
// 0x01F0 (0x0218 - 0x0028)
class UAJBAMSystemSettings final : public UObject
{
public:
	bool                                          bIsInitialActivation;                              // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAMVersion                             AMVersion;                                         // 0x0030(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FLastGameStatus                        LastGameStatus;                                    // 0x0048(0x0038)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FFreePlayCount                         FreePlayCount;                                     // 0x0080(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FCoinOptions                           CoinOptions;                                       // 0x0084(0x0004)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FSoundOptions                          SoundOptions;                                      // 0x0088(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FAMIOOptions                           AMIOOptions;                                       // 0x0094(0x001A)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_AE[0x2];                                       // 0x00AE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCloseTimeSettings                     CloseTimeSettings;                                 // 0x00B0(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FBookKeepingData                       BookKeepingData;                                   // 0x00D0(0x0030)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FErrorLogs                             ErrorLogs;                                         // 0x0100(0x0010)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAJBInformation                        Information;                                       // 0x0110(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FShopEventSettings                     ShopEventSettings;                                 // 0x0128(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	struct FShopInfoSaveData                      ShopInfoSaveData;                                  // 0x0130(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FAMUpdateSettings                      UpdateSettings;                                    // 0x0148(0x0001)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsCheckDongle;                                    // 0x0149(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCheckUSIO;                                      // 0x014A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCheckTouchPanel;                                // 0x014B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCheckBNCRW;                                     // 0x014C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCheckNetwork;                                   // 0x014D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCheckAppVersion;                                // 0x014E(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDedicatedSeverStartSelect;                     // 0x014F(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugInputMode;                                   // 0x0150(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_151[0x7];                                      // 0x0151(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 OverwriteAccessCode;                               // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteChipID;                                   // 0x0168(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteGameID;                                   // 0x0178(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteSerialNo;                                 // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteTenpoID;                                  // 0x0198(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteRegionCode;                               // 0x01A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteCuntryCode;                               // 0x01B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteAmwBnamMainId;                            // 0x01C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 OverwriteGameServerURL;                            // 0x01D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E8[0x30];                                     // 0x01E8(0x0030)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static const struct FAMIOOptions GetAMIOOptions(class UObject* WorldContextObject);
	static EPurchaseLimitPP GetDefaultPurchaseLimitPP();
	static const struct FShopEventSettings GetShopEventSettings(class UObject* WorldContextObject);
	static void GetTimeByClose(class UObject* WorldContextObject, int32* OutMinute);
	static void GetTodayCloseTime(class UObject* WorldContextObject, int32* OutHoure, int32* OutMinute);
	static bool IsEnableDebugInput(class UObject* WorldContextObject);
	static bool IsEnableOverwriteDebugLogin(class UObject* WorldContextObject);
	static void ResetBackupMemory(class UObject* WorldContextObject);
	static void ResetBookKeeping(class UObject* WorldContextObject);
	static void SetLEDPowerAlive(class UObject* WorldContextObject, int32 Power);
	static void SetLEDPowerNormal(class UObject* WorldContextObject, int32 Power);
	static void SetShopCompetitionMatchingKey(class UObject* WorldContextObject, int32 MatchingKey);
	static void SetShopCompetitionMode(class UObject* WorldContextObject, bool bIsShopCompetition);
	static void SetShopCompetitionPlayerType(class UObject* WorldContextObject, EShopEventPlayerType Type);
	static void SetUpdateServerMode(class UObject* WorldContextObject, bool bIsServerMode);
	static void SetUSIOAnalogSetting(class UObject* WorldContextObject, int32 ChannelNo, int32 Min, int32 Max, int32 Center);
	static void UpdateCloseTime(class UObject* WorldContextObject, const int32 WeekIndex, const int32 Houre, const int32 Minute);
	static void UpdateUSIOSetting(class UObject* WorldContextObject);

	void IncrementPlayCount();
	bool IsNeedUploadErrorLog();
	void LoadSettingsIni();
	void ResetPlayTime();
	void SetupSave_AMVersion(TArray<uint8>* Data);
	void SetupSave_BookKeeping(TArray<uint8>* Data);
	void SetupSave_ErrorLogs(TArray<uint8>* Data);
	void SetupSave_FreePlayCount(TArray<uint8>* Data);
	void SetupSave_Information(TArray<uint8>* Data);
	void SetupSave_LastGameStatus(TArray<uint8>* Data);
	void SetupSave_ShopInfoSaveData(TArray<uint8>* Data);
	void SetupSave_SystemOptions(TArray<uint8>* Data);
	void SetupSave_UpdateSettingsSaveData(TArray<uint8>* Data);
	void UpdatePlayTime(bool bOnPlay);

	bool IsEnableCloseTime() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAMSystemSettings">();
	}
	static class UAJBAMSystemSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAMSystemSettings>();
	}
};
static_assert(alignof(UAJBAMSystemSettings) == 0x000008, "Wrong alignment on UAJBAMSystemSettings");
static_assert(sizeof(UAJBAMSystemSettings) == 0x000218, "Wrong size on UAJBAMSystemSettings");
static_assert(offsetof(UAJBAMSystemSettings, bIsInitialActivation) == 0x000028, "Member 'UAJBAMSystemSettings::bIsInitialActivation' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, AMVersion) == 0x000030, "Member 'UAJBAMSystemSettings::AMVersion' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, LastGameStatus) == 0x000048, "Member 'UAJBAMSystemSettings::LastGameStatus' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, FreePlayCount) == 0x000080, "Member 'UAJBAMSystemSettings::FreePlayCount' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, CoinOptions) == 0x000084, "Member 'UAJBAMSystemSettings::CoinOptions' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, SoundOptions) == 0x000088, "Member 'UAJBAMSystemSettings::SoundOptions' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, AMIOOptions) == 0x000094, "Member 'UAJBAMSystemSettings::AMIOOptions' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, CloseTimeSettings) == 0x0000B0, "Member 'UAJBAMSystemSettings::CloseTimeSettings' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, BookKeepingData) == 0x0000D0, "Member 'UAJBAMSystemSettings::BookKeepingData' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, ErrorLogs) == 0x000100, "Member 'UAJBAMSystemSettings::ErrorLogs' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, Information) == 0x000110, "Member 'UAJBAMSystemSettings::Information' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, ShopEventSettings) == 0x000128, "Member 'UAJBAMSystemSettings::ShopEventSettings' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, ShopInfoSaveData) == 0x000130, "Member 'UAJBAMSystemSettings::ShopInfoSaveData' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, UpdateSettings) == 0x000148, "Member 'UAJBAMSystemSettings::UpdateSettings' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bIsCheckDongle) == 0x000149, "Member 'UAJBAMSystemSettings::bIsCheckDongle' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bIsCheckUSIO) == 0x00014A, "Member 'UAJBAMSystemSettings::bIsCheckUSIO' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bIsCheckTouchPanel) == 0x00014B, "Member 'UAJBAMSystemSettings::bIsCheckTouchPanel' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bIsCheckBNCRW) == 0x00014C, "Member 'UAJBAMSystemSettings::bIsCheckBNCRW' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bIsCheckNetwork) == 0x00014D, "Member 'UAJBAMSystemSettings::bIsCheckNetwork' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bIsCheckAppVersion) == 0x00014E, "Member 'UAJBAMSystemSettings::bIsCheckAppVersion' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bUseDedicatedSeverStartSelect) == 0x00014F, "Member 'UAJBAMSystemSettings::bUseDedicatedSeverStartSelect' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, bDebugInputMode) == 0x000150, "Member 'UAJBAMSystemSettings::bDebugInputMode' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteAccessCode) == 0x000158, "Member 'UAJBAMSystemSettings::OverwriteAccessCode' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteChipID) == 0x000168, "Member 'UAJBAMSystemSettings::OverwriteChipID' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteGameID) == 0x000178, "Member 'UAJBAMSystemSettings::OverwriteGameID' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteSerialNo) == 0x000188, "Member 'UAJBAMSystemSettings::OverwriteSerialNo' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteTenpoID) == 0x000198, "Member 'UAJBAMSystemSettings::OverwriteTenpoID' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteRegionCode) == 0x0001A8, "Member 'UAJBAMSystemSettings::OverwriteRegionCode' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteCuntryCode) == 0x0001B8, "Member 'UAJBAMSystemSettings::OverwriteCuntryCode' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteAmwBnamMainId) == 0x0001C8, "Member 'UAJBAMSystemSettings::OverwriteAmwBnamMainId' has a wrong offset!");
static_assert(offsetof(UAJBAMSystemSettings, OverwriteGameServerURL) == 0x0001D8, "Member 'UAJBAMSystemSettings::OverwriteGameServerURL' has a wrong offset!");

// Class AJB.AJBInGameCharaMoveComponent
// 0x0010 (0x0780 - 0x0770)
class UAJBInGameCharaMoveComponent final : public UCharacterMovementComponent
{
public:
	float                                         JumpOffSpeed;                                      // 0x0768(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldResolveMovementTimestampError;              // 0x076C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_76D[0x3];                                      // 0x076D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         ForceResolvingTimestampError;                      // 0x0770(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	float                                         ClientZeroTimeThreshold;                           // 0x0774(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_778[0x8];                                      // 0x0778(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ForceUnCrouch();
	void SetClientZeroTimeThreshold(float NewValue);
	void SetForceResolvingTimestampError(float NewValue);
	void SetShouldResolveMovementTimestampError(bool NewValue);

	float GetClientZeroTimeThreshold() const;
	float GetForceResolvingTimestampError() const;
	bool ShouldResolveMovementTimestampError() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameCharaMoveComponent">();
	}
	static class UAJBInGameCharaMoveComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameCharaMoveComponent>();
	}
};
static_assert(alignof(UAJBInGameCharaMoveComponent) == 0x000010, "Wrong alignment on UAJBInGameCharaMoveComponent");
static_assert(sizeof(UAJBInGameCharaMoveComponent) == 0x000780, "Wrong size on UAJBInGameCharaMoveComponent");
static_assert(offsetof(UAJBInGameCharaMoveComponent, JumpOffSpeed) == 0x000768, "Member 'UAJBInGameCharaMoveComponent::JumpOffSpeed' has a wrong offset!");
static_assert(offsetof(UAJBInGameCharaMoveComponent, bShouldResolveMovementTimestampError) == 0x00076C, "Member 'UAJBInGameCharaMoveComponent::bShouldResolveMovementTimestampError' has a wrong offset!");
static_assert(offsetof(UAJBInGameCharaMoveComponent, ForceResolvingTimestampError) == 0x000770, "Member 'UAJBInGameCharaMoveComponent::ForceResolvingTimestampError' has a wrong offset!");
static_assert(offsetof(UAJBInGameCharaMoveComponent, ClientZeroTimeThreshold) == 0x000774, "Member 'UAJBInGameCharaMoveComponent::ClientZeroTimeThreshold' has a wrong offset!");

// Class AJB.AJBAnimMetaData
// 0x0008 (0x0030 - 0x0028)
class UAJBAnimMetaData final : public UAnimMetaData
{
public:
	bool                                          bLoop;                                             // 0x0028(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAnimMetaData">();
	}
	static class UAJBAnimMetaData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAnimMetaData>();
	}
};
static_assert(alignof(UAJBAnimMetaData) == 0x000008, "Wrong alignment on UAJBAnimMetaData");
static_assert(sizeof(UAJBAnimMetaData) == 0x000030, "Wrong size on UAJBAnimMetaData");
static_assert(offsetof(UAJBAnimMetaData, bLoop) == 0x000028, "Member 'UAJBAnimMetaData::bLoop' has a wrong offset!");

// Class AJB.AJBInGameEffectActor
// 0x0000 (0x0328 - 0x0328)
class AAJBInGameEffectActor : public AActor
{
public:
	bool IsBeingUsed();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameEffectActor">();
	}
	static class AAJBInGameEffectActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameEffectActor>();
	}
};
static_assert(alignof(AAJBInGameEffectActor) == 0x000008, "Wrong alignment on AAJBInGameEffectActor");
static_assert(sizeof(AAJBInGameEffectActor) == 0x000328, "Wrong size on AAJBInGameEffectActor");

// Class AJB.AJBArcadeTimeManager
// 0x0038 (0x0060 - 0x0028)
class UAJBArcadeTimeManager : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAJBClosedAlertArcadeTimeSchedule> ClosedAlertArcadeTimeSchedule;                  // 0x0030(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         MaxBuyPPLimit;                                     // 0x0040(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTickableWhenPaused;                               // 0x0044(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_45[0x3];                                       // 0x0045(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 IgnoreAddCreditLevelName;                          // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxPayCreditNum;                                   // 0x0058(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DevUpdateTodayWeekCloseTime(const int32 Houre, const int32 Minute);
	void OnAddPP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBArcadeTimeManager">();
	}
	static class UAJBArcadeTimeManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBArcadeTimeManager>();
	}
};
static_assert(alignof(UAJBArcadeTimeManager) == 0x000008, "Wrong alignment on UAJBArcadeTimeManager");
static_assert(sizeof(UAJBArcadeTimeManager) == 0x000060, "Wrong size on UAJBArcadeTimeManager");
static_assert(offsetof(UAJBArcadeTimeManager, ClosedAlertArcadeTimeSchedule) == 0x000030, "Member 'UAJBArcadeTimeManager::ClosedAlertArcadeTimeSchedule' has a wrong offset!");
static_assert(offsetof(UAJBArcadeTimeManager, MaxBuyPPLimit) == 0x000040, "Member 'UAJBArcadeTimeManager::MaxBuyPPLimit' has a wrong offset!");
static_assert(offsetof(UAJBArcadeTimeManager, bTickableWhenPaused) == 0x000044, "Member 'UAJBArcadeTimeManager::bTickableWhenPaused' has a wrong offset!");
static_assert(offsetof(UAJBArcadeTimeManager, IgnoreAddCreditLevelName) == 0x000048, "Member 'UAJBArcadeTimeManager::IgnoreAddCreditLevelName' has a wrong offset!");
static_assert(offsetof(UAJBArcadeTimeManager, MaxPayCreditNum) == 0x000058, "Member 'UAJBArcadeTimeManager::MaxPayCreditNum' has a wrong offset!");

// Class AJB.AJBInGameEffectPoolManager
// 0x0010 (0x0338 - 0x0328)
class AAJBInGameEffectPoolManager : public AActor
{
public:
	bool                                          bRegister;                                         // 0x0328(0x0001)(ZeroConstructor, Transient, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimerHandle                           RegisterHandle;                                    // 0x0330(0x0008)(Transient, NoDestructor, Protected, NativeAccessSpecifierProtected)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameEffectPoolManager">();
	}
	static class AAJBInGameEffectPoolManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameEffectPoolManager>();
	}
};
static_assert(alignof(AAJBInGameEffectPoolManager) == 0x000008, "Wrong alignment on AAJBInGameEffectPoolManager");
static_assert(sizeof(AAJBInGameEffectPoolManager) == 0x000338, "Wrong size on AAJBInGameEffectPoolManager");
static_assert(offsetof(AAJBInGameEffectPoolManager, bRegister) == 0x000328, "Member 'AAJBInGameEffectPoolManager::bRegister' has a wrong offset!");
static_assert(offsetof(AAJBInGameEffectPoolManager, RegisterHandle) == 0x000330, "Member 'AAJBInGameEffectPoolManager::RegisterHandle' has a wrong offset!");

// Class AJB.AJBArrayFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAJBArrayFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void SortInt32Array(const TArray<int32>& inArray, TArray<int32>* OutArray);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBArrayFunctionLibrary">();
	}
	static class UAJBArrayFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBArrayFunctionLibrary>();
	}
};
static_assert(alignof(UAJBArrayFunctionLibrary) == 0x000008, "Wrong alignment on UAJBArrayFunctionLibrary");
static_assert(sizeof(UAJBArrayFunctionLibrary) == 0x000028, "Wrong size on UAJBArrayFunctionLibrary");

// Class AJB.AJBAssetManager
// 0x0078 (0x0450 - 0x03D8)
class UAJBAssetManager : public UAssetManager
{
public:
	class UAJBPrimaryDataAsset*                   TitlePreLoadingPrimaryDataAsset;                   // 0x03D8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TMap<struct FPrimaryAssetId, class UAJBPrimaryEmote*> LoadedPrimaryEmoteMap;                     // 0x03E0(0x0050)(ZeroConstructor, NativeAccessSpecifierPublic)
	class UAJBPrimaryCharacterClass*              CharacterClassPrimaryDataAsset;                    // 0x0430(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBPrimaryRewardPlayerIconID*          RewardPlayerIconIDPrimaryDataAsset;                // 0x0438(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBPrimaryRewardStandSkinID*           RewardStandSkinIDPrimaryDataAsset;                 // 0x0440(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBPrimaryRewardCharaSkinID*           RewardCharaSkinIDPrimaryDataAsset;                 // 0x0448(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UAJBAssetManager* Get();

	void AllUnloadPrimaryEmoteAssets();
	TSubclassOf<class AAJBInGameCharacter> GetAJBInGameCharacterClassByCharaId(const class UObject* WorldContextObject, const int32 CharacterID, bool* bSuccess);
	TSubclassOf<class AAJBInGameCharacter> GetAJBInGameCharacterClassByCharaTag(const struct FGameplayTag& CharaTag, bool* bSuccess);
	struct FGameplayTag GetAJBInGameCharacterTagByCharaId(const class UObject* WorldContextObject, const int32 CharacterID, bool* bSuccess);
	struct FPrimaryAssetId GetEmotePrimaryDataAssetIdByCharaId(const class UObject* WorldContextObject, const int32 CharacterID, const int32 emoteId, bool* bSuccess);
	struct FPrimaryAssetId GetEmotePrimaryDataAssetIdByCharaTag(const class UObject* WorldContextObject, const struct FGameplayTag& CharaTag, const int32 emoteId, bool* bSuccess);
	int32 GetPlayerIconIDByRewardNo(int32 RewardNo);
	struct FPrimaryAssetId GetPreLoadingPrimaryDataAssetId(const class UObject* WorldContextObject, const int32 StageId);
	TSoftObjectPtr<class UTexture> GetRewardCharaIconTexture(const class UObject* WorldContextObject, int32 CharaIndex, int32 RewardNo);
	TSoftObjectPtr<class UTexture> GetRewardStandIconTexture(const class UObject* WorldContextObject, int32 CharaIndex, int32 RewardNo);
	bool IsValidPrimaryAssetId(const struct FPrimaryAssetId& CheckPrimaryAssetId);
	class UObject* LoadAssetSyncByPrimaryAssetId(const struct FPrimaryAssetId& PrimaryAssetId, bool bLogWarning);
	void RegisterLoadedPrimaryEmoteMap(const TArray<class UObject*>& PrimaryEmoteAssets);
	void SetupCharacterClassLoadingPrimaryDataAsset(class UObject* PrimaryAsset);
	void SetupTitlePreLoadingPrimaryDataAsset(class UObject* PrimaryAsset);
	class UAJBPrimaryEmote* TryGetLoadedPrimaryEmoteAsset(const class UObject* WorldContextObject, const int32 CharacterID, const int32 emoteId);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAssetManager">();
	}
	static class UAJBAssetManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAssetManager>();
	}
};
static_assert(alignof(UAJBAssetManager) == 0x000008, "Wrong alignment on UAJBAssetManager");
static_assert(sizeof(UAJBAssetManager) == 0x000450, "Wrong size on UAJBAssetManager");
static_assert(offsetof(UAJBAssetManager, TitlePreLoadingPrimaryDataAsset) == 0x0003D8, "Member 'UAJBAssetManager::TitlePreLoadingPrimaryDataAsset' has a wrong offset!");
static_assert(offsetof(UAJBAssetManager, LoadedPrimaryEmoteMap) == 0x0003E0, "Member 'UAJBAssetManager::LoadedPrimaryEmoteMap' has a wrong offset!");
static_assert(offsetof(UAJBAssetManager, CharacterClassPrimaryDataAsset) == 0x000430, "Member 'UAJBAssetManager::CharacterClassPrimaryDataAsset' has a wrong offset!");
static_assert(offsetof(UAJBAssetManager, RewardPlayerIconIDPrimaryDataAsset) == 0x000438, "Member 'UAJBAssetManager::RewardPlayerIconIDPrimaryDataAsset' has a wrong offset!");
static_assert(offsetof(UAJBAssetManager, RewardStandSkinIDPrimaryDataAsset) == 0x000440, "Member 'UAJBAssetManager::RewardStandSkinIDPrimaryDataAsset' has a wrong offset!");
static_assert(offsetof(UAJBAssetManager, RewardCharaSkinIDPrimaryDataAsset) == 0x000448, "Member 'UAJBAssetManager::RewardCharaSkinIDPrimaryDataAsset' has a wrong offset!");

// Class AJB.AJBInGameGameSession
// 0x0000 (0x0340 - 0x0340)
class AAJBInGameGameSession final : public AGameSession
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameGameSession">();
	}
	static class AAJBInGameGameSession* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameGameSession>();
	}
};
static_assert(alignof(AAJBInGameGameSession) == 0x000008, "Wrong alignment on AAJBInGameGameSession");
static_assert(sizeof(AAJBInGameGameSession) == 0x000340, "Wrong size on AAJBInGameGameSession");

// Class AJB.AJBAsyncTaskDownloadImage
// 0x0058 (0x0088 - 0x0030)
class UAJBAsyncTaskDownloadImage final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFail;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_50[0x38];                                      // 0x0050(0x0038)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBAsyncTaskDownloadImage* AJBDownloadImage(class UObject* WorldContextObject, const class FString& SourceURL_, const class FString& SourceMD5HashString_, const class FString& DistFilename_, float TimeoutSec_, int32 BandwidthBytePerSec_);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBAsyncTaskDownloadImage">();
	}
	static class UAJBAsyncTaskDownloadImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBAsyncTaskDownloadImage>();
	}
};
static_assert(alignof(UAJBAsyncTaskDownloadImage) == 0x000008, "Wrong alignment on UAJBAsyncTaskDownloadImage");
static_assert(sizeof(UAJBAsyncTaskDownloadImage) == 0x000088, "Wrong size on UAJBAsyncTaskDownloadImage");
static_assert(offsetof(UAJBAsyncTaskDownloadImage, OnSuccess) == 0x000030, "Member 'UAJBAsyncTaskDownloadImage::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBAsyncTaskDownloadImage, OnFail) == 0x000040, "Member 'UAJBAsyncTaskDownloadImage::OnFail' has a wrong offset!");

// Class AJB.AJBInGameEnviroment
// 0x0000 (0x0328 - 0x0328)
class AAJBInGameEnviroment : public AActor
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameEnviroment">();
	}
	static class AAJBInGameEnviroment* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameEnviroment>();
	}
};
static_assert(alignof(AAJBInGameEnviroment) == 0x000008, "Wrong alignment on AAJBInGameEnviroment");
static_assert(sizeof(AAJBInGameEnviroment) == 0x000328, "Wrong size on AAJBInGameEnviroment");

// Class AJB.AJBInGameHouse
// 0x0000 (0x0328 - 0x0328)
class AAJBInGameHouse final : public AAJBInGameEnviroment
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameHouse">();
	}
	static class AAJBInGameHouse* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameHouse>();
	}
};
static_assert(alignof(AAJBInGameHouse) == 0x000008, "Wrong alignment on AAJBInGameHouse");
static_assert(sizeof(AAJBInGameHouse) == 0x000328, "Wrong size on AAJBInGameHouse");

// Class AJB.AJBBackGroundWidget
// 0x0008 (0x0210 - 0x0208)
class UAJBBackGroundWidget : public UUserWidget
{
public:
	class UAJBWindowWidget*                       OwnerWindowWidget;                                 // 0x0208(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void OnClosingOwnerWindow();
	void OnOpeningOwnerWindow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBBackGroundWidget">();
	}
	static class UAJBBackGroundWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBBackGroundWidget>();
	}
};
static_assert(alignof(UAJBBackGroundWidget) == 0x000008, "Wrong alignment on UAJBBackGroundWidget");
static_assert(sizeof(UAJBBackGroundWidget) == 0x000210, "Wrong size on UAJBBackGroundWidget");
static_assert(offsetof(UAJBBackGroundWidget, OwnerWindowWidget) == 0x000208, "Member 'UAJBBackGroundWidget::OwnerWindowWidget' has a wrong offset!");

// Class AJB.AJBInGameIndoorVolumeComponent
// 0x0000 (0x0590 - 0x0590)
class UAJBInGameIndoorVolumeComponent : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameIndoorVolumeComponent">();
	}
	static class UAJBInGameIndoorVolumeComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameIndoorVolumeComponent>();
	}
};
static_assert(alignof(UAJBInGameIndoorVolumeComponent) == 0x000008, "Wrong alignment on UAJBInGameIndoorVolumeComponent");
static_assert(sizeof(UAJBInGameIndoorVolumeComponent) == 0x000590, "Wrong size on UAJBInGameIndoorVolumeComponent");

// Class AJB.AJBInGameGameMode
// 0x0010 (0x0420 - 0x0410)
class AAJBInGameGameMode : public AGameMode
{
public:
	uint8                                         Pad_410[0x8];                                      // 0x0410(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class AAJBOnlineBeaconHost*                   OnlineBeaconHost;                                  // 0x0418(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void FinalizeOnlineBeacon();
	bool InitializeOnlineBeacon(TSubclassOf<class AAJBOnlineBeaconClient> BeaconClientClass);
	void SetBlogLoingState(bool IsBlock);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameGameMode">();
	}
	static class AAJBInGameGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameGameMode>();
	}
};
static_assert(alignof(AAJBInGameGameMode) == 0x000008, "Wrong alignment on AAJBInGameGameMode");
static_assert(sizeof(AAJBInGameGameMode) == 0x000420, "Wrong size on AAJBInGameGameMode");
static_assert(offsetof(AAJBInGameGameMode, OnlineBeaconHost) == 0x000418, "Member 'AAJBInGameGameMode::OnlineBeaconHost' has a wrong offset!");

// Class AJB.AJBInGameMovableStand
// 0x0010 (0x07A0 - 0x0790)
class AAJBInGameMovableStand : public AAJBInGameCharacterBase
{
public:
	EStandAccompanyTransition                     Rep_AppearanceTransition;                          // 0x0790(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_791[0xF];                                      // 0x0791(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Activate();
	void Inactivate();
	void OnRep_AppearanceTransition();
	void ROS_SetAppearanceTransition(EStandAccompanyTransition NextTransition);
	void SetAppearanceTransition(EStandAccompanyTransition NextTransition);
	void SetAppearanceTransitionAll(EStandAccompanyTransition NextTransition);

	bool IsAppearance() const;
	bool IsBackwardTransition() const;
	bool IsForwardTransition() const;
	bool IsNotAppearance() const;
	bool IsTransition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameMovableStand">();
	}
	static class AAJBInGameMovableStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameMovableStand>();
	}
};
static_assert(alignof(AAJBInGameMovableStand) == 0x000010, "Wrong alignment on AAJBInGameMovableStand");
static_assert(sizeof(AAJBInGameMovableStand) == 0x0007A0, "Wrong size on AAJBInGameMovableStand");
static_assert(offsetof(AAJBInGameMovableStand, Rep_AppearanceTransition) == 0x000790, "Member 'AAJBInGameMovableStand::Rep_AppearanceTransition' has a wrong offset!");

// Class AJB.AJBBattleGameMode
// 0x0000 (0x0420 - 0x0420)
class AAJBBattleGameMode : public AAJBInGameGameMode
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBBattleGameMode">();
	}
	static class AAJBBattleGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBBattleGameMode>();
	}
};
static_assert(alignof(AAJBBattleGameMode) == 0x000008, "Wrong alignment on AAJBBattleGameMode");
static_assert(sizeof(AAJBBattleGameMode) == 0x000420, "Wrong size on AAJBBattleGameMode");

// Class AJB.AJBInGameGameState
// 0x0008 (0x0390 - 0x0388)
class AAJBInGameGameState : public AGameState
{
public:
	bool                                          bLoadedStageLevels;                                // 0x0388(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_389[0x3];                                      // 0x0389(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LoadingLevelCount;                                 // 0x038C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	struct FTimespan GetElapsedInGameTimespan();
	int32 GetLoadingLevelCount();
	bool IsLoadedStageLevels();
	void SetLoadingLevelCount(int32 Count);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameGameState">();
	}
	static class AAJBInGameGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameGameState>();
	}
};
static_assert(alignof(AAJBInGameGameState) == 0x000008, "Wrong alignment on AAJBInGameGameState");
static_assert(sizeof(AAJBInGameGameState) == 0x000390, "Wrong size on AAJBInGameGameState");
static_assert(offsetof(AAJBInGameGameState, bLoadedStageLevels) == 0x000388, "Member 'AAJBInGameGameState::bLoadedStageLevels' has a wrong offset!");
static_assert(offsetof(AAJBInGameGameState, LoadingLevelCount) == 0x00038C, "Member 'AAJBInGameGameState::LoadingLevelCount' has a wrong offset!");

// Class AJB.AJBBattleGameState
// 0x0000 (0x0390 - 0x0390)
class AAJBBattleGameState : public AAJBInGameGameState
{
public:
	void StartRecordingReplay();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBBattleGameState">();
	}
	static class AAJBBattleGameState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBBattleGameState>();
	}
};
static_assert(alignof(AAJBBattleGameState) == 0x000008, "Wrong alignment on AAJBBattleGameState");
static_assert(sizeof(AAJBBattleGameState) == 0x000390, "Wrong size on AAJBBattleGameState");

// Class AJB.AJBBTNodeFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAJBBTNodeFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool HasObjectValue(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key);
	static bool IsValidVectorValue(class UBTNode* NodeOwner, const struct FBlackboardKeySelector& Key);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBBTNodeFunctionLibrary">();
	}
	static class UAJBBTNodeFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBBTNodeFunctionLibrary>();
	}
};
static_assert(alignof(UAJBBTNodeFunctionLibrary) == 0x000008, "Wrong alignment on UAJBBTNodeFunctionLibrary");
static_assert(sizeof(UAJBBTNodeFunctionLibrary) == 0x000028, "Wrong size on UAJBBTNodeFunctionLibrary");

// Class AJB.AJBButton
// 0x0020 (0x0440 - 0x0420)
class UAJBButton final : public UButton
{
public:
	uint8                                         Pad_420[0x8];                                      // 0x0420(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UUserWidget*                            RootOwnerWidget;                                   // 0x0428(0x0008)(ExportObject, ZeroConstructor, Transient, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnCancelled;                                       // 0x0430(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	bool IsPressableButton() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBButton">();
	}
	static class UAJBButton* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBButton>();
	}
};
static_assert(alignof(UAJBButton) == 0x000008, "Wrong alignment on UAJBButton");
static_assert(sizeof(UAJBButton) == 0x000440, "Wrong size on UAJBButton");
static_assert(offsetof(UAJBButton, RootOwnerWidget) == 0x000428, "Member 'UAJBButton::RootOwnerWidget' has a wrong offset!");
static_assert(offsetof(UAJBButton, OnCancelled) == 0x000430, "Member 'UAJBButton::OnCancelled' has a wrong offset!");

// Class AJB.AJBUserWidget
// 0x0040 (0x0248 - 0x0208)
class UAJBUserWidget : public UUserWidget
{
public:
	EAJBUIViewPortPriority                        ViewPriority;                                      // 0x0208(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableForceInvisibleHUD;                          // 0x0209(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ESlateVisibility                              CachedPreVisibility;                               // 0x020A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_20B[0x1];                                      // 0x020B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGeometry                              CachedPreGeometry;                                 // 0x020C(0x0038)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_244[0x4];                                      // 0x0244(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void ResetAnimation(class UWidgetAnimation* InAnimation, const float StartAtTime, EUMGSequencePlayMode PlayMode);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBUserWidget">();
	}
	static class UAJBUserWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBUserWidget>();
	}
};
static_assert(alignof(UAJBUserWidget) == 0x000008, "Wrong alignment on UAJBUserWidget");
static_assert(sizeof(UAJBUserWidget) == 0x000248, "Wrong size on UAJBUserWidget");
static_assert(offsetof(UAJBUserWidget, ViewPriority) == 0x000208, "Member 'UAJBUserWidget::ViewPriority' has a wrong offset!");
static_assert(offsetof(UAJBUserWidget, bEnableForceInvisibleHUD) == 0x000209, "Member 'UAJBUserWidget::bEnableForceInvisibleHUD' has a wrong offset!");
static_assert(offsetof(UAJBUserWidget, CachedPreVisibility) == 0x00020A, "Member 'UAJBUserWidget::CachedPreVisibility' has a wrong offset!");
static_assert(offsetof(UAJBUserWidget, CachedPreGeometry) == 0x00020C, "Member 'UAJBUserWidget::CachedPreGeometry' has a wrong offset!");

// Class AJB.AJBButtonWidget
// 0x0058 (0x02A0 - 0x0248)
class UAJBButtonWidget : public UAJBUserWidget
{
public:
	UMulticastDelegateProperty_                   OnPressedButtonDispatcher;                         // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnReleasedButtonDispatcher;                        // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnDecidedButtonDispatcher;                         // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class FText                                   DisplayButtonText;                                 // 0x0278(0x0018)(Edit, NativeAccessSpecifierPublic)
	uint8                                         Pad_290[0x10];                                     // 0x0290(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallDecidedButtonEvent();
	void CurveAnimationFinishDelegate(TDelegate<void()> Delegate, class UWidget* AnimWidget, int32 AnimSequence);
	class UAJBButton* GetButton();
	class UAJBTextBlock* GetTextBlock();
	bool IsButtonPressed();
	bool IsPlayingCurveAnimation(class UWidget* AnimWidget, int32 AnimSequence);
	void OnButtonPressed();
	void OnButtonPressedAnimation();
	void OnButtonReleased();
	void OnButtonReleasedAnimation();
	void OnResetButtonWidget();
	void PlayCurveAnimation(class UWidget* AnimWidget, int32 AnimSequence, bool bPlayingCheck, EUMGSequencePlayMode PlayMode, int32 NumLoopToPlay);
	void RegisterCurve_Angle(class UWidget* AnimWidget, class UCurveFloat* Curve, int32 AnimSequence);
	void RegisterCurve_Scale(class UWidget* AnimWidget, class UCurveBase* Curve, int32 AnimSequence);
	void RegisterCurve_Trans(class UWidget* AnimWidget, class UCurveVector* CurveVector, int32 AnimSequence);
	void RegisterCurve_TransX(class UWidget* AnimWidget, class UCurveFloat* Curve, int32 AnimSequence);
	void RegisterCurve_TransY(class UWidget* AnimWidget, class UCurveFloat* Curve, int32 AnimSequence);
	void StopCurveAnimation(class UWidget* AnimWidget, int32 AnimSequence);
	void UpdateButtonText(const class FText& newText);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBButtonWidget">();
	}
	static class UAJBButtonWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBButtonWidget>();
	}
};
static_assert(alignof(UAJBButtonWidget) == 0x000008, "Wrong alignment on UAJBButtonWidget");
static_assert(sizeof(UAJBButtonWidget) == 0x0002A0, "Wrong size on UAJBButtonWidget");
static_assert(offsetof(UAJBButtonWidget, OnPressedButtonDispatcher) == 0x000248, "Member 'UAJBButtonWidget::OnPressedButtonDispatcher' has a wrong offset!");
static_assert(offsetof(UAJBButtonWidget, OnReleasedButtonDispatcher) == 0x000258, "Member 'UAJBButtonWidget::OnReleasedButtonDispatcher' has a wrong offset!");
static_assert(offsetof(UAJBButtonWidget, OnDecidedButtonDispatcher) == 0x000268, "Member 'UAJBButtonWidget::OnDecidedButtonDispatcher' has a wrong offset!");
static_assert(offsetof(UAJBButtonWidget, DisplayButtonText) == 0x000278, "Member 'UAJBButtonWidget::DisplayButtonText' has a wrong offset!");

// Class AJB.AJBCameraShake
// 0x0018 (0x0170 - 0x0158)
class UAJBCameraShake : public UCameraShake
{
public:
	bool                                          bIgnoreTimeDilation;                               // 0x0158(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_159[0x17];                                     // 0x0159(0x0017)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBCameraShake">();
	}
	static class UAJBCameraShake* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBCameraShake>();
	}
};
static_assert(alignof(UAJBCameraShake) == 0x000008, "Wrong alignment on UAJBCameraShake");
static_assert(sizeof(UAJBCameraShake) == 0x000170, "Wrong size on UAJBCameraShake");
static_assert(offsetof(UAJBCameraShake, bIgnoreTimeDilation) == 0x000158, "Member 'UAJBCameraShake::bIgnoreTimeDilation' has a wrong offset!");

// Class AJB.AJBCharaSelectMannequin
// 0x0000 (0x0328 - 0x0328)
class AAJBCharaSelectMannequin : public AActor
{
public:
	bool IsFinishedMannequinTextureStreaming();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBCharaSelectMannequin">();
	}
	static class AAJBCharaSelectMannequin* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBCharaSelectMannequin>();
	}
};
static_assert(alignof(AAJBCharaSelectMannequin) == 0x000008, "Wrong alignment on AAJBCharaSelectMannequin");
static_assert(sizeof(AAJBCharaSelectMannequin) == 0x000328, "Wrong size on AAJBCharaSelectMannequin");

// Class AJB.AJBCheatManager
// 0x0018 (0x0090 - 0x0078)
class UAJBCheatManager final : public UCheatManager
{
public:
	TArray<float>                                 SlomoSpeed;                                        // 0x0078(0x0010)(ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         SlomoDefaultIndex;                                 // 0x0088(0x0004)(ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_8C[0x4];                                       // 0x008C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallActorProcessEvent(class FName EventName, class FName TagName);
	void DebugGameSpeedDown();
	void DebugGameSpeedUp();
	void GetDebugCameraLocation(struct FVector* Location, bool* bSucceed);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBCheatManager">();
	}
	static class UAJBCheatManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBCheatManager>();
	}
};
static_assert(alignof(UAJBCheatManager) == 0x000008, "Wrong alignment on UAJBCheatManager");
static_assert(sizeof(UAJBCheatManager) == 0x000090, "Wrong size on UAJBCheatManager");
static_assert(offsetof(UAJBCheatManager, SlomoSpeed) == 0x000078, "Member 'UAJBCheatManager::SlomoSpeed' has a wrong offset!");
static_assert(offsetof(UAJBCheatManager, SlomoDefaultIndex) == 0x000088, "Member 'UAJBCheatManager::SlomoDefaultIndex' has a wrong offset!");

// Class AJB.AJBCheckRewardLottery
// 0x0010 (0x0040 - 0x0030)
class UAJBCheckRewardLottery final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnLoaded;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	static class UAJBCheckRewardLottery* CheckRewardLottery(class UObject* WorldContextObject);
	static void RemoveRewardLottery(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBCheckRewardLottery">();
	}
	static class UAJBCheckRewardLottery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBCheckRewardLottery>();
	}
};
static_assert(alignof(UAJBCheckRewardLottery) == 0x000008, "Wrong alignment on UAJBCheckRewardLottery");
static_assert(sizeof(UAJBCheckRewardLottery) == 0x000040, "Wrong size on UAJBCheckRewardLottery");
static_assert(offsetof(UAJBCheckRewardLottery, OnLoaded) == 0x000030, "Member 'UAJBCheckRewardLottery::OnLoaded' has a wrong offset!");

// Class AJB.AJBDataTableFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAJBDataTableFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static bool GetDataTableRow_WwiseVoiceEventInfo(class UDataTable* DataTable, class FName RowName, struct FWwiseVoiceEventInfo* OutRow);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBDataTableFunctionLibrary">();
	}
	static class UAJBDataTableFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBDataTableFunctionLibrary>();
	}
};
static_assert(alignof(UAJBDataTableFunctionLibrary) == 0x000008, "Wrong alignment on UAJBDataTableFunctionLibrary");
static_assert(sizeof(UAJBDataTableFunctionLibrary) == 0x000028, "Wrong size on UAJBDataTableFunctionLibrary");

// Class AJB.AJBDebugCameraController
// 0x0008 (0x06C8 - 0x06C0)
class AAJBDebugCameraController final : public ADebugCameraController
{
public:
	uint8                                         Pad_6C0[0x8];                                      // 0x06C0(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBDebugCameraController">();
	}
	static class AAJBDebugCameraController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBDebugCameraController>();
	}
};
static_assert(alignof(AAJBDebugCameraController) == 0x000008, "Wrong alignment on AAJBDebugCameraController");
static_assert(sizeof(AAJBDebugCameraController) == 0x0006C8, "Wrong size on AAJBDebugCameraController");

// Class AJB.AJBPlayerControllerBase
// 0x0080 (0x06F8 - 0x0678)
class AAJBPlayerControllerBase : public APlayerController
{
public:
	UMulticastDelegateProperty_                   OnChangedAJBInputModeDispatcher;                   // 0x0678(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	EAJBInputMode                                 InputMode;                                         // 0x0688(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_689[0x7];                                      // 0x0689(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameServerUniqueID;                                // 0x0690(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   AutoPlayTestManagerClass;                          // 0x06A0(0x0028)(Edit, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 AutoPlayTestManager;                               // 0x06C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class AAJBInGameEffectPoolManager*>    EffectPoolManagerList;                             // 0x06D0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_6E0[0x18];                                     // 0x06E0(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AssignKeyFromDataTable(class UDataTable* DataTable);
	void ChangeInputMode(EAJBInputMode NewMode);
	void ClientStopKillcam();
	struct FKey GetGamePlayKeyFromActionName(class FName ActionName);
	bool IsDisabledInputMode();
	bool IsInputModeInGameOnly();
	bool IsInputModeUIOnly();
	void OnSetupInputComponentBP();
	void Reliable_RunOnServerMemreport();
	void Reliable_RunOnServerStartCPUProfile();
	void Reliable_RunOnServerStartNetprofile();
	void Reliable_RunOnServerStopCPUProfile();
	void Reliable_RunOnServerStopNetprofile();
	void RunOnServerCmd(const class FString& Cmd);
	void RunOnServerMemreport();
	void RunOnServerStartCPUProfile();
	void RunOnServerStartNetprofile();
	void RunOnServerStopCPUProfile();
	void RunOnServerStopNetprofile();
	void ServerCmd(const class FString& Cmd);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPlayerControllerBase">();
	}
	static class AAJBPlayerControllerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBPlayerControllerBase>();
	}
};
static_assert(alignof(AAJBPlayerControllerBase) == 0x000008, "Wrong alignment on AAJBPlayerControllerBase");
static_assert(sizeof(AAJBPlayerControllerBase) == 0x0006F8, "Wrong size on AAJBPlayerControllerBase");
static_assert(offsetof(AAJBPlayerControllerBase, OnChangedAJBInputModeDispatcher) == 0x000678, "Member 'AAJBPlayerControllerBase::OnChangedAJBInputModeDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBPlayerControllerBase, InputMode) == 0x000688, "Member 'AAJBPlayerControllerBase::InputMode' has a wrong offset!");
static_assert(offsetof(AAJBPlayerControllerBase, GameServerUniqueID) == 0x000690, "Member 'AAJBPlayerControllerBase::GameServerUniqueID' has a wrong offset!");
static_assert(offsetof(AAJBPlayerControllerBase, AutoPlayTestManagerClass) == 0x0006A0, "Member 'AAJBPlayerControllerBase::AutoPlayTestManagerClass' has a wrong offset!");
static_assert(offsetof(AAJBPlayerControllerBase, AutoPlayTestManager) == 0x0006C8, "Member 'AAJBPlayerControllerBase::AutoPlayTestManager' has a wrong offset!");
static_assert(offsetof(AAJBPlayerControllerBase, EffectPoolManagerList) == 0x0006D0, "Member 'AAJBPlayerControllerBase::EffectPoolManagerList' has a wrong offset!");

// Class AJB.AJBInGamePlayerController
// 0x0028 (0x0720 - 0x06F8)
class AAJBInGamePlayerController : public AAJBPlayerControllerBase
{
public:
	UMulticastDelegateProperty_                   OnReadyControllCharacterDispatcher;                // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UAJBGameDataStorageManager*             InGameDataStorageManager;                          // 0x0708(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugShowPlayerTrace;                             // 0x0710(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugShowZipperExitLocations;                     // 0x0711(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_712[0x2];                                      // 0x0712(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         JoystickRightPlayHighInGame;                       // 0x0714(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoystickLeftPlayHighInGame;                        // 0x0718(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_71C[0x4];                                      // 0x071C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool CallReadyControllCharacterDispatcher(class AAJBInGameCharacterBase* TargetCharacter);
	bool DevOnly_GetL3Pressed();
	float DevOnly_GetLookupRateInputvalue();
	float DevOnly_GetMoveForwardInputvalue();
	float DevOnly_GetMoveRightInputvalue();
	bool DevOnly_GetR3Pressed();
	float DevOnly_GetTurnRateInputvalue();
	void GetCameraManagerViewPoint(struct FVector* Location);
	void OnDebugChangeQuality();
	void OnDebugLastSurvivor();
	void OnDebugSoundMute();
	void OnDebugSuicide();
	void OnPawnLeavingGameBP();
	void SetAutoManageActiveCameraTarget(bool bEnable);
	void SetCameraManagerClientSideCameraUpdate(bool bEnable);

	bool GetAutoManageActiveCameraTarget() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGamePlayerController">();
	}
	static class AAJBInGamePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGamePlayerController>();
	}
};
static_assert(alignof(AAJBInGamePlayerController) == 0x000008, "Wrong alignment on AAJBInGamePlayerController");
static_assert(sizeof(AAJBInGamePlayerController) == 0x000720, "Wrong size on AAJBInGamePlayerController");
static_assert(offsetof(AAJBInGamePlayerController, OnReadyControllCharacterDispatcher) == 0x0006F8, "Member 'AAJBInGamePlayerController::OnReadyControllCharacterDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBInGamePlayerController, InGameDataStorageManager) == 0x000708, "Member 'AAJBInGamePlayerController::InGameDataStorageManager' has a wrong offset!");
static_assert(offsetof(AAJBInGamePlayerController, bDebugShowPlayerTrace) == 0x000710, "Member 'AAJBInGamePlayerController::bDebugShowPlayerTrace' has a wrong offset!");
static_assert(offsetof(AAJBInGamePlayerController, bDebugShowZipperExitLocations) == 0x000711, "Member 'AAJBInGamePlayerController::bDebugShowZipperExitLocations' has a wrong offset!");
static_assert(offsetof(AAJBInGamePlayerController, JoystickRightPlayHighInGame) == 0x000714, "Member 'AAJBInGamePlayerController::JoystickRightPlayHighInGame' has a wrong offset!");
static_assert(offsetof(AAJBInGamePlayerController, JoystickLeftPlayHighInGame) == 0x000718, "Member 'AAJBInGamePlayerController::JoystickLeftPlayHighInGame' has a wrong offset!");

// Class AJB.AJBDemoRecSpectator
// 0x0038 (0x0758 - 0x0720)
class AAJBDemoRecSpectator final : public AAJBInGamePlayerController
{
public:
	class APlayerState*                           QueuedPlayerStateToView;                           // 0x0720(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         LastKillcamSeekTime;                               // 0x0728(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_72C[0x2C];                                     // 0x072C(0x002C)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void DemoNotifyCausedHit(class APawn* InstigatorPawn, class AAJBInGameCharacter* HitPawn, uint8 AppliedDamage, const struct FVector& Momentum, const struct FDamageEvent& DamageEvent, bool bArmorDamage, bool bOverhealth);
	void DumpSpecInfo();
	void MulticastReceiveLocalizedMessage(TSubclassOf<class ULocalMessage> Message, int32 SWITCH, class APlayerState* RelatedPlayerState_1, class APlayerState* RelatedPlayerState_2, class UObject* OptionalObject);
	void ToggleReplayWindow();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBDemoRecSpectator">();
	}
	static class AAJBDemoRecSpectator* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBDemoRecSpectator>();
	}
};
static_assert(alignof(AAJBDemoRecSpectator) == 0x000008, "Wrong alignment on AAJBDemoRecSpectator");
static_assert(sizeof(AAJBDemoRecSpectator) == 0x000758, "Wrong size on AAJBDemoRecSpectator");
static_assert(offsetof(AAJBDemoRecSpectator, QueuedPlayerStateToView) == 0x000720, "Member 'AAJBDemoRecSpectator::QueuedPlayerStateToView' has a wrong offset!");
static_assert(offsetof(AAJBDemoRecSpectator, LastKillcamSeekTime) == 0x000728, "Member 'AAJBDemoRecSpectator::LastKillcamSeekTime' has a wrong offset!");

// Class AJB.AJBError
// 0x0000 (0x0028 - 0x0028)
class UAJBError final : public UBlueprintFunctionLibrary
{
public:
	static class FText GetErrorEnglish(EAJBErrorID ErrorID);
	static class FText GetErrorNo(EAJBErrorID ErrorID);
	static class FText GetErrorText(EAJBErrorID ErrorID);
	static class FText GetNetAPIErrorText(EAJBNetAPIResult ErrorID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBError">();
	}
	static class UAJBError* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBError>();
	}
};
static_assert(alignof(UAJBError) == 0x000008, "Wrong alignment on UAJBError");
static_assert(sizeof(UAJBError) == 0x000028, "Wrong size on UAJBError");

// Class AJB.AJBErrorHandler
// 0x0008 (0x0030 - 0x0028)
class UAJBErrorHandler final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void PrintAllPropertyValue(class UObject* Obj);
	static void PrintLogActiveBlueprintCallstack();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBErrorHandler">();
	}
	static class UAJBErrorHandler* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBErrorHandler>();
	}
};
static_assert(alignof(UAJBErrorHandler) == 0x000008, "Wrong alignment on UAJBErrorHandler");
static_assert(sizeof(UAJBErrorHandler) == 0x000030, "Wrong size on UAJBErrorHandler");

// Class AJB.AJBGameDataStorageManager
// 0x0000 (0x0078 - 0x0078)
class UAJBGameDataStorageManager final : public UGameDataStorageManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBGameDataStorageManager">();
	}
	static class UAJBGameDataStorageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBGameDataStorageManager>();
	}
};
static_assert(alignof(UAJBGameDataStorageManager) == 0x000008, "Wrong alignment on UAJBGameDataStorageManager");
static_assert(sizeof(UAJBGameDataStorageManager) == 0x000078, "Wrong size on UAJBGameDataStorageManager");

// Class AJB.AJBGameInstance
// 0x0448 (0x04E8 - 0x00A0)
class UAJBGameInstance : public UGameInstance
{
public:
	class UAJBErrorHandler*                       ErrorHandler;                                      // 0x00A0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBParamRepos*                         ParamRepos;                                        // 0x00A8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBOperationParam*                     OperationParam;                                    // 0x00B0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBAMSystemSettings*                   AMSystemSettings;                                  // 0x00B8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBAMSystemObject*                     AMSystemObject;                                    // 0x00C0(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBInGameServerInfo*                   InGameServerInfo;                                  // 0x00C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FPlayerLoginInfo                       PlayerLoginInfo;                                   // 0x00D0(0x0150)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FRoomPlayerInfo>                RoomPlayerData;                                    // 0x0220(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FRoomPlayerInfo                        PairRoomPlayerInfo;                                // 0x0230(0x0110)(BlueprintVisible, NativeAccessSpecifierPublic)
	TMap<class FString, struct FMatchingPlayerInfo> MatchingPlayers;                                 // 0x0340(0x0050)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FMatchingPlayerInfo>            MachingNPC;                                        // 0x0390(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A0[0x20];                                     // 0x03A0(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          IsInGameForNetworkError;                           // 0x03C0(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C1[0x7];                                      // 0x03C1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class UAJBNetworkObserver*                    NetworkObserverTask;                               // 0x03C8(0x0008)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSubclassOf<class ULoadingScreenManager>      LoadingScreenManagerClass;                         // 0x03D0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPlayMode                                     PlayMode;                                          // 0x03D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D9[0x3];                                      // 0x03D9(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAJBBattleSettings                     BattleSettings;                                    // 0x03DC(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E4[0x4];                                      // 0x03E4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAJBArcadeTimeManager>      ArcadeTimeManagerClass;                            // 0x03E8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBArcadeTimeManager*                  ArcadeTimeManager;                                 // 0x03F0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UDataTable*                             CharacterInfoTable;                                // 0x03F8(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FAJBServerAliveInfo                    ServerAliveInfo;                                   // 0x0400(0x0014)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	int32                                         MovieUploadRemainingNum;                           // 0x0414(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MaxMovieUploadNum;                                 // 0x0418(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsValidShopId;                                     // 0x041C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41D[0x3];                                      // 0x041D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStopReplayRecording;                             // 0x0420(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_430[0x8];                                      // 0x0430(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAJBAMSystemObserver*                   AMSystemObserverTask;                              // 0x0438(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAJBHighlightManager*                   highlightManager;                                  // 0x0440(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	TMap<int32, struct FCustomData>               OfflineDefaultCustomData;                          // 0x0448(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TMap<int32, int32>                            ExtraPPTable;                                      // 0x0498(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	void AddCoinCredit(int32 AddCredit, bool IsSaveLastStatus);
	void AddEmoneyCredit(int32 AddCredit, bool IsSaveLastStatus);
	bool AddPP(int32 PayCreditNum, int32 AddPPNum);
	void AddServiceCredit(int32 AddCredit, bool IsSaveLastStatus);
	void BP_PlayHighlight();
	void BP_StartRecordingReplay();
	void BP_StopRecordingReplay();
	bool CallSaved(int32 Result, const TArray<uint8>& Data);
	bool CanBuyAddPP();
	bool CanPayCredit(int32 Credit);
	bool CanUploadHighlight();
	void ClearMatchingID();
	void ClearPairRoomInfo();
	void ClearPlayerLoginInfo();
	bool CompensationCredit();
	bool CompensationPP();
	void DumpAllPlayersCustomData();
	void FinalizeHighlight();
	void FixConsumePP();
	class AAJBInGameCharacterBase* GetAJBInGameCharacterByPlayerID(int32 PlayerID);
	int32 GetBuyPPByPayCreditNum(int32 PayCredit_0);
	int32 GetCharacterSkinId(int32 CharaID);
	ECloseScheduleType GetCloseScheduleType();
	struct FCloseTimeInfo GetCloseTimeSetting(EAJBDayOfWeek WeekIndex);
	int32 GetCreaditNum();
	int32 GetCreditNumPurchaseLimitPP();
	int32 GetDefaultOutputLevelIndex();
	int32 GetDefaultSoundVolumeValue();
	struct FCloseTimeInfo GetEveryDayCloseTimeSetting();
	int32 GetExtraPPByPayCreditNum(int32 PayCredit_0);
	EExtraPPKind GetExtraPPKind();
	class AActor* GetFocusActor();
	class FString GetFocusActorID();
	class AActor* GetFocusStand();
	class FString GetFocusStandID();
	void GetGachaDetails(bool* OutNeedUpdate, struct FAJBGachaDetail* OutLuckyDrawDetail, struct FAJBGachaDetail* OutPremiumDrawDetail);
	class FString GetGameServerURL();
	class UAJBHighlightManager* GetHighlightManager();
	int32 GetHighlightUploadRemainingNum();
	int32 GetMaxHighlightUploadNum();
	int32 GetMaxOutputLevelIndex();
	int32 GetMaxSoundVolumeValue();
	int32 GetMinOutputLevelIndex();
	int32 GetMinSoundVolumeValue();
	void GetNationalMatchSchedule(bool* OutCanPlaySoloMode, bool* OutCanPlayPairMode, struct FAJBMatchSchedule* OutMatchSchedule, struct FAJBMatchScheduleDateTime* OutSoloScheduleDateTime, struct FAJBMatchScheduleDateTime* OutPairScheduleDateTime);
	int32 GetOutputLevelIndexHeadphone();
	void GetPairMatchingPlayerInfo(TArray<struct FRoomPlayerInfo>* OutPairMatching);
	bool GetPlayerCharacterEmoteData(int32 CharacterID, TArray<struct FEmoteData>* OutEmoteData);
	EPurchaseLimitPP GetPurchaseLimitPP();
	int32 GetSelectedCharacterNo();
	int32 GetStandSkinId(int32 CharaID);
	float GetTargetSeconds();
	int32 GetVolumeAttract();
	int32 GetVolumeGame();
	bool HasStartedPlayingReplay();
	bool IsConsumePP();
	bool IsExecutedReplay();
	bool IsFreePlay();
	bool IsGuestPlaying();
	bool IsHighlightReady();
	bool IsIdleNBANSave();
	bool IsLockLimitedCredit();
	bool IsLoginPlayer();
	bool IsMatchCompensationLoginUserDataID();
	bool IsNeedCompensation(bool* bCompensationCredit, bool* bCompensationPP);
	bool IsNPCPartner();
	bool IsPlayBanapassCardPlayCompensation();
	bool IsPlayingReplay();
	bool IsPlayingReplayDataAvailable();
	bool IsRecordingReplay();
	bool IsServicePlay();
	bool IsShopCompetitionMode();
	void LoadParamRepos();
	void LoadStorage_AMVersion();
	void LoadStorage_BookKeepingData();
	void LoadStorage_ErrorLogs();
	void LoadStorage_FreePlayCount();
	void LoadStorage_Information();
	void LoadStorage_LastGameStatus();
	void LoadStorage_OperationParameter();
	void LoadStorage_ShopInfo();
	void LoadStorage_SystemOptions();
	void LoadStorage_UpdateSettings();
	void OnCoinCredit();
	void OnCompleteLoadingSystemOptions();
	bool OnLoaded_AMVersion(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_BookKeeping(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_ErrorLogs(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_FreePlayCount(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_Information(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_LastGameStatus(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_OperationParameter(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_ShopInfo(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_SystemOptions(int32 Result, const TArray<uint8>& Data);
	bool OnLoaded_UpdateSettings(int32 Result, const TArray<uint8>& Data);
	void OnResetCompensationInfo();
	void OnServiceCredit();
	bool PayCredit(int32 Credit, bool SaveLastStatus);
	void ResetBattleSettings();
	void ResetCompensationInfo(bool bIsSaveLastGameStatus);
	void ResetCredit();
	void ResetLastGameStatus(bool bClearUsed);
	void ResetPP(bool bIsSaveLastGameStatus);
	void RevertConsumePP();
	void SaveStorage_AMVersion();
	void SaveStorage_BookKeepingData();
	void SaveStorage_ErrorLogs();
	void SaveStorage_FreePlayCount();
	void SaveStorage_HeadClerk(struct FAMHeadClerkInfo* HeadClerkInfo, const class FString& FilePath);
	void SaveStorage_Information();
	void SaveStorage_LastGameStatus();
	void SaveStorage_ShopInfoSaveData();
	void SaveStorage_SystemOptions();
	void SaveStorage_UpdateSettingSaveData();
	void SeekReplay(float second);
	void SetBattleSettings(const struct FAJBBattleSettings& InBattleSettings);
	void SetBuyAddPP(bool bEnable);
	void SetCharacterSkinId(int32 CharaID, int32 skinID);
	void SetCloseScheduleType(ECloseScheduleType Type);
	void SetCloseTimeSetting(EAJBDayOfWeek Week, const struct FCloseTimeInfo& Info);
	void SetEveryDayCloseTimeSetting(const struct FCloseTimeInfo& Info);
	void SetExtraPPKind(EExtraPPKind Kind);
	bool SetFocusActor(class AActor* Actor);
	void SetFocusId(int32 ID);
	bool SetFocusStand(class AActor* Actor);
	void SetFreePlay(bool bEnable);
	void SetFreePPTime(int32 second);
	void SetHighlightReady(bool bReady);
	void SetMaxConsumePP(int32 MaxPP);
	void SetOutputLevelIndexHeadphone(int32 NewIndex);
	bool SetPauseState(bool bDoPause, class APlayerController* Causer);
	void SetPurchaseLimitPP(EPurchaseLimitPP LimitPP);
	void SetSelectedCharacterNo(int32 ID);
	void SetStandSkinId(int32 CharaID, int32 skinID);
	void SetTargetSeconds(float targetSeconds, float seekTargetSeconds);
	void SetupLocalMatchingNPC(int32 NPCNum, const struct FStartLocation& StageLocationSize, int32 CanPutNum);
	void SetVolumeAttract(int32 NewVolume);
	void SetVolumeGame(int32 NewVolume);
	void StartConsumePP();
	void StopConsumePP();
	void SubCoinCredit(int32 SubCredit, bool IsSaveLastStatus);
	void SubEmoneyCredit(int32 SubCredit, bool IsSaveLastStatus);
	bool SubPP(int32 SubPPNum);
	void SubServiceCredit(int32 SubCredit, bool IsSaveLastStatus);
	bool TryCreateOfflinePlayerInfo();
	bool TryGetMatchingPlayerInfoByPlayerID(int32 PlayerID, struct FMatchingPlayerInfo* Out);
	bool TryGetMatchingPlayerInfoByPlayerIDPureFunction(int32 PlayerID, struct FMatchingPlayerInfo* Out);
	bool TryGetMatchingPlayerInfoByUserID(const class FString& UserID, struct FMatchingPlayerInfo* Out);
	void TryGetMyPairMatchingPlayerInfo(bool* bIsValid, bool* bIsRoomHost, struct FMatchingPlayerInfo* Out);
	bool TryUpdateCustomDataAndCharacterIDByPlayerID(uint8 PlayerID, const struct FCustomData& NewCustomData, uint8 NewCharacterID);
	bool TryUpdateCustomDataAndCharacterIDByUserID(const class FString& UserID, const struct FCustomData& NewCustomData, uint8 NewCharacterID);

	class UAJBParamRepos* GetParamRepos() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBGameInstance">();
	}
	static class UAJBGameInstance* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBGameInstance>();
	}
};
static_assert(alignof(UAJBGameInstance) == 0x000008, "Wrong alignment on UAJBGameInstance");
static_assert(sizeof(UAJBGameInstance) == 0x0004E8, "Wrong size on UAJBGameInstance");
static_assert(offsetof(UAJBGameInstance, ErrorHandler) == 0x0000A0, "Member 'UAJBGameInstance::ErrorHandler' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, ParamRepos) == 0x0000A8, "Member 'UAJBGameInstance::ParamRepos' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, OperationParam) == 0x0000B0, "Member 'UAJBGameInstance::OperationParam' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, AMSystemSettings) == 0x0000B8, "Member 'UAJBGameInstance::AMSystemSettings' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, AMSystemObject) == 0x0000C0, "Member 'UAJBGameInstance::AMSystemObject' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, InGameServerInfo) == 0x0000C8, "Member 'UAJBGameInstance::InGameServerInfo' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, PlayerLoginInfo) == 0x0000D0, "Member 'UAJBGameInstance::PlayerLoginInfo' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, RoomPlayerData) == 0x000220, "Member 'UAJBGameInstance::RoomPlayerData' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, PairRoomPlayerInfo) == 0x000230, "Member 'UAJBGameInstance::PairRoomPlayerInfo' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, MatchingPlayers) == 0x000340, "Member 'UAJBGameInstance::MatchingPlayers' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, MachingNPC) == 0x000390, "Member 'UAJBGameInstance::MachingNPC' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, IsInGameForNetworkError) == 0x0003C0, "Member 'UAJBGameInstance::IsInGameForNetworkError' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, NetworkObserverTask) == 0x0003C8, "Member 'UAJBGameInstance::NetworkObserverTask' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, LoadingScreenManagerClass) == 0x0003D0, "Member 'UAJBGameInstance::LoadingScreenManagerClass' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, PlayMode) == 0x0003D8, "Member 'UAJBGameInstance::PlayMode' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, BattleSettings) == 0x0003DC, "Member 'UAJBGameInstance::BattleSettings' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, ArcadeTimeManagerClass) == 0x0003E8, "Member 'UAJBGameInstance::ArcadeTimeManagerClass' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, ArcadeTimeManager) == 0x0003F0, "Member 'UAJBGameInstance::ArcadeTimeManager' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, CharacterInfoTable) == 0x0003F8, "Member 'UAJBGameInstance::CharacterInfoTable' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, ServerAliveInfo) == 0x000400, "Member 'UAJBGameInstance::ServerAliveInfo' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, MovieUploadRemainingNum) == 0x000414, "Member 'UAJBGameInstance::MovieUploadRemainingNum' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, MaxMovieUploadNum) == 0x000418, "Member 'UAJBGameInstance::MaxMovieUploadNum' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, IsValidShopId) == 0x00041C, "Member 'UAJBGameInstance::IsValidShopId' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, OnStopReplayRecording) == 0x000420, "Member 'UAJBGameInstance::OnStopReplayRecording' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, AMSystemObserverTask) == 0x000438, "Member 'UAJBGameInstance::AMSystemObserverTask' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, highlightManager) == 0x000440, "Member 'UAJBGameInstance::highlightManager' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, OfflineDefaultCustomData) == 0x000448, "Member 'UAJBGameInstance::OfflineDefaultCustomData' has a wrong offset!");
static_assert(offsetof(UAJBGameInstance, ExtraPPTable) == 0x000498, "Member 'UAJBGameInstance::ExtraPPTable' has a wrong offset!");

// Class AJB.AJBGameModeBase
// 0x0000 (0x03C8 - 0x03C8)
class AAJBGameModeBase : public AGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBGameModeBase">();
	}
	static class AAJBGameModeBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBGameModeBase>();
	}
};
static_assert(alignof(AAJBGameModeBase) == 0x000008, "Wrong alignment on AAJBGameModeBase");
static_assert(sizeof(AAJBGameModeBase) == 0x0003C8, "Wrong size on AAJBGameModeBase");

// Class AJB.AJBGameplayTagAssetUserData
// 0x0020 (0x0048 - 0x0028)
class UAJBGameplayTagAssetUserData final : public UAssetUserData
{
public:
	struct FGameplayTagContainer                  GameplayTag;                                       // 0x0028(0x0020)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBGameplayTagAssetUserData">();
	}
	static class UAJBGameplayTagAssetUserData* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBGameplayTagAssetUserData>();
	}
};
static_assert(alignof(UAJBGameplayTagAssetUserData) == 0x000008, "Wrong alignment on UAJBGameplayTagAssetUserData");
static_assert(sizeof(UAJBGameplayTagAssetUserData) == 0x000048, "Wrong size on UAJBGameplayTagAssetUserData");
static_assert(offsetof(UAJBGameplayTagAssetUserData, GameplayTag) == 0x000028, "Member 'UAJBGameplayTagAssetUserData::GameplayTag' has a wrong offset!");

// Class AJB.AJBGameViewportClient
// 0x0008 (0x02F0 - 0x02E8)
class UAJBGameViewportClient final : public UGameViewportClient
{
public:
	uint8                                         Pad_2E8[0x8];                                      // 0x02E8(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBGameViewportClient">();
	}
	static class UAJBGameViewportClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBGameViewportClient>();
	}
};
static_assert(alignof(UAJBGameViewportClient) == 0x000008, "Wrong alignment on UAJBGameViewportClient");
static_assert(sizeof(UAJBGameViewportClient) == 0x0002F0, "Wrong size on UAJBGameViewportClient");

// Class AJB.AJBGetIPAddress
// 0x0078 (0x00A8 - 0x0030)
class UAJBGetIPAddress final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x58];                                      // 0x0050(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBGetIPAddress* GetIPAddress(class UObject* WorldContextObject);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBGetIPAddress">();
	}
	static class UAJBGetIPAddress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBGetIPAddress>();
	}
};
static_assert(alignof(UAJBGetIPAddress) == 0x000008, "Wrong alignment on UAJBGetIPAddress");
static_assert(sizeof(UAJBGetIPAddress) == 0x0000A8, "Wrong size on UAJBGetIPAddress");
static_assert(offsetof(UAJBGetIPAddress, OnSuccess) == 0x000030, "Member 'UAJBGetIPAddress::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBGetIPAddress, OnFailed) == 0x000040, "Member 'UAJBGetIPAddress::OnFailed' has a wrong offset!");

// Class AJB.AJBHighlightManager
// 0x0040 (0x0068 - 0x0028)
class UAJBHighlightManager final : public UObject
{
public:
	float                                         CheckpointUploadDelayInSeconds;                    // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x18];                                      // 0x002C(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          isReadyHighlight;                                  // 0x0044(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_45[0x23];                                      // 0x0045(0x0023)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void HighlightOnly_PrintString(class UObject* WorldContextObject, const class FString& inString, bool bPrintToScreen, bool bPrintToLog, const struct FLinearColor& TextColor, float Duration);

	void BP_PlayHighlight();
	void BP_StartRecordingReplay();
	void BP_StopRecordingReplay();
	void DeleteMovieCache();
	bool ExistsMovieCache();
	void FinalizeHighlight(bool bResetHighlightPlayingMemory);
	bool FinishedCreateMovie();
	float GetCurrentHighlightTime();
	bool GetDebugFullReplayFlag();
	float GetFadeTime();
	class AActor* GetFocusActor();
	class FString GetFocusActorID();
	class AActor* GetFocusStand();
	class FString GetFocusStandID();
	float GetLastCheckPointTimeBySeekTargetTime(float SeekTargetTime);
	class FString GetMoviePath();
	float GetSeekTargetSeconds();
	float GetTargetSeconds();
	bool HasStartedPlayingReplay();
	bool IsCabinet();
	bool IsExecutedReplay();
	bool IsHighlightReady();
	bool IsPlayingReplay();
	bool IsRecordingReplay();
	bool RequestEncodeMovie(bool bLaunchDetached, bool bLaunchHidden, bool bLaunchReallyHidden, class FString* ErrorMessage);
	void SeekReplay(float second);
	void SetDebugFullReplayFlag(bool flag);
	bool SetFocusActor(class AActor* Actor);
	void SetFocusId(int32 ID);
	bool SetFocusStand(class AActor* Actor);
	void SetHighlightReady(bool bReady);
	bool SetPauseState(bool bDoPause, class APlayerController* Causer);
	void SetTargetSeconds(float targetSeconds, float seekTargetSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBHighlightManager">();
	}
	static class UAJBHighlightManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBHighlightManager>();
	}
};
static_assert(alignof(UAJBHighlightManager) == 0x000008, "Wrong alignment on UAJBHighlightManager");
static_assert(sizeof(UAJBHighlightManager) == 0x000068, "Wrong size on UAJBHighlightManager");
static_assert(offsetof(UAJBHighlightManager, CheckpointUploadDelayInSeconds) == 0x000028, "Member 'UAJBHighlightManager::CheckpointUploadDelayInSeconds' has a wrong offset!");
static_assert(offsetof(UAJBHighlightManager, isReadyHighlight) == 0x000044, "Member 'UAJBHighlightManager::isReadyHighlight' has a wrong offset!");

// Class AJB.AJBHUDBase
// 0x0100 (0x0518 - 0x0418)
class AAJBHUDBase : public AHUD
{
public:
	UMulticastDelegateProperty_                   OnOpeningWindowDispatcher;                         // 0x0418(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnOpenedWindowDispatcher;                          // 0x0428(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClosingWindowDispatcher;                         // 0x0438(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClosedWindowDispatcher;                          // 0x0448(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnStartFadeDispatcher;                             // 0x0458(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEndFadeDispatcher;                               // 0x0468(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TArray<class UAJBUserWidget*>                 ViewportWidgets;                                   // 0x0478(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAJBUserWidget*>                 InputWidgets;                                      // 0x0488(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class UAJBUserWidget*>                 OpenErrorWindowWidgets;                            // 0x0498(0x0010)(ExportObject, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)
	TArray<class AActor*>                         InputActors;                                       // 0x04A8(0x0010)(ZeroConstructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_4B8[0x58];                                     // 0x04B8(0x0058)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bForceInvisibleAllWidgets;                         // 0x0510(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_511[0x7];                                      // 0x0511(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void BindButtonsEventDynamic(class UAJBUserWidget* TargetWidget);
	void CallEndFadeEvent(EAJBFadeType Type);
	void CallStartFadeEvent(EAJBFadeType Type);
	void FindAJBWidgetOfClass(TSubclassOf<class UAJBUserWidget> AJBWidgetClass, class UAJBUserWidget** OutWidget);
	void FindAJBWidgetsOfClass(TSubclassOf<class UAJBUserWidget> AJBWidgetClass, TArray<class UAJBUserWidget*>* OutWidgets);
	bool GetInputWidgets(TArray<class UAJBUserWidget*>* OutWidgets);
	bool GetViewportWidgets(TArray<class UAJBUserWidget*>* OutWidgets);
	bool IsPressedInputButtonWidget();
	bool IsPressedInputPad();
	void OnFinishedAssignKeyFromDataTable();
	void OnInputCharaSkinDecrement();
	void OnInputCharaSkinIncrement();
	void OnInputStandSkinDecrement();
	void OnInputStandSkinIncrement();
	void OnPressedButtonWidget();
	void OnReceivedClosedWindow(class UAJBWindowWidget* TargetWidget);
	void OnReceivedClosingWindow(class UAJBWindowWidget* TargetWidget);
	void OnReceivedOpenedWindow(class UAJBWindowWidget* TargetWidget);
	void OnReceivedOpeningWindow(class UAJBWindowWidget* TargetWidget);
	void OnReleasedButtonWidget();
	void OnStartFadeIn(float FadeTime);
	void OnStartFadeOut(float FadeTime);
	void RegisterInputActor(class AActor* Actor);
	void SetCreditWidgetInstance(class UAJBUserWidget* CreditWidget);
	void SetupForceInvisibleAllWidgetsFlag(bool bVisible);
	void SetVisibilityTimeCountDown(bool bVisible);
	void UnbindButtonsEventDynamic(class UAJBUserWidget* TargetWidget);
	void UnregisterInputActor(class AActor* Actor);
	void UpdateTimeCountDown(float Time, float MaxTime);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBHUDBase">();
	}
	static class AAJBHUDBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBHUDBase>();
	}
};
static_assert(alignof(AAJBHUDBase) == 0x000008, "Wrong alignment on AAJBHUDBase");
static_assert(sizeof(AAJBHUDBase) == 0x000518, "Wrong size on AAJBHUDBase");
static_assert(offsetof(AAJBHUDBase, OnOpeningWindowDispatcher) == 0x000418, "Member 'AAJBHUDBase::OnOpeningWindowDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, OnOpenedWindowDispatcher) == 0x000428, "Member 'AAJBHUDBase::OnOpenedWindowDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, OnClosingWindowDispatcher) == 0x000438, "Member 'AAJBHUDBase::OnClosingWindowDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, OnClosedWindowDispatcher) == 0x000448, "Member 'AAJBHUDBase::OnClosedWindowDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, OnStartFadeDispatcher) == 0x000458, "Member 'AAJBHUDBase::OnStartFadeDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, OnEndFadeDispatcher) == 0x000468, "Member 'AAJBHUDBase::OnEndFadeDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, ViewportWidgets) == 0x000478, "Member 'AAJBHUDBase::ViewportWidgets' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, InputWidgets) == 0x000488, "Member 'AAJBHUDBase::InputWidgets' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, OpenErrorWindowWidgets) == 0x000498, "Member 'AAJBHUDBase::OpenErrorWindowWidgets' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, InputActors) == 0x0004A8, "Member 'AAJBHUDBase::InputActors' has a wrong offset!");
static_assert(offsetof(AAJBHUDBase, bForceInvisibleAllWidgets) == 0x000510, "Member 'AAJBHUDBase::bForceInvisibleAllWidgets' has a wrong offset!");

// Class AJB.AJBIcmpPing
// 0x0020 (0x0050 - 0x0030)
class UAJBIcmpPing final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)

public:
	static class UAJBIcmpPing* Request_Ping(class UObject* WorldContextObject, const class FString& TargetAddress, float Timeout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBIcmpPing">();
	}
	static class UAJBIcmpPing* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBIcmpPing>();
	}
};
static_assert(alignof(UAJBIcmpPing) == 0x000008, "Wrong alignment on UAJBIcmpPing");
static_assert(sizeof(UAJBIcmpPing) == 0x000050, "Wrong size on UAJBIcmpPing");
static_assert(offsetof(UAJBIcmpPing, OnSuccess) == 0x000030, "Member 'UAJBIcmpPing::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBIcmpPing, OnFailed) == 0x000040, "Member 'UAJBIcmpPing::OnFailed' has a wrong offset!");

// Class AJB.AJBImage
// 0x0000 (0x01D8 - 0x01D8)
class UAJBImage final : public UImage
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBImage">();
	}
	static class UAJBImage* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBImage>();
	}
};
static_assert(alignof(UAJBImage) == 0x000008, "Wrong alignment on UAJBImage");
static_assert(sizeof(UAJBImage) == 0x0001D8, "Wrong size on UAJBImage");

// Class AJB.AJBInGameCharacter
// 0x0020 (0x07B0 - 0x0790)
class AAJBInGameCharacter : public AAJBInGameCharacterBase
{
public:
	class AAJBInGameStand*                        Stand;                                             // 0x0790(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AAJBInGameMovableStand*                 MovableStand;                                      // 0x0798(0x0008)(BlueprintVisible, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMatchingTarget;                                   // 0x07A0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_7A1[0xF];                                      // 0x07A1(0x000F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool IsNPC();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameCharacter">();
	}
	static class AAJBInGameCharacter* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameCharacter>();
	}
};
static_assert(alignof(AAJBInGameCharacter) == 0x000010, "Wrong alignment on AAJBInGameCharacter");
static_assert(sizeof(AAJBInGameCharacter) == 0x0007B0, "Wrong size on AAJBInGameCharacter");
static_assert(offsetof(AAJBInGameCharacter, Stand) == 0x000790, "Member 'AAJBInGameCharacter::Stand' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacter, MovableStand) == 0x000798, "Member 'AAJBInGameCharacter::MovableStand' has a wrong offset!");
static_assert(offsetof(AAJBInGameCharacter, bMatchingTarget) == 0x0007A0, "Member 'AAJBInGameCharacter::bMatchingTarget' has a wrong offset!");

// Class AJB.AJBInGameGate
// 0x0000 (0x0328 - 0x0328)
class AAJBInGameGate : public AAJBInGameEnviroment
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameGate">();
	}
	static class AAJBInGameGate* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameGate>();
	}
};
static_assert(alignof(AAJBInGameGate) == 0x000008, "Wrong alignment on AAJBInGameGate");
static_assert(sizeof(AAJBInGameGate) == 0x000328, "Wrong size on AAJBInGameGate");

// Class AJB.AJBInGameHUD
// 0x0078 (0x0590 - 0x0518)
class AAJBInGameHUD : public AAJBHUDBase
{
public:
	UMulticastDelegateProperty_                   OnInGameActivateDispatcher;                        // 0x0518(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnInGameDeactivatedDispatcher;                     // 0x0528(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bInGameActivate;                                   // 0x0538(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInGameInitialized;                                // 0x0539(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_53A[0x6];                                      // 0x053A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<TSubclassOf<class UAJBInGameSkillWidget>, class UAJBInGameSkillWidget*> InstancedSkillWidgets; // 0x0540(0x0050)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, ContainsInstancedReference, NativeAccessSpecifierPublic)

public:
	void CallInGameActivateDispatcher();
	void CallInGameDeactivatedDispatcher();
	bool IsActivateInGameUI();
	bool IsInitializedInGameUI();
	void OnChangedViewTargetCharacter(class AAJBInGameCharacterBase* ViewCharacter);
	void OnToggleFullMapVisibility();
	class UAJBInGameSkillWidget* TryCreateSkillWidget(const TSubclassOf<class UAJBInGameSkillWidget>& SkillWidgetClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameHUD">();
	}
	static class AAJBInGameHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameHUD>();
	}
};
static_assert(alignof(AAJBInGameHUD) == 0x000008, "Wrong alignment on AAJBInGameHUD");
static_assert(sizeof(AAJBInGameHUD) == 0x000590, "Wrong size on AAJBInGameHUD");
static_assert(offsetof(AAJBInGameHUD, OnInGameActivateDispatcher) == 0x000518, "Member 'AAJBInGameHUD::OnInGameActivateDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBInGameHUD, OnInGameDeactivatedDispatcher) == 0x000528, "Member 'AAJBInGameHUD::OnInGameDeactivatedDispatcher' has a wrong offset!");
static_assert(offsetof(AAJBInGameHUD, bInGameActivate) == 0x000538, "Member 'AAJBInGameHUD::bInGameActivate' has a wrong offset!");
static_assert(offsetof(AAJBInGameHUD, bInGameInitialized) == 0x000539, "Member 'AAJBInGameHUD::bInGameInitialized' has a wrong offset!");
static_assert(offsetof(AAJBInGameHUD, InstancedSkillWidgets) == 0x000540, "Member 'AAJBInGameHUD::InstancedSkillWidgets' has a wrong offset!");

// Class AJB.AJBInGameMovementComponent
// 0x0088 (0x0178 - 0x00F0)
class UAJBInGameMovementComponent final : public UActorComponent
{
public:
	struct FVector                                ActorLocation;                                     // 0x00F0(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                ActorVelocity;                                     // 0x00FC(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               ActorRotation;                                     // 0x0108(0x000C)(BlueprintVisible, BlueprintReadOnly, Net, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_114[0x4];                                      // 0x0114(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class USceneComponent*                        InterpSceneComponent;                              // 0x0118(0x0008)(ExportObject, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MoveSpeed;                                         // 0x0120(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         GravitySpeed;                                      // 0x0124(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InterpSpeed;                                       // 0x0128(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UpdateThresholdSquared;                            // 0x012C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_130[0x48];                                     // 0x0130(0x0048)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void AddInput(const struct FVector& Vector, bool IsForce);
	void AddInputPitch(float Value);
	void AddInputYaw(float Value);
	void AddInputZ(const struct FVector& Vector, bool IsForce);
	void ResetInterpSceneComponent();
	void ROC_UpdateServerLocation(const struct FVector& Location);
	void ROS_CheckServerLocation(const struct FVector& Location);
	void ROS_SetLocation(const struct FVector& Location);
	void ROS_SetLocationReliable(const struct FVector& Location);
	void ROS_SetMoveSpeed(float Speed);
	void ROS_SetRotation(const struct FRotator& Rotation);
	void ROS_SetVelocity(const struct FVector& Velocity);
	void SetInterpSceneComponent(class USceneComponent* SceneComponent);
	void SetLocation(const struct FVector& Location);
	void SetLocationReliable(const struct FVector& Location);
	void SetMoveSpeed(float Speed);
	void SetRotation(const struct FRotator& Rotation);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameMovementComponent">();
	}
	static class UAJBInGameMovementComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameMovementComponent>();
	}
};
static_assert(alignof(UAJBInGameMovementComponent) == 0x000008, "Wrong alignment on UAJBInGameMovementComponent");
static_assert(sizeof(UAJBInGameMovementComponent) == 0x000178, "Wrong size on UAJBInGameMovementComponent");
static_assert(offsetof(UAJBInGameMovementComponent, ActorLocation) == 0x0000F0, "Member 'UAJBInGameMovementComponent::ActorLocation' has a wrong offset!");
static_assert(offsetof(UAJBInGameMovementComponent, ActorVelocity) == 0x0000FC, "Member 'UAJBInGameMovementComponent::ActorVelocity' has a wrong offset!");
static_assert(offsetof(UAJBInGameMovementComponent, ActorRotation) == 0x000108, "Member 'UAJBInGameMovementComponent::ActorRotation' has a wrong offset!");
static_assert(offsetof(UAJBInGameMovementComponent, InterpSceneComponent) == 0x000118, "Member 'UAJBInGameMovementComponent::InterpSceneComponent' has a wrong offset!");
static_assert(offsetof(UAJBInGameMovementComponent, MoveSpeed) == 0x000120, "Member 'UAJBInGameMovementComponent::MoveSpeed' has a wrong offset!");
static_assert(offsetof(UAJBInGameMovementComponent, GravitySpeed) == 0x000124, "Member 'UAJBInGameMovementComponent::GravitySpeed' has a wrong offset!");
static_assert(offsetof(UAJBInGameMovementComponent, InterpSpeed) == 0x000128, "Member 'UAJBInGameMovementComponent::InterpSpeed' has a wrong offset!");
static_assert(offsetof(UAJBInGameMovementComponent, UpdateThresholdSquared) == 0x00012C, "Member 'UAJBInGameMovementComponent::UpdateThresholdSquared' has a wrong offset!");

// Class AJB.AJBInGamePlacementBase
// 0x0000 (0x0328 - 0x0328)
class AAJBInGamePlacementBase : public AActor
{
public:
	void PostInitializeComponentsBP();
	void PreInitializeComponentsBP();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGamePlacementBase">();
	}
	static class AAJBInGamePlacementBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGamePlacementBase>();
	}
};
static_assert(alignof(AAJBInGamePlacementBase) == 0x000008, "Wrong alignment on AAJBInGamePlacementBase");
static_assert(sizeof(AAJBInGamePlacementBase) == 0x000328, "Wrong size on AAJBInGamePlacementBase");

// Class AJB.AJBInGamePlayerState
// 0x0008 (0x03F8 - 0x03F0)
class AAJBInGamePlayerState : public APlayerState
{
public:
	bool                                          bIsDemoRecording;                                  // 0x03F0(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3F1[0x7];                                      // 0x03F1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGamePlayerState">();
	}
	static class AAJBInGamePlayerState* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGamePlayerState>();
	}
};
static_assert(alignof(AAJBInGamePlayerState) == 0x000008, "Wrong alignment on AAJBInGamePlayerState");
static_assert(sizeof(AAJBInGamePlayerState) == 0x0003F8, "Wrong size on AAJBInGamePlayerState");
static_assert(offsetof(AAJBInGamePlayerState, bIsDemoRecording) == 0x0003F0, "Member 'AAJBInGamePlayerState::bIsDemoRecording' has a wrong offset!");

// Class AJB.AJBInGameProp
// 0x0000 (0x0328 - 0x0328)
class AAJBInGameProp : public AAJBInGameEnviroment
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameProp">();
	}
	static class AAJBInGameProp* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameProp>();
	}
};
static_assert(alignof(AAJBInGameProp) == 0x000008, "Wrong alignment on AAJBInGameProp");
static_assert(sizeof(AAJBInGameProp) == 0x000328, "Wrong size on AAJBInGameProp");

// Class AJB.AJBInGameServerInfo
// 0x0048 (0x0070 - 0x0028)
class UAJBInGameServerInfo final : public UObject
{
public:
	class FString                                 ServerIP;                                          // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PortNo;                                            // 0x0038(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ProcessNo;                                         // 0x003C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PID;                                               // 0x0040(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_44[0x4];                                       // 0x0044(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameServerURL;                                     // 0x0048(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EInGameServerStatus                           StatusID;                                          // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableRedis;                                    // 0x0059(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsInitializedNPC;                                 // 0x005A(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsRequestStopProcess;                             // 0x005B(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAJBGameInstance*                       RefAJBGameInstance;                                // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         DG_STATUS_ExpireSeconds;                           // 0x0068(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_6C[0x4];                                       // 0x006C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void InitializeConnection(class UObject* WorldContextObject);
	static bool IsEnableRedis(class UObject* WorldContextObject);
	static bool IsInitializedNPC(class UObject* WorldContextObject);
	static void OutputLogServer(class UObject* WorldContextObject, const class FString& Log);
	static void OutputLogStatus(class UObject* WorldContextObject);
	static void RunServerConsoleCmd(class UObject* WorldContextObject, const class FString& Cmd);
	static void SendCommand_DEL_GD_COMMAND(class UObject* WorldContextObject);
	static void SendCommand_EXPIRE_DG_STATUS(class UObject* WorldContextObject);
	static void SendCommand_GET_GD_COMMAND(class UObject* WorldContextObject);
	static void SendCommand_SET_DG_STATUS(class UObject* WorldContextObject, EInGameServerStatus Status);
	static void SetDG_STATUS_ExpireSeconds(class UObject* WorldContextObject, int32 Seconds);
	static void SetEnableRedis(class UObject* WorldContextObject, bool bIsEnable);

	bool Response_DEL_GD_COMMAND(int32 Result, const class FString& Data);
	bool Response_EXPIRE_DG_STATUS(int32 Result, const class FString& Data);
	bool Response_GET_GD_COMMAND(int32 Result, const class FString& Data);
	bool Response_SET_DG_STATUS(int32 Result, const class FString& Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameServerInfo">();
	}
	static class UAJBInGameServerInfo* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameServerInfo>();
	}
};
static_assert(alignof(UAJBInGameServerInfo) == 0x000008, "Wrong alignment on UAJBInGameServerInfo");
static_assert(sizeof(UAJBInGameServerInfo) == 0x000070, "Wrong size on UAJBInGameServerInfo");
static_assert(offsetof(UAJBInGameServerInfo, ServerIP) == 0x000028, "Member 'UAJBInGameServerInfo::ServerIP' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, PortNo) == 0x000038, "Member 'UAJBInGameServerInfo::PortNo' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, ProcessNo) == 0x00003C, "Member 'UAJBInGameServerInfo::ProcessNo' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, PID) == 0x000040, "Member 'UAJBInGameServerInfo::PID' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, GameServerURL) == 0x000048, "Member 'UAJBInGameServerInfo::GameServerURL' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, StatusID) == 0x000058, "Member 'UAJBInGameServerInfo::StatusID' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, bIsEnableRedis) == 0x000059, "Member 'UAJBInGameServerInfo::bIsEnableRedis' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, bIsInitializedNPC) == 0x00005A, "Member 'UAJBInGameServerInfo::bIsInitializedNPC' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, bIsRequestStopProcess) == 0x00005B, "Member 'UAJBInGameServerInfo::bIsRequestStopProcess' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, RefAJBGameInstance) == 0x000060, "Member 'UAJBInGameServerInfo::RefAJBGameInstance' has a wrong offset!");
static_assert(offsetof(UAJBInGameServerInfo, DG_STATUS_ExpireSeconds) == 0x000068, "Member 'UAJBInGameServerInfo::DG_STATUS_ExpireSeconds' has a wrong offset!");

// Class AJB.AJBInGameSkillComponent
// 0x0020 (0x0110 - 0x00F0)
class UAJBInGameSkillComponent : public UActorComponent
{
public:
	bool                                          bForceActive;                                      // 0x00F0(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActive;                                           // 0x00F1(0x0001)(Edit, Net, ZeroConstructor, EditConst, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_F2[0x6];                                       // 0x00F2(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAJBInGameSkillWidget>      UseSkillWidgetClass;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBInGameSkillWidget*                  SkillWidget;                                       // 0x0100(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bReserveInactive;                                  // 0x0108(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_109[0x7];                                      // 0x0109(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CancelSkill();
	void CancelSkillServer();
	bool CanUseSkill(struct FGameplayTagContainer* TagContainer);
	bool CheckSkillAction();
	int32 GetComponentUniqueID();
	class AAJBInGameCharacterBase* GetOwnerCharacter();
	class AAJBInGameMovableStand* GetOwnerMovableStand();
	class AAJBInGameStand* GetOwnerStand();
	void InactiveSkill(bool bForce);
	void InitializeComponentBP();
	void MC_CancelSkill();
	void MC_CancelSkillServer();
	void MC_NotifyActive(bool bInActive);
	void OnActive();
	void OnCancel();
	void OnDisconnected();
	void OnInactive();
	void OnReady();
	void OnRep_bActive();
	void ReadySkill();
	void RegisterSkillWidget(class UAJBInGameSkillWidget* RegisterSkillWidget_0);
	void ROS_CancelSkill();
	void ROS_SetSkillActive(bool bInActive);
	void UnregisterSkillWidget();

	bool IsInPreview() const;
	bool IsSkillActive(bool bIncludeReady, bool bIncludePreview) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameSkillComponent">();
	}
	static class UAJBInGameSkillComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameSkillComponent>();
	}
};
static_assert(alignof(UAJBInGameSkillComponent) == 0x000008, "Wrong alignment on UAJBInGameSkillComponent");
static_assert(sizeof(UAJBInGameSkillComponent) == 0x000110, "Wrong size on UAJBInGameSkillComponent");
static_assert(offsetof(UAJBInGameSkillComponent, bForceActive) == 0x0000F0, "Member 'UAJBInGameSkillComponent::bForceActive' has a wrong offset!");
static_assert(offsetof(UAJBInGameSkillComponent, bActive) == 0x0000F1, "Member 'UAJBInGameSkillComponent::bActive' has a wrong offset!");
static_assert(offsetof(UAJBInGameSkillComponent, UseSkillWidgetClass) == 0x0000F8, "Member 'UAJBInGameSkillComponent::UseSkillWidgetClass' has a wrong offset!");
static_assert(offsetof(UAJBInGameSkillComponent, SkillWidget) == 0x000100, "Member 'UAJBInGameSkillComponent::SkillWidget' has a wrong offset!");
static_assert(offsetof(UAJBInGameSkillComponent, bReserveInactive) == 0x000108, "Member 'UAJBInGameSkillComponent::bReserveInactive' has a wrong offset!");

// Class AJB.AJBInGameSkillParameterComponent
// 0x0000 (0x00F0 - 0x00F0)
class UAJBInGameSkillParameterComponent final : public UActorComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameSkillParameterComponent">();
	}
	static class UAJBInGameSkillParameterComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameSkillParameterComponent>();
	}
};
static_assert(alignof(UAJBInGameSkillParameterComponent) == 0x000008, "Wrong alignment on UAJBInGameSkillParameterComponent");
static_assert(sizeof(UAJBInGameSkillParameterComponent) == 0x0000F0, "Wrong size on UAJBInGameSkillParameterComponent");

// Class AJB.AJBInGameSkillWidget
// 0x0038 (0x0280 - 0x0248)
class UAJBInGameSkillWidget : public UAJBUserWidget
{
public:
	class UAJBInGameSkillComponent*               OwnerSkillComponent;                               // 0x0248(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bActiveSkillWidget;                                // 0x0250(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_251[0x7];                                      // 0x0251(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAJBSkillGuideInfo                     GuideInfo;                                         // 0x0258(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)

public:
	void OnActiveSkillWidget();
	void OnInactiveSkillWidget();
	void OnOutsideComponentUpdate(float InDeltaTime);
	void OnOwnerSkillStateChanged(uint8 NewState, uint8 PreState);
	void OnRegisterSkillComponent();
	void OnUnregisterSkillComponent();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameSkillWidget">();
	}
	static class UAJBInGameSkillWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameSkillWidget>();
	}
};
static_assert(alignof(UAJBInGameSkillWidget) == 0x000008, "Wrong alignment on UAJBInGameSkillWidget");
static_assert(sizeof(UAJBInGameSkillWidget) == 0x000280, "Wrong size on UAJBInGameSkillWidget");
static_assert(offsetof(UAJBInGameSkillWidget, OwnerSkillComponent) == 0x000248, "Member 'UAJBInGameSkillWidget::OwnerSkillComponent' has a wrong offset!");
static_assert(offsetof(UAJBInGameSkillWidget, bActiveSkillWidget) == 0x000250, "Member 'UAJBInGameSkillWidget::bActiveSkillWidget' has a wrong offset!");
static_assert(offsetof(UAJBInGameSkillWidget, GuideInfo) == 0x000258, "Member 'UAJBInGameSkillWidget::GuideInfo' has a wrong offset!");

// Class AJB.AJBInGameSpeedTreeWindBlower
// 0x0000 (0x00F0 - 0x00F0)
class UAJBInGameSpeedTreeWindBlower : public UActorComponent
{
public:
	void UpdateSpeedTreeWind(float TimeSeconds);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameSpeedTreeWindBlower">();
	}
	static class UAJBInGameSpeedTreeWindBlower* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameSpeedTreeWindBlower>();
	}
};
static_assert(alignof(UAJBInGameSpeedTreeWindBlower) == 0x000008, "Wrong alignment on UAJBInGameSpeedTreeWindBlower");
static_assert(sizeof(UAJBInGameSpeedTreeWindBlower) == 0x0000F0, "Wrong size on UAJBInGameSpeedTreeWindBlower");

// Class AJB.AJBInGameStand
// 0x0018 (0x0340 - 0x0328)
class AAJBInGameStand : public AActor
{
public:
	EStandAccompanyTransition                     Rep_AccompanyTransition;                           // 0x0328(0x0001)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x3];                                      // 0x0329(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchingPlayerIndex;                               // 0x032C(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, RepNotify, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTransitionChangedDispatcher;                     // 0x0330(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CleanUp(bool bShouldDestroy);
	void MC_NotifyTransitionChanged(EStandAccompanyTransition PrevTransition, EStandAccompanyTransition NextTransition, bool bBySeparate);
	void OnRep_AccompanyTransition();
	void OnRep_MatchingPlayerIndex();
	void OnTransitionChanged(EStandAccompanyTransition PrevTransition, EStandAccompanyTransition NextTransition, bool bBySeparate);
	void ROS_SetAccompanyTransition(EStandAccompanyTransition PrevTransition, EStandAccompanyTransition NextTransition, bool bBySeparate);
	void SetAccompanyTransition(EStandAccompanyTransition NextTransition, bool bBySeparate);
	void SetAccompanyTransitionAll(EStandAccompanyTransition NextTransition, bool bBySeparate);
	void SetMatchingPlayerIndex(int32 NewMatchingPlayerIndex);

	class AAJBInGameMovableStand* GetOwnerCharacterMovableStand(bool* bIsValid) const;
	bool IsAccompany() const;
	bool IsBackwardTransition() const;
	bool IsForwardTransition() const;
	bool IsNotAccompany() const;
	bool IsSeparating(bool bIncludeTransition) const;
	bool IsTransition() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameStand">();
	}
	static class AAJBInGameStand* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameStand>();
	}
};
static_assert(alignof(AAJBInGameStand) == 0x000008, "Wrong alignment on AAJBInGameStand");
static_assert(sizeof(AAJBInGameStand) == 0x000340, "Wrong size on AAJBInGameStand");
static_assert(offsetof(AAJBInGameStand, Rep_AccompanyTransition) == 0x000328, "Member 'AAJBInGameStand::Rep_AccompanyTransition' has a wrong offset!");
static_assert(offsetof(AAJBInGameStand, MatchingPlayerIndex) == 0x00032C, "Member 'AAJBInGameStand::MatchingPlayerIndex' has a wrong offset!");
static_assert(offsetof(AAJBInGameStand, OnTransitionChangedDispatcher) == 0x000330, "Member 'AAJBInGameStand::OnTransitionChangedDispatcher' has a wrong offset!");

// Class AJB.AJBInGameVolumeDetectionComponent
// 0x0000 (0x0590 - 0x0590)
class UAJBInGameVolumeDetectionComponent : public UBoxComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameVolumeDetectionComponent">();
	}
	static class UAJBInGameVolumeDetectionComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBInGameVolumeDetectionComponent>();
	}
};
static_assert(alignof(UAJBInGameVolumeDetectionComponent) == 0x000008, "Wrong alignment on UAJBInGameVolumeDetectionComponent");
static_assert(sizeof(UAJBInGameVolumeDetectionComponent) == 0x000590, "Wrong size on UAJBInGameVolumeDetectionComponent");

// Class AJB.AJBInGameWindow
// 0x0000 (0x0328 - 0x0328)
class AAJBInGameWindow : public AAJBInGameEnviroment
{
public:
	bool IsSmallWindow() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInGameWindow">();
	}
	static class AAJBInGameWindow* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBInGameWindow>();
	}
};
static_assert(alignof(AAJBInGameWindow) == 0x000008, "Wrong alignment on AAJBInGameWindow");
static_assert(sizeof(AAJBInGameWindow) == 0x000328, "Wrong size on AAJBInGameWindow");

// Class AJB.AJBInputUIInterface
// 0x0000 (0x0000 - 0x0000)
class IAJBInputUIInterface final
{
public:
	bool IsModeless();
	bool OnInputLookupRate(float Value);
	bool OnInputMoveForward(float Value);
	bool OnInputMoveRight(float Value);
	bool OnInputPressedCancel();
	bool OnInputPressedDecide();
	bool OnInputPressedDown();
	bool OnInputPressedL1();
	bool OnInputPressedL2();
	bool OnInputPressedL3();
	bool OnInputPressedLeft();
	bool OnInputPressedR1();
	bool OnInputPressedR2();
	bool OnInputPressedRight();
	bool OnInputPressedTouch(const float LocationX, const float LocationY);
	bool OnInputPressedUp();
	bool OnInputReleasedCancel();
	bool OnInputReleasedDecide();
	bool OnInputReleasedDown();
	bool OnInputReleasedL1();
	bool OnInputReleasedL2();
	bool OnInputReleasedL3();
	bool OnInputReleasedLeft();
	bool OnInputReleasedR1();
	bool OnInputReleasedR2();
	bool OnInputReleasedRight();
	bool OnInputReleasedTouch();
	bool OnInputReleasedUp();
	bool OnInputTurnRate(float Value);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBInputUIInterface">();
	}
	static class IAJBInputUIInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IAJBInputUIInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IAJBInputUIInterface) == 0x000001, "Wrong alignment on IAJBInputUIInterface");
static_assert(sizeof(IAJBInputUIInterface) == 0x000001, "Wrong size on IAJBInputUIInterface");

// Class AJB.AJBIPSetAddress
// 0x0078 (0x00A8 - 0x0030)
class UAJBIPSetAddress final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_50[0x58];                                      // 0x0050(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBIPSetAddress* NetshIPSetAddress(class UObject* WorldContextObject, const class FString& Address, const class FString& Gateway, float Timeout);
	static class UAJBIPSetAddress* NetshIPSetDHCP(class UObject* WorldContextObject, float Timeout);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBIPSetAddress">();
	}
	static class UAJBIPSetAddress* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBIPSetAddress>();
	}
};
static_assert(alignof(UAJBIPSetAddress) == 0x000008, "Wrong alignment on UAJBIPSetAddress");
static_assert(sizeof(UAJBIPSetAddress) == 0x0000A8, "Wrong size on UAJBIPSetAddress");
static_assert(offsetof(UAJBIPSetAddress, OnSuccess) == 0x000030, "Member 'UAJBIPSetAddress::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBIPSetAddress, OnFailed) == 0x000040, "Member 'UAJBIPSetAddress::OnFailed' has a wrong offset!");

// Class AJB.AJBKillcamPlayback
// 0x0038 (0x0060 - 0x0028)
class UAJBKillcamPlayback final : public UObject
{
public:
	class UWorld*                                 KillcamWorld;                                      // 0x0028(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UPackage*                               KillcamWorldPackage;                               // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_38[0x28];                                      // 0x0038(0x0028)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBKillcamPlayback">();
	}
	static class UAJBKillcamPlayback* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBKillcamPlayback>();
	}
};
static_assert(alignof(UAJBKillcamPlayback) == 0x000008, "Wrong alignment on UAJBKillcamPlayback");
static_assert(sizeof(UAJBKillcamPlayback) == 0x000060, "Wrong size on UAJBKillcamPlayback");
static_assert(offsetof(UAJBKillcamPlayback, KillcamWorld) == 0x000028, "Member 'UAJBKillcamPlayback::KillcamWorld' has a wrong offset!");
static_assert(offsetof(UAJBKillcamPlayback, KillcamWorldPackage) == 0x000030, "Member 'UAJBKillcamPlayback::KillcamWorldPackage' has a wrong offset!");

// Class AJB.AJBLevelSequenceActor
// 0x0008 (0x03D8 - 0x03D0)
class AAJBLevelSequenceActor final : public ALevelSequenceActor
{
public:
	bool                                          bStopSequenceWhenDestroy;                          // 0x03D0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3D1[0x7];                                      // 0x03D1(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool PlaySequence();
	bool StopSequence();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBLevelSequenceActor">();
	}
	static class AAJBLevelSequenceActor* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBLevelSequenceActor>();
	}
};
static_assert(alignof(AAJBLevelSequenceActor) == 0x000008, "Wrong alignment on AAJBLevelSequenceActor");
static_assert(sizeof(AAJBLevelSequenceActor) == 0x0003D8, "Wrong size on AAJBLevelSequenceActor");
static_assert(offsetof(AAJBLevelSequenceActor, bStopSequenceWhenDestroy) == 0x0003D0, "Member 'AAJBLevelSequenceActor::bStopSequenceWhenDestroy' has a wrong offset!");

// Class AJB.AJBLocalPlayer
// 0x0008 (0x01D0 - 0x01C8)
class UAJBLocalPlayer final : public ULocalPlayer
{
public:
	class UAJBKillcamPlayback*                    KillcamPlayback;                                   // 0x01C8(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)

public:
	bool IsKillcamReplayActive();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBLocalPlayer">();
	}
	static class UAJBLocalPlayer* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBLocalPlayer>();
	}
};
static_assert(alignof(UAJBLocalPlayer) == 0x000008, "Wrong alignment on UAJBLocalPlayer");
static_assert(sizeof(UAJBLocalPlayer) == 0x0001D0, "Wrong size on UAJBLocalPlayer");
static_assert(offsetof(UAJBLocalPlayer, KillcamPlayback) == 0x0001C8, "Member 'UAJBLocalPlayer::KillcamPlayback' has a wrong offset!");

// Class AJB.AJBMessageManager
// 0x0008 (0x0330 - 0x0328)
class AAJBMessageManager : public AActor
{
public:
	class UStringTable*                           MessageTable;                                      // 0x0328(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	class FName GetStringTablePath();
	void OnMessageRequested(int32 MessageType, float Value1, float Value2);
	void RequestMessage(int32 MessageType, float Value1, float Value2);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBMessageManager">();
	}
	static class AAJBMessageManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBMessageManager>();
	}
};
static_assert(alignof(AAJBMessageManager) == 0x000008, "Wrong alignment on AAJBMessageManager");
static_assert(sizeof(AAJBMessageManager) == 0x000330, "Wrong size on AAJBMessageManager");
static_assert(offsetof(AAJBMessageManager, MessageTable) == 0x000328, "Member 'AAJBMessageManager::MessageTable' has a wrong offset!");

// Class AJB.AJBNetAPI
// 0x0050 (0x0080 - 0x0030)
class UAJBNetAPI final : public UBlueprintAsyncActionBase
{
public:
	struct FAJBSetGameRewardParam                 CachedSetRewardParam;                              // 0x0030(0x0020)(NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0060(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0078(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_79[0x7];                                       // 0x0079(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CleanLoginPlayerInfo(class UObject* WorldContextObject);
	static class FString CreateBNCSiteURL(class UObject* WorldContextObject);
	static class UAJBNetAPI* Request_CatalogGetArea(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_CatalogGetLobby(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_CatalogGetRegion(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_GachaDetails(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_InfoGetInfo(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_ResultSetReward(class UObject* WorldContextObject, class UNetHttp* NetHttp, const struct FAJBSetGameRewardParam& RewardParam, float limitSec);
	static class UAJBNetAPI* Request_ResultUploadWinnerResult(class UObject* WorldContextObject, class UNetHttp* NetHttp, const TArray<struct FColor>& ColorBuffer, int32 ImageWidth, int32 ImageHeight, float limitSec);
	static class UAJBNetAPI* Request_SysCharacterParameter(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_SysGetEnv(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_SysMachineError(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_SysNationalMatchInfo(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_SysServeralive(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_SysShopInfo(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_SysVersionInfo(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_TSSRead(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_TUSRead(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_TUSWrite(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI* Request_UserDelete(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_CatalogGetArea(class UNetMessage* Data);
	void Response_CatalogGetLobby(class UNetMessage* Data);
	void Response_CatalogGetRegion(class UNetMessage* Data);
	void Response_GachaDetails(class UNetMessage* Data);
	void Response_InfoGetInfo(class UNetMessage* Data);
	void Response_ResultSetReward(class UNetMessage* Data);
	void Response_ResultUploadWinnerResult(class UNetMessage* Data);
	void Response_SysCharacterParameter(class UNetMessage* Data);
	void Response_SysGetEnv(class UNetMessage* Data);
	void Response_SysMachineError(class UNetMessage* Data);
	void Response_SysNationalMatchInfo(class UNetMessage* Data);
	void Response_SysServeralive(class UNetMessage* Data);
	void Response_SysShopInfo(class UNetMessage* Data);
	void Response_SysVersionInfo(class UNetMessage* Data);
	void Response_TSSRead(class UNetMessage* Data);
	void Response_TUSRead(class UNetMessage* Data);
	void Response_TUSWrite(class UNetMessage* Data);
	void Response_UserDelete(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI">();
	}
	static class UAJBNetAPI* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI>();
	}
};
static_assert(alignof(UAJBNetAPI) == 0x000008, "Wrong alignment on UAJBNetAPI");
static_assert(sizeof(UAJBNetAPI) == 0x000080, "Wrong size on UAJBNetAPI");
static_assert(offsetof(UAJBNetAPI, CachedSetRewardParam) == 0x000030, "Member 'UAJBNetAPI::CachedSetRewardParam' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI, OnSuccess) == 0x000050, "Member 'UAJBNetAPI::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI, OnFailed) == 0x000060, "Member 'UAJBNetAPI::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI, NetHttpObject) == 0x000070, "Member 'UAJBNetAPI::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI, bIsOfflineProcess) == 0x000078, "Member 'UAJBNetAPI::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_Login
// 0x0040 (0x0070 - 0x0030)
class UAJBNetAPI_Login final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnLogin;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   NeedCreateUser;                                    // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0060(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0068(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_69[0x7];                                       // 0x0069(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_Login* Request_UserLoginFromAwm(class UObject* WorldContextObject, class UNetHttp* NetHttp, const struct FAmwTouchInfo& TouchInfo, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UserLogin(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_Login">();
	}
	static class UAJBNetAPI_Login* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_Login>();
	}
};
static_assert(alignof(UAJBNetAPI_Login) == 0x000008, "Wrong alignment on UAJBNetAPI_Login");
static_assert(sizeof(UAJBNetAPI_Login) == 0x000070, "Wrong size on UAJBNetAPI_Login");
static_assert(offsetof(UAJBNetAPI_Login, OnLogin) == 0x000030, "Member 'UAJBNetAPI_Login::OnLogin' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Login, NeedCreateUser) == 0x000040, "Member 'UAJBNetAPI_Login::NeedCreateUser' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Login, OnFailed) == 0x000050, "Member 'UAJBNetAPI_Login::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Login, NetHttpObject) == 0x000060, "Member 'UAJBNetAPI_Login::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Login, bIsOfflineProcess) == 0x000068, "Member 'UAJBNetAPI_Login::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_CreateUser
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_CreateUser final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_CreateUser* Request_UserCreateFromAwm(class UObject* WorldContextObject, class UNetHttp* NetHttp, const struct FAmwTouchInfo& TouchInfo, bool IsGuest, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UserCreate(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_CreateUser">();
	}
	static class UAJBNetAPI_CreateUser* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_CreateUser>();
	}
};
static_assert(alignof(UAJBNetAPI_CreateUser) == 0x000008, "Wrong alignment on UAJBNetAPI_CreateUser");
static_assert(sizeof(UAJBNetAPI_CreateUser) == 0x000060, "Wrong size on UAJBNetAPI_CreateUser");
static_assert(offsetof(UAJBNetAPI_CreateUser, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_CreateUser::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_CreateUser, OnFailed) == 0x000040, "Member 'UAJBNetAPI_CreateUser::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_CreateUser, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_CreateUser::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_CreateUser, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_CreateUser::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_Logout
// 0x0038 (0x0068 - 0x0030)
class UAJBNetAPI_Logout final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsCheck;                                          // 0x0050(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsLoginCancel;                                    // 0x0051(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_52[0x6];                                       // 0x0052(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetHttp*                               NetHttpObject;                                     // 0x0058(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0060(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_61[0x7];                                       // 0x0061(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_Logout* Request_UserLogout(class UObject* WorldContextObject, class UNetHttp* NetHttp, bool IsCheck, bool IsLoginCancel, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UserLogout(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_Logout">();
	}
	static class UAJBNetAPI_Logout* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_Logout>();
	}
};
static_assert(alignof(UAJBNetAPI_Logout) == 0x000008, "Wrong alignment on UAJBNetAPI_Logout");
static_assert(sizeof(UAJBNetAPI_Logout) == 0x000068, "Wrong size on UAJBNetAPI_Logout");
static_assert(offsetof(UAJBNetAPI_Logout, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_Logout::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Logout, OnFailed) == 0x000040, "Member 'UAJBNetAPI_Logout::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Logout, bIsCheck) == 0x000050, "Member 'UAJBNetAPI_Logout::bIsCheck' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Logout, bIsLoginCancel) == 0x000051, "Member 'UAJBNetAPI_Logout::bIsLoginCancel' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Logout, NetHttpObject) == 0x000058, "Member 'UAJBNetAPI_Logout::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_Logout, bIsOfflineProcess) == 0x000060, "Member 'UAJBNetAPI_Logout::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_GetAnnouncement
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_GetAnnouncement final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_GetAnnouncement* Request_InfoGetAnnouncement(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_InfoGetAnnouncement(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_GetAnnouncement">();
	}
	static class UAJBNetAPI_GetAnnouncement* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_GetAnnouncement>();
	}
};
static_assert(alignof(UAJBNetAPI_GetAnnouncement) == 0x000008, "Wrong alignment on UAJBNetAPI_GetAnnouncement");
static_assert(sizeof(UAJBNetAPI_GetAnnouncement) == 0x000060, "Wrong size on UAJBNetAPI_GetAnnouncement");
static_assert(offsetof(UAJBNetAPI_GetAnnouncement, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_GetAnnouncement::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GetAnnouncement, OnFailed) == 0x000040, "Member 'UAJBNetAPI_GetAnnouncement::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GetAnnouncement, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_GetAnnouncement::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GetAnnouncement, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_GetAnnouncement::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_GameResult
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_GameResult final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_GameResult* Request_GameResult(class UObject* WorldContextObject, class UNetHttp* NetHttp, const struct FAJBGameRecord& GameRecord, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_GameResult(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_GameResult">();
	}
	static class UAJBNetAPI_GameResult* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_GameResult>();
	}
};
static_assert(alignof(UAJBNetAPI_GameResult) == 0x000008, "Wrong alignment on UAJBNetAPI_GameResult");
static_assert(sizeof(UAJBNetAPI_GameResult) == 0x000060, "Wrong size on UAJBNetAPI_GameResult");
static_assert(offsetof(UAJBNetAPI_GameResult, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_GameResult::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GameResult, OnFailed) == 0x000040, "Member 'UAJBNetAPI_GameResult::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GameResult, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_GameResult::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GameResult, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_GameResult::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_ResultGetReward
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_ResultGetReward final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_ResultGetReward* Request_ResultGetReward(class UObject* WorldContextObject, class UNetHttp* NetHttp, EAJBGachaType GachaType, float limitSec);
	static class UAJBNetAPI_ResultGetReward* Request_ResultGetRewardCheckGachaID(class UObject* WorldContextObject, class UNetHttp* NetHttp, const struct FAJBGachaID& GachaID, EAJBGachaType GachaType, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_ResultGetReward(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_ResultGetReward">();
	}
	static class UAJBNetAPI_ResultGetReward* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_ResultGetReward>();
	}
};
static_assert(alignof(UAJBNetAPI_ResultGetReward) == 0x000008, "Wrong alignment on UAJBNetAPI_ResultGetReward");
static_assert(sizeof(UAJBNetAPI_ResultGetReward) == 0x000060, "Wrong size on UAJBNetAPI_ResultGetReward");
static_assert(offsetof(UAJBNetAPI_ResultGetReward, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_ResultGetReward::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_ResultGetReward, OnFailed) == 0x000040, "Member 'UAJBNetAPI_ResultGetReward::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_ResultGetReward, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_ResultGetReward::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_ResultGetReward, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_ResultGetReward::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_UserCheck
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_UserCheck final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_UserCheck* Request_UserCheckFromAwm(class UObject* WorldContextObject, class UNetHttp* NetHttp, const struct FAmwTouchInfo& TouchInfo, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UserCheck(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_UserCheck">();
	}
	static class UAJBNetAPI_UserCheck* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_UserCheck>();
	}
};
static_assert(alignof(UAJBNetAPI_UserCheck) == 0x000008, "Wrong alignment on UAJBNetAPI_UserCheck");
static_assert(sizeof(UAJBNetAPI_UserCheck) == 0x000060, "Wrong size on UAJBNetAPI_UserCheck");
static_assert(offsetof(UAJBNetAPI_UserCheck, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_UserCheck::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserCheck, OnFailed) == 0x000040, "Member 'UAJBNetAPI_UserCheck::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserCheck, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_UserCheck::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserCheck, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_UserCheck::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_UserUnlock
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_UserUnlock final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_UserUnlock* Request_LoginedUserUnlock(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);
	static class UAJBNetAPI_UserUnlock* Request_UserUnlockFromAwm(class UObject* WorldContextObject, class UNetHttp* NetHttp, const struct FAmwTouchInfo& TouchInfo, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UserUnlock(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_UserUnlock">();
	}
	static class UAJBNetAPI_UserUnlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_UserUnlock>();
	}
};
static_assert(alignof(UAJBNetAPI_UserUnlock) == 0x000008, "Wrong alignment on UAJBNetAPI_UserUnlock");
static_assert(sizeof(UAJBNetAPI_UserUnlock) == 0x000060, "Wrong size on UAJBNetAPI_UserUnlock");
static_assert(offsetof(UAJBNetAPI_UserUnlock, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_UserUnlock::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserUnlock, OnFailed) == 0x000040, "Member 'UAJBNetAPI_UserUnlock::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserUnlock, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_UserUnlock::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserUnlock, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_UserUnlock::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_UploadHighlight
// 0x00A0 (0x00D0 - 0x0030)
class UAJBNetAPI_UploadHighlight final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnUploadOneSection;                                // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_60[0x60];                                      // 0x0060(0x0060)(Fixing Size After Last Property [ Dumper-7 ])
	class UNetHttp*                               NetHttpObject;                                     // 0x00C0(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x00C8(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_C9[0x7];                                       // 0x00C9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_UploadHighlight* Request_UploadHighlight(class UObject* WorldContextObject, class UNetHttp* NetHttp, const TArray<struct FColor>& ColorBuffer, int32 ImageWidth, int32 ImageHeight, const class FString& HighLightFilePath, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UploadHighlight(class UNetMessage* Data);
	void UploadDataSetup();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_UploadHighlight">();
	}
	static class UAJBNetAPI_UploadHighlight* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_UploadHighlight>();
	}
};
static_assert(alignof(UAJBNetAPI_UploadHighlight) == 0x000008, "Wrong alignment on UAJBNetAPI_UploadHighlight");
static_assert(sizeof(UAJBNetAPI_UploadHighlight) == 0x0000D0, "Wrong size on UAJBNetAPI_UploadHighlight");
static_assert(offsetof(UAJBNetAPI_UploadHighlight, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_UploadHighlight::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UploadHighlight, OnFailed) == 0x000040, "Member 'UAJBNetAPI_UploadHighlight::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UploadHighlight, OnUploadOneSection) == 0x000050, "Member 'UAJBNetAPI_UploadHighlight::OnUploadOneSection' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UploadHighlight, NetHttpObject) == 0x0000C0, "Member 'UAJBNetAPI_UploadHighlight::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UploadHighlight, bIsOfflineProcess) == 0x0000C8, "Member 'UAJBNetAPI_UploadHighlight::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_UploadHeadClerk
// 0x0048 (0x0078 - 0x0030)
class UAJBNetAPI_UploadHeadClerk final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x1F];                                      // 0x0059(0x001F)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_UploadHeadClerk* Request_UploadHeadClerk(class UObject* WorldContextObject, class UNetHttp* NetHttp);
	static void SaveUploadHeadClerk(class UObject* WorldContextObject);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UploadHeadClerk(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_UploadHeadClerk">();
	}
	static class UAJBNetAPI_UploadHeadClerk* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_UploadHeadClerk>();
	}
};
static_assert(alignof(UAJBNetAPI_UploadHeadClerk) == 0x000008, "Wrong alignment on UAJBNetAPI_UploadHeadClerk");
static_assert(sizeof(UAJBNetAPI_UploadHeadClerk) == 0x000078, "Wrong size on UAJBNetAPI_UploadHeadClerk");
static_assert(offsetof(UAJBNetAPI_UploadHeadClerk, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_UploadHeadClerk::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UploadHeadClerk, OnFailed) == 0x000040, "Member 'UAJBNetAPI_UploadHeadClerk::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UploadHeadClerk, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_UploadHeadClerk::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UploadHeadClerk, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_UploadHeadClerk::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_UserExtendBPLock
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_UserExtendBPLock final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_UserExtendBPLock* Request_UserExtendBPLock(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_UserExtendBPLock(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_UserExtendBPLock">();
	}
	static class UAJBNetAPI_UserExtendBPLock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_UserExtendBPLock>();
	}
};
static_assert(alignof(UAJBNetAPI_UserExtendBPLock) == 0x000008, "Wrong alignment on UAJBNetAPI_UserExtendBPLock");
static_assert(sizeof(UAJBNetAPI_UserExtendBPLock) == 0x000060, "Wrong size on UAJBNetAPI_UserExtendBPLock");
static_assert(offsetof(UAJBNetAPI_UserExtendBPLock, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_UserExtendBPLock::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserExtendBPLock, OnFailed) == 0x000040, "Member 'UAJBNetAPI_UserExtendBPLock::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserExtendBPLock, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_UserExtendBPLock::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_UserExtendBPLock, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_UserExtendBPLock::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetAPI_GetRewardLottery
// 0x0030 (0x0060 - 0x0030)
class UAJBNetAPI_GetRewardLottery final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   OnSuccess;                                         // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFailed;                                          // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	class UNetHttp*                               NetHttpObject;                                     // 0x0050(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          bIsOfflineProcess;                                 // 0x0058(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UAJBNetAPI_GetRewardLottery* Request_GetRewardLottery(class UObject* WorldContextObject, class UNetHttp* NetHttp, float limitSec);

	void HttpError(int32 code, const class FString& ErrorMessage);
	void Response_GetRewardLottery(class UNetMessage* Data);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetAPI_GetRewardLottery">();
	}
	static class UAJBNetAPI_GetRewardLottery* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetAPI_GetRewardLottery>();
	}
};
static_assert(alignof(UAJBNetAPI_GetRewardLottery) == 0x000008, "Wrong alignment on UAJBNetAPI_GetRewardLottery");
static_assert(sizeof(UAJBNetAPI_GetRewardLottery) == 0x000060, "Wrong size on UAJBNetAPI_GetRewardLottery");
static_assert(offsetof(UAJBNetAPI_GetRewardLottery, OnSuccess) == 0x000030, "Member 'UAJBNetAPI_GetRewardLottery::OnSuccess' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GetRewardLottery, OnFailed) == 0x000040, "Member 'UAJBNetAPI_GetRewardLottery::OnFailed' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GetRewardLottery, NetHttpObject) == 0x000050, "Member 'UAJBNetAPI_GetRewardLottery::NetHttpObject' has a wrong offset!");
static_assert(offsetof(UAJBNetAPI_GetRewardLottery, bIsOfflineProcess) == 0x000058, "Member 'UAJBNetAPI_GetRewardLottery::bIsOfflineProcess' has a wrong offset!");

// Class AJB.AJBNetVaryFloatComponent
// 0x0030 (0x0120 - 0x00F0)
class UAJBNetVaryFloatComponent final : public UActorComponent
{
public:
	float                                         Value;                                             // 0x00F0(0x0004)(BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DeltaPerSecond;                                    // 0x00F4(0x0004)(Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueMax;                                          // 0x00F8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ValueMin;                                          // 0x00FC(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, Net, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnValueArrivedMax;                                 // 0x0100(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnValueArrivedMin;                                 // 0x0110(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void MC_ReqReplicated();
	void ROC_RepValue(float NewValue);
	void ROS_GoodValue(float GoodValue);
	void ROS_SetDeltaPerSecond(float NewDeltaPerScond);
	void ROS_SetValue(float NewValue);
	void ROS_SetValueMax(float NewValue);
	void ROS_SetValueMin(float NewValue);
	void SetDeltaPerSecond(float NewDeltaPerScond);
	void SetValue(float NewValue);
	void SetValueMax(float NewValue);
	void SetValueMin(float NewValue);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetVaryFloatComponent">();
	}
	static class UAJBNetVaryFloatComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetVaryFloatComponent>();
	}
};
static_assert(alignof(UAJBNetVaryFloatComponent) == 0x000008, "Wrong alignment on UAJBNetVaryFloatComponent");
static_assert(sizeof(UAJBNetVaryFloatComponent) == 0x000120, "Wrong size on UAJBNetVaryFloatComponent");
static_assert(offsetof(UAJBNetVaryFloatComponent, Value) == 0x0000F0, "Member 'UAJBNetVaryFloatComponent::Value' has a wrong offset!");
static_assert(offsetof(UAJBNetVaryFloatComponent, DeltaPerSecond) == 0x0000F4, "Member 'UAJBNetVaryFloatComponent::DeltaPerSecond' has a wrong offset!");
static_assert(offsetof(UAJBNetVaryFloatComponent, ValueMax) == 0x0000F8, "Member 'UAJBNetVaryFloatComponent::ValueMax' has a wrong offset!");
static_assert(offsetof(UAJBNetVaryFloatComponent, ValueMin) == 0x0000FC, "Member 'UAJBNetVaryFloatComponent::ValueMin' has a wrong offset!");
static_assert(offsetof(UAJBNetVaryFloatComponent, OnValueArrivedMax) == 0x000100, "Member 'UAJBNetVaryFloatComponent::OnValueArrivedMax' has a wrong offset!");
static_assert(offsetof(UAJBNetVaryFloatComponent, OnValueArrivedMin) == 0x000110, "Member 'UAJBNetVaryFloatComponent::OnValueArrivedMin' has a wrong offset!");

// Class AJB.AJBNetworkObserver
// 0x01E0 (0x0208 - 0x0028)
class UAJBNetworkObserver final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	class UAJBGameInstance*                       RefGameInstance;                                   // 0x0030(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBAllNetTenpoError                          TenpoError;                                        // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBAllNetError                               AllNetError;                                       // 0x0039(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBAllNetGameError                           GameServerError;                                   // 0x003A(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBTestModeAllNetError                       TestModeAllNetError;                               // 0x003B(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBTestModeGameServerError                   TestModeGameError;                                 // 0x003C(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBTestModeUpdateServerError                 TestModeUpdateServerError;                         // 0x003D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3E[0x2];                                       // 0x003E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TenpoIP;                                           // 0x0040(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HopNum;                                            // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_54[0x4];                                       // 0x0054(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NetID;                                             // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AllNetGameVer;                                     // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 IP;                                                // 0x0078(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Mask;                                              // 0x0088(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Gateway;                                           // 0x0098(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 DNS;                                               // 0x00A8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TenpoName;                                         // 0x00B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameID;                                            // 0x00C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 SerialNumber;                                      // 0x00D8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TenpoID;                                           // 0x00E8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 AuthTenpoID;                                       // 0x00F8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionCode;                                        // 0x0108(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionName0;                                       // 0x0118(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionName1;                                       // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionName2;                                       // 0x0138(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RegionName3;                                       // 0x0148(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 CountryCode;                                       // 0x0158(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameServerHost;                                    // 0x0168(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 GameServerURL;                                     // 0x0178(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MuchaGameID;                                       // 0x0188(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAMSoftwearUpdateStatus                       SoftwearUpdateStatus;                              // 0x0198(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_199[0x7];                                      // 0x0199(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MuchaAppVersion;                                   // 0x01A0(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsMuchaServerOK;                                  // 0x01B0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B1[0x7];                                      // 0x01B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 MuchaUpdateVersion;                                // 0x01B8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MuchaDownloadVersion;                              // 0x01C8(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MuchaDownload;                                     // 0x01D8(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBLocalNetCheckState                        StateCable;                                        // 0x01DC(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBLocalNetCheckState                        StateContentRouter;                                // 0x01DD(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBLocalNetCheckState                        StateTenpoRouter;                                  // 0x01DE(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBLocalNetCheckState                        StateHopNum;                                       // 0x01DF(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsALLNetMaintenanceTime;                          // 0x01E0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1E1[0x21];                                     // 0x01E1(0x0021)(Fixing Size After Last Property [ Dumper-7 ])
	EAllNetReAuthStateID                          ReAuthStateID;                                     // 0x0202(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_203[0x5];                                      // 0x0203(0x0005)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void CheckAMNetworkError(class UObject* WorldContextObject);
	static void CheckLocalNetworkError(class UObject* WorldContextObject);
	static bool IsOfflineMode(class UObject* WorldContextObject);

	void BeginGameServerCheck();
	bool CheckLocalNetwork();
	void EndGameServerCheck(EAJBTestModeGameServerError Error);
	class FString GetAuthGateway();
	class FString GetMacAddress();
	class FString GetShopSupportWebSiteLogInID();
	class FString GetShopSupportWebSiteLogInPassword();
	bool IsFinishedCheckLocalNetwork();
	bool IsInitializeAuth();
	bool IsServerUpdateMode();
	bool RequestAllNetLicense();
	void RequestMuchaLicense();
	bool RequestRestartNet();
	void SetNetworkTest(bool IsNetworkTest);
	bool SetServerUpdateMode(bool bIsSeverUpdateMode);
	void UpdateAllNetInfo();
	void UpdateLocalNetworkInfo();

	class FString GetNetID() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBNetworkObserver">();
	}
	static class UAJBNetworkObserver* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBNetworkObserver>();
	}
};
static_assert(alignof(UAJBNetworkObserver) == 0x000008, "Wrong alignment on UAJBNetworkObserver");
static_assert(sizeof(UAJBNetworkObserver) == 0x000208, "Wrong size on UAJBNetworkObserver");
static_assert(offsetof(UAJBNetworkObserver, RefGameInstance) == 0x000030, "Member 'UAJBNetworkObserver::RefGameInstance' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, TenpoError) == 0x000038, "Member 'UAJBNetworkObserver::TenpoError' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, AllNetError) == 0x000039, "Member 'UAJBNetworkObserver::AllNetError' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, GameServerError) == 0x00003A, "Member 'UAJBNetworkObserver::GameServerError' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, TestModeAllNetError) == 0x00003B, "Member 'UAJBNetworkObserver::TestModeAllNetError' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, TestModeGameError) == 0x00003C, "Member 'UAJBNetworkObserver::TestModeGameError' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, TestModeUpdateServerError) == 0x00003D, "Member 'UAJBNetworkObserver::TestModeUpdateServerError' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, TenpoIP) == 0x000040, "Member 'UAJBNetworkObserver::TenpoIP' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, HopNum) == 0x000050, "Member 'UAJBNetworkObserver::HopNum' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, NetID) == 0x000058, "Member 'UAJBNetworkObserver::NetID' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, AllNetGameVer) == 0x000068, "Member 'UAJBNetworkObserver::AllNetGameVer' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, IP) == 0x000078, "Member 'UAJBNetworkObserver::IP' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, Mask) == 0x000088, "Member 'UAJBNetworkObserver::Mask' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, Gateway) == 0x000098, "Member 'UAJBNetworkObserver::Gateway' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, DNS) == 0x0000A8, "Member 'UAJBNetworkObserver::DNS' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, TenpoName) == 0x0000B8, "Member 'UAJBNetworkObserver::TenpoName' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, GameID) == 0x0000C8, "Member 'UAJBNetworkObserver::GameID' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, SerialNumber) == 0x0000D8, "Member 'UAJBNetworkObserver::SerialNumber' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, TenpoID) == 0x0000E8, "Member 'UAJBNetworkObserver::TenpoID' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, AuthTenpoID) == 0x0000F8, "Member 'UAJBNetworkObserver::AuthTenpoID' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, RegionCode) == 0x000108, "Member 'UAJBNetworkObserver::RegionCode' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, RegionName0) == 0x000118, "Member 'UAJBNetworkObserver::RegionName0' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, RegionName1) == 0x000128, "Member 'UAJBNetworkObserver::RegionName1' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, RegionName2) == 0x000138, "Member 'UAJBNetworkObserver::RegionName2' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, RegionName3) == 0x000148, "Member 'UAJBNetworkObserver::RegionName3' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, CountryCode) == 0x000158, "Member 'UAJBNetworkObserver::CountryCode' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, GameServerHost) == 0x000168, "Member 'UAJBNetworkObserver::GameServerHost' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, GameServerURL) == 0x000178, "Member 'UAJBNetworkObserver::GameServerURL' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, MuchaGameID) == 0x000188, "Member 'UAJBNetworkObserver::MuchaGameID' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, SoftwearUpdateStatus) == 0x000198, "Member 'UAJBNetworkObserver::SoftwearUpdateStatus' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, MuchaAppVersion) == 0x0001A0, "Member 'UAJBNetworkObserver::MuchaAppVersion' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, bIsMuchaServerOK) == 0x0001B0, "Member 'UAJBNetworkObserver::bIsMuchaServerOK' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, MuchaUpdateVersion) == 0x0001B8, "Member 'UAJBNetworkObserver::MuchaUpdateVersion' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, MuchaDownloadVersion) == 0x0001C8, "Member 'UAJBNetworkObserver::MuchaDownloadVersion' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, MuchaDownload) == 0x0001D8, "Member 'UAJBNetworkObserver::MuchaDownload' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, StateCable) == 0x0001DC, "Member 'UAJBNetworkObserver::StateCable' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, StateContentRouter) == 0x0001DD, "Member 'UAJBNetworkObserver::StateContentRouter' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, StateTenpoRouter) == 0x0001DE, "Member 'UAJBNetworkObserver::StateTenpoRouter' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, StateHopNum) == 0x0001DF, "Member 'UAJBNetworkObserver::StateHopNum' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, bIsALLNetMaintenanceTime) == 0x0001E0, "Member 'UAJBNetworkObserver::bIsALLNetMaintenanceTime' has a wrong offset!");
static_assert(offsetof(UAJBNetworkObserver, ReAuthStateID) == 0x000202, "Member 'UAJBNetworkObserver::ReAuthStateID' has a wrong offset!");

// Class AJB.AJBOnlineBeaconClient
// 0x0000 (0x03A0 - 0x03A0)
class AAJBOnlineBeaconClient : public AOnlineBeaconClient
{
public:
	int32 ConvertPortNoDedicatedServerToBeaconHost(int32 DedicatedServerPort);
	void JoinBeacon(const class FString& HostName, int32 Port);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBOnlineBeaconClient">();
	}
	static class AAJBOnlineBeaconClient* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBOnlineBeaconClient>();
	}
};
static_assert(alignof(AAJBOnlineBeaconClient) == 0x000008, "Wrong alignment on AAJBOnlineBeaconClient");
static_assert(sizeof(AAJBOnlineBeaconClient) == 0x0003A0, "Wrong size on AAJBOnlineBeaconClient");

// Class AJB.AJBOnlineBeaconHost
// 0x0000 (0x0408 - 0x0408)
class AAJBOnlineBeaconHost final : public AOnlineBeaconHost
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBOnlineBeaconHost">();
	}
	static class AAJBOnlineBeaconHost* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBOnlineBeaconHost>();
	}
};
static_assert(alignof(AAJBOnlineBeaconHost) == 0x000008, "Wrong alignment on AAJBOnlineBeaconHost");
static_assert(sizeof(AAJBOnlineBeaconHost) == 0x000408, "Wrong size on AAJBOnlineBeaconHost");

// Class AJB.AJBOnlineBeaconHostObject
// 0x0000 (0x0350 - 0x0350)
class AAJBOnlineBeaconHostObject final : public AOnlineBeaconHostObject
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBOnlineBeaconHostObject">();
	}
	static class AAJBOnlineBeaconHostObject* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBOnlineBeaconHostObject>();
	}
};
static_assert(alignof(AAJBOnlineBeaconHostObject) == 0x000008, "Wrong alignment on AAJBOnlineBeaconHostObject");
static_assert(sizeof(AAJBOnlineBeaconHostObject) == 0x000350, "Wrong size on AAJBOnlineBeaconHostObject");

// Class AJB.AJBOperationParam
// 0x0050 (0x0078 - 0x0028)
class UAJBOperationParam final : public UObject
{
public:
	bool                                          bEnableOperatingParameter;                         // 0x0028(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x27];                                      // 0x0029(0x0027)(Fixing Size After Last Property [ Dumper-7 ])
	struct FAJBOperationParameterInformation      Information;                                       // 0x0050(0x0020)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	class UAJBGameInstance*                       GameInstanceObj;                                   // 0x0070(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void ResetOperationParam();
	void SetEnableOperatingparameter(bool bEnable);
	void SetGameInstance(class UAJBGameInstance* GameInstance);
	void SetupSave_OperationParamater(TArray<uint8>* Data);
	void UpdateOperationParamFromNewInformation();

	bool IsWithInDateScope() const;
	bool ShouldAdaptionOperationParameter() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBOperationParam">();
	}
	static class UAJBOperationParam* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBOperationParam>();
	}
};
static_assert(alignof(UAJBOperationParam) == 0x000008, "Wrong alignment on UAJBOperationParam");
static_assert(sizeof(UAJBOperationParam) == 0x000078, "Wrong size on UAJBOperationParam");
static_assert(offsetof(UAJBOperationParam, bEnableOperatingParameter) == 0x000028, "Member 'UAJBOperationParam::bEnableOperatingParameter' has a wrong offset!");
static_assert(offsetof(UAJBOperationParam, Information) == 0x000050, "Member 'UAJBOperationParam::Information' has a wrong offset!");
static_assert(offsetof(UAJBOperationParam, GameInstanceObj) == 0x000070, "Member 'UAJBOperationParam::GameInstanceObj' has a wrong offset!");

// Class AJB.AJBOutGamePlayerController
// 0x0000 (0x06F8 - 0x06F8)
class AAJBOutGamePlayerController : public AAJBPlayerControllerBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBOutGamePlayerController">();
	}
	static class AAJBOutGamePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBOutGamePlayerController>();
	}
};
static_assert(alignof(AAJBOutGamePlayerController) == 0x000008, "Wrong alignment on AAJBOutGamePlayerController");
static_assert(sizeof(AAJBOutGamePlayerController) == 0x0006F8, "Wrong size on AAJBOutGamePlayerController");

// Class AJB.AJBOutGameProxy
// 0x00E0 (0x0408 - 0x0328)
class AAJBOutGameProxy : public AActor
{
public:
	EOutGameProxyState                            OutGameProxyState;                                 // 0x0328(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_329[0x7];                                      // 0x0329(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RoomHostUserID;                                    // 0x0330(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MatchingRemainTime;                                // 0x0340(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsSelectedStartLocation;                          // 0x0344(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_345[0x3];                                      // 0x0345(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 DedicatedServerIP;                                 // 0x0348(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DedicatedServerPort;                               // 0x0358(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERetryScokcetConnectType                      RetryScokcetConnectType;                           // 0x035C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EReconnectRetryProtocol                       ReconnectRetryProtocol;                            // 0x035D(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_35E[0x2];                                      // 0x035E(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SelectX;                                           // 0x0360(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	int32                                         SelectY;                                           // 0x0364(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, Protected, HasGetValueTypeHash, NativeAccessSpecifierProtected)
	uint8                                         Pad_368[0xA0];                                     // 0x0368(0x00A0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static void OutputLogMatchingPlayerInfo(const struct FMatchingPlayerInfo& MatchingPlayerInfo);

	bool CanTenpoBattle();
	void ClearPairRoomInfo();
	void ClearProtocolTimeOut(int32 ProtocolID);
	class UNetMessage* CreateNetMessage_ChangeCharacter();
	class UNetMessage* CreateNetMessage_CreateRoom(int32 RoomNo);
	class UNetMessage* CreateNetMessage_DeletePairIDMatch(const class FString& PairMatchID);
	class UNetMessage* CreateNetMessage_DeleteRoom();
	class UNetMessage* CreateNetMessage_EnterRoom(int32 RoomNo);
	class UNetMessage* CreateNetMessage_GetRoomInfo();
	class UNetMessage* CreateNetMessage_Matching_Breakup();
	class UNetMessage* CreateNetMessage_Matching_Finish();
	class UNetMessage* CreateNetMessage_Matching_Start(bool IsReconnect);
	class UNetMessage* CreateNetMessage_PairIDMatch(const class FString& PairMatchID);
	class UNetMessage* CreateNetMessage_PairRandomMatch();
	class UNetMessage* CreateNetMessage_ServerTest();
	class UNetMessage* CreateNetMessage_StartLocation_GetNPCInfo();
	class UNetMessage* CreateNetMessage_StartLocation_GetPlayerInfo(int32 X, int32 Y, bool bIsPartnerNPC);
	class UNetMessage* CreateNetMessage_Tenpo_EnterRoom(int32 TimeLimit);
	class UNetMessage* CreateNetMessage_Tenpo_ExitRoom();
	class UNetMessage* CreateNetMessage_Tenpo_GameSetting(int32 NPCNum, int32 PlayMode, int32 AreaId);
	class UNetMessage* CreateNetMessage_Tenpo_GetRoomInfo();
	class UNetMessage* CreateNetMessage_Tenpo_Logined();
	class UNetMessage* CreateNetMessage_Tenpo_StartMatching(int32 InAreaType);
	void DebugSetupLoginPlayerInfo(bool bForceSetting);
	void DecodeCustomData(struct FCustomData* OutCustomData, const class FString& InDecodeString);
	void EncodeCustomData(class FString* OutEncodeString, const struct FCustomData& InCustomData);
	class FString GetOpenCommand();
	int32 GetTenpoBattleDamageAreaType();
	float GetTenpoRoomRemainingTimeSeconds();
	bool HasTenpoHostIP();
	bool IsTenpoHost();
	void NotifyAPI_ChangeRoomInfo(class UNetMessage* Msg);
	void NotifyAPI_Matching_Status(class UNetMessage* Msg);
	void NotifyAPI_PairRandomMatch(class UNetMessage* Msg);
	void NotifyAPI_StartLocation_GetPlayerInfo(class UNetMessage* Msg);
	void NotifyAPI_Tenpo_ChangeGameSetting(class UNetMessage* Msg);
	void NotifyAPI_Tenpo_ChangeRoomInfo(class UNetMessage* Msg);
	void NotifyAPI_Tenpo_Logined(class UNetMessage* Msg);
	void NotifyAPI_Tenpo_Matching(class UNetMessage* Msg);
	void OnErrorHttp(int32 code, const class FString& errmsg);
	void OnFaildMatching();
	void OnFinieshedLoginTenpoMatching();
	void OnFinishedSelectedStartLocation();
	void OnNotHeldMatching();
	void OnNotifyFailedStartedMatch();
	void OnNotifyTenpoDeleteRoom();
	void OnNotifyTenpoGameSettings(int32 CPUNum, bool ExchangeMode, int32 AreaId);
	void OnNotifyUpdatePairMatchingRoomInfo();
	void OnNotifyUpdateSelectCharacter(bool bFinished, const struct FRoomPlayerInfo& RoomPlayerInfo);
	void OnNotifyUpdateTenpoMatching(ETenpoMatchingResult Result);
	void OnNotifyUpdateTenpoRoomInfo();
	void OnProtocolRequestTimeout();
	void OnResponsCharacterSelect(bool bSuccess);
	void OnResponseCreateRoom(bool bSuccess);
	void OnResponseDeletePairIDMatch(bool bSuccess);
	void OnResponseDeleteRoom(bool bSuccess);
	void OnResponseEnterRoom(bool bSuccess);
	void OnResponsePairIDMatching(bool bSuccessMatching, int32 RemainTime);
	void OnResponsePairMatching(bool bSuccessMatching, const struct FMatchingPlayerInfo& PairMatchingPlayerInfo);
	void OnResponseRandomPairMatching(bool bSuccessMatching);
	void OnResponseSelectStartLocation(EResultStartLocation Result, int32 X, int32 Y, const class FString& UserID);
	void OnResponseServerTest(bool bSuccess);
	void OnResponseTenpoDeleteRoom(bool bSuccess);
	void OnResponseTenpoEnterRoom(bool bSuccess, ETenpoRoomEnterResult Result);
	void OnResponseTenpoGameSettings(bool bSuccess);
	void OnResponseTenpoStartMatching(bool bSuccess);
	void OnResponseTimeoutPairIDMatching();
	void OnResponseTimeoutPairMatching();
	void OnResponseUpdateTenpoRoomInfo();
	void OnServerError();
	void OnStartMatching();
	void OnSuccessBreakupmatching();
	void OnUpdateMatchingStatus(bool bComplete);
	void OnUpdateNPCInfo();
	void OnUpdateStartLocationPlayerInfo();
	void Receive_SocketNetMessage(class UNetMessage* Msg);
	void ResponseAPI_ChangeCharacter(class UNetMessage* Msg);
	void ResponseAPI_CreateRoom(class UNetMessage* Msg);
	void ResponseAPI_DeletePairIDMatch(class UNetMessage* Msg);
	void ResponseAPI_DeleteRoom(class UNetMessage* Msg);
	void ResponseAPI_EnterRoom(class UNetMessage* Msg);
	void ResponseAPI_GetRoomInfo(class UNetMessage* Msg);
	void ResponseAPI_Matching_Breakup(class UNetMessage* Msg);
	void ResponseAPI_Matching_Finish(class UNetMessage* Msg);
	void ResponseAPI_Matching_Start(class UNetMessage* Msg);
	void ResponseAPI_PairIDMatch(class UNetMessage* Msg);
	void ResponseAPI_PairRandomMatch(class UNetMessage* Msg);
	void ResponseAPI_ServerTest(class UNetMessage* Msg);
	void ResponseAPI_StartLocation_GetNPCInfo(class UNetMessage* Msg);
	void ResponseAPI_StartLocation_GetPlayerInfo(class UNetMessage* Msg);
	void ResponseAPI_Tenpo_EnterRoom(class UNetMessage* Msg);
	void ResponseAPI_Tenpo_ExitRoom(class UNetMessage* Msg);
	void ResponseAPI_Tenpo_GameSetting(class UNetMessage* Msg);
	void ResponseAPI_Tenpo_GetRoomInfo(class UNetMessage* Msg);
	void ResponseAPI_Tenpo_Logined(class UNetMessage* Msg);
	void ResponseAPI_Tenpo_Matching(class UNetMessage* Msg);
	void SetOutGameProxyState(EOutGameProxyState State);
	void SetReconnectRetryProtocol(EReconnectRetryProtocol RequestProtocol);
	void SetSolvedProtocol(EReconnectRetryProtocol RequestProtocol);
	void SetupPartnerNPCMatchingPlayerInfo();
	void StartProtocolRequestTimeOut(int32 ProtocolID, float TimeOutSecond);
	bool TryGetPartnerMatchingPlayerInfo(struct FMatchingPlayerInfo* PairMatchingPlayerInfo);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBOutGameProxy">();
	}
	static class AAJBOutGameProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBOutGameProxy>();
	}
};
static_assert(alignof(AAJBOutGameProxy) == 0x000008, "Wrong alignment on AAJBOutGameProxy");
static_assert(sizeof(AAJBOutGameProxy) == 0x000408, "Wrong size on AAJBOutGameProxy");
static_assert(offsetof(AAJBOutGameProxy, OutGameProxyState) == 0x000328, "Member 'AAJBOutGameProxy::OutGameProxyState' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, RoomHostUserID) == 0x000330, "Member 'AAJBOutGameProxy::RoomHostUserID' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, MatchingRemainTime) == 0x000340, "Member 'AAJBOutGameProxy::MatchingRemainTime' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, bIsSelectedStartLocation) == 0x000344, "Member 'AAJBOutGameProxy::bIsSelectedStartLocation' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, DedicatedServerIP) == 0x000348, "Member 'AAJBOutGameProxy::DedicatedServerIP' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, DedicatedServerPort) == 0x000358, "Member 'AAJBOutGameProxy::DedicatedServerPort' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, RetryScokcetConnectType) == 0x00035C, "Member 'AAJBOutGameProxy::RetryScokcetConnectType' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, ReconnectRetryProtocol) == 0x00035D, "Member 'AAJBOutGameProxy::ReconnectRetryProtocol' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, SelectX) == 0x000360, "Member 'AAJBOutGameProxy::SelectX' has a wrong offset!");
static_assert(offsetof(AAJBOutGameProxy, SelectY) == 0x000364, "Member 'AAJBOutGameProxy::SelectY' has a wrong offset!");

// Class AJB.AJBParamAccessor
// 0x0000 (0x0028 - 0x0028)
class UAJBParamAccessor final : public UBlueprintFunctionLibrary
{
public:
	static void AssignParamsFromContentArray(class UObject* WorldContextObject, class UClass* ClassRef, class UObject* Object, class FName Filename, int32 ArrayIndex);
	static void AssignParamsFromContentMap(class UObject* WorldContextObject, class UClass* ClassRef, class UObject* Object, class FName Filename, class FName ContentName);
	static void AssignParamsFromDefaultContent(class UObject* WorldContextObject, class UClass* ClassRef, class UObject* Object, class FName Filename);
	static class UAJBParamContent* GetParamContentArray(class UObject* WorldContextObject, class FName Filename, int32 ArrayIndex);
	static class UAJBParamContent* GetParamContentMap(class UObject* WorldContextObject, class FName Filename, class FName ContentName);
	static class UAJBParamContent* GetParamDefaultContent(class UObject* WorldContextObject, class FName Filename);
	static class UAJBParamFile* GetParamFile(class UObject* WorldContextObject, class FName Filename);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBParamAccessor">();
	}
	static class UAJBParamAccessor* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBParamAccessor>();
	}
};
static_assert(alignof(UAJBParamAccessor) == 0x000008, "Wrong alignment on UAJBParamAccessor");
static_assert(sizeof(UAJBParamAccessor) == 0x000028, "Wrong size on UAJBParamAccessor");

// Class AJB.AJBParamContent
// 0x00F0 (0x0118 - 0x0028)
class UAJBParamContent final : public UObject
{
public:
	uint8                                         Pad_28[0xF0];                                      // 0x0028(0x00F0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	bool Contains(class FName Name_0) const;
	bool GetBoolValue(class FName Name_0) const;
	float GetFloatValue(class FName Name_0) const;
	class FString GetStringValue(class FName Name_0) const;
	struct FVector GetVectorValue(class FName Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBParamContent">();
	}
	static class UAJBParamContent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBParamContent>();
	}
};
static_assert(alignof(UAJBParamContent) == 0x000008, "Wrong alignment on UAJBParamContent");
static_assert(sizeof(UAJBParamContent) == 0x000118, "Wrong size on UAJBParamContent");

// Class AJB.AJBParamFile
// 0x0078 (0x00A0 - 0x0028)
class UAJBParamFile final : public UObject
{
public:
	uint8                                         Pad_28[0x8];                                       // 0x0028(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	TMap<class FName, class UAJBParamContent*>    ContentMap;                                        // 0x0030(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<class UAJBParamContent*>               ContentArray;                                      // 0x0080(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UAJBParamContent*                       OperationParamContent;                             // 0x0090(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class UAJBOperationParam*                     OperationParam;                                    // 0x0098(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void SetOperationParam(class UAJBOperationParam* NewOperationParam);

	bool Contains(class FName Name_0) const;
	int32 ContentNum() const;
	class UAJBParamContent* GetContentArray(int32 ArrayIndex) const;
	class UAJBParamContent* GetContentMap(class FName ContentName) const;
	class UAJBParamContent* GetDefaultContent() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBParamFile">();
	}
	static class UAJBParamFile* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBParamFile>();
	}
};
static_assert(alignof(UAJBParamFile) == 0x000008, "Wrong alignment on UAJBParamFile");
static_assert(sizeof(UAJBParamFile) == 0x0000A0, "Wrong size on UAJBParamFile");
static_assert(offsetof(UAJBParamFile, ContentMap) == 0x000030, "Member 'UAJBParamFile::ContentMap' has a wrong offset!");
static_assert(offsetof(UAJBParamFile, ContentArray) == 0x000080, "Member 'UAJBParamFile::ContentArray' has a wrong offset!");
static_assert(offsetof(UAJBParamFile, OperationParamContent) == 0x000090, "Member 'UAJBParamFile::OperationParamContent' has a wrong offset!");
static_assert(offsetof(UAJBParamFile, OperationParam) == 0x000098, "Member 'UAJBParamFile::OperationParam' has a wrong offset!");

// Class AJB.AJBParamRepos
// 0x0058 (0x0080 - 0x0028)
class UAJBParamRepos final : public UObject
{
public:
	TMap<class FName, class UAJBParamFile*>       Files;                                             // 0x0028(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UAJBOperationParam*                     OperationParam;                                    // 0x0078(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)

public:
	void AssignParamsFromContentArray(class UClass* ClassRef, class UObject* Object, class FName Filename, int32 ArrayIndex);
	void AssignParamsFromContentMap(class UClass* ClassRef, class UObject* Object, class FName Filename, class FName ContentName);
	void AssignParamsFromDefaultContent(class UClass* ClassRef, class UObject* Object, class FName Filename);
	bool CheckExistParamFile(const class FString& Filename);
	void LoadOperationParam(const class FString& ParamJson);
	void LoadParamFile(const class FString& Filename);
	void RemoveOperationParam();
	void SetOperationParam(class UAJBOperationParam* OperationParam_0);

	class UAJBParamFile* GetFile(class FName Name_0) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBParamRepos">();
	}
	static class UAJBParamRepos* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBParamRepos>();
	}
};
static_assert(alignof(UAJBParamRepos) == 0x000008, "Wrong alignment on UAJBParamRepos");
static_assert(sizeof(UAJBParamRepos) == 0x000080, "Wrong size on UAJBParamRepos");
static_assert(offsetof(UAJBParamRepos, Files) == 0x000028, "Member 'UAJBParamRepos::Files' has a wrong offset!");
static_assert(offsetof(UAJBParamRepos, OperationParam) == 0x000078, "Member 'UAJBParamRepos::OperationParam' has a wrong offset!");

// Class AJB.AJBPlayerCameraManager
// 0x0000 (0x25F0 - 0x25F0)
class AAJBPlayerCameraManager : public APlayerCameraManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPlayerCameraManager">();
	}
	static class AAJBPlayerCameraManager* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBPlayerCameraManager>();
	}
};
static_assert(alignof(AAJBPlayerCameraManager) == 0x000010, "Wrong alignment on AAJBPlayerCameraManager");
static_assert(sizeof(AAJBPlayerCameraManager) == 0x0025F0, "Wrong size on AAJBPlayerCameraManager");

// Class AJB.AJBPlayerInfoUtility
// 0x0000 (0x0028 - 0x0028)
class UAJBPlayerInfoUtility final : public UBlueprintFunctionLibrary
{
public:
	static void ClearResultAtTime(class UObject* WorldContextObject);
	static class FString ConvNumberHankakuToZenkaku(const class FString& Source);
	static void FixLogoutTime(class UObject* WorldContextObject);
	static int32 GetNextExtendBPUnlockSecond(class UObject* WorldContextObject);
	static class FString MakeAutoPlayerName(const class FString& NamePrefix, bool bAvoidNG, bool bUseSerialNumber);
	static void SetBotFMatchingPlayerInfo(struct FMatchingPlayerInfo* OutMatchingPlayerInfo, const class FString& UserID);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPlayerInfoUtility">();
	}
	static class UAJBPlayerInfoUtility* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPlayerInfoUtility>();
	}
};
static_assert(alignof(UAJBPlayerInfoUtility) == 0x000008, "Wrong alignment on UAJBPlayerInfoUtility");
static_assert(sizeof(UAJBPlayerInfoUtility) == 0x000028, "Wrong size on UAJBPlayerInfoUtility");

// Class AJB.AJBPrimaryDataAsset
// 0x0008 (0x0038 - 0x0030)
class UAJBPrimaryDataAsset : public UPrimaryDataAsset
{
public:
	struct FPrimaryAssetType                      PrimaryType;                                       // 0x0030(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	class FString GetIdentifierString() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPrimaryDataAsset">();
	}
	static class UAJBPrimaryDataAsset* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPrimaryDataAsset>();
	}
};
static_assert(alignof(UAJBPrimaryDataAsset) == 0x000008, "Wrong alignment on UAJBPrimaryDataAsset");
static_assert(sizeof(UAJBPrimaryDataAsset) == 0x000038, "Wrong size on UAJBPrimaryDataAsset");
static_assert(offsetof(UAJBPrimaryDataAsset, PrimaryType) == 0x000030, "Member 'UAJBPrimaryDataAsset::PrimaryType' has a wrong offset!");

// Class AJB.AJBPrimaryBeforehand
// 0x00B0 (0x00E8 - 0x0038)
class UAJBPrimaryBeforehand final : public UAJBPrimaryDataAsset
{
public:
	TArray<TSubclassOf<class AAJBInGameEnviroment>> EnviromentClasses;                               // 0x0038(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AAJBInGameGate>>     GateClasses;                                       // 0x0048(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AAJBInGameHouse>>    HouseClasses;                                      // 0x0058(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AAJBInGameProp>>     PropClasses;                                       // 0x0068(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<TSubclassOf<class AAJBInGameWindow>>   WindowClasses;                                     // 0x0078(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)
	TArray<class USkeletalMesh*>                  SkeletalMeshObjects;                               // 0x0088(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UStaticMesh*>                    StaticMeshObjects;                                 // 0x0098(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimMontage*>                   AnimMontageObjects;                                // 0x00A8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UAnimSequence*>                  AnimSequenceObjects;                               // 0x00B8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UBlendSpaceBase*>                BlendSpaceObjects;                                 // 0x00C8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<class UObject*>                        OtherObjects;                                      // 0x00D8(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPrimaryBeforehand">();
	}
	static class UAJBPrimaryBeforehand* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPrimaryBeforehand>();
	}
};
static_assert(alignof(UAJBPrimaryBeforehand) == 0x000008, "Wrong alignment on UAJBPrimaryBeforehand");
static_assert(sizeof(UAJBPrimaryBeforehand) == 0x0000E8, "Wrong size on UAJBPrimaryBeforehand");
static_assert(offsetof(UAJBPrimaryBeforehand, EnviromentClasses) == 0x000038, "Member 'UAJBPrimaryBeforehand::EnviromentClasses' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, GateClasses) == 0x000048, "Member 'UAJBPrimaryBeforehand::GateClasses' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, HouseClasses) == 0x000058, "Member 'UAJBPrimaryBeforehand::HouseClasses' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, PropClasses) == 0x000068, "Member 'UAJBPrimaryBeforehand::PropClasses' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, WindowClasses) == 0x000078, "Member 'UAJBPrimaryBeforehand::WindowClasses' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, SkeletalMeshObjects) == 0x000088, "Member 'UAJBPrimaryBeforehand::SkeletalMeshObjects' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, StaticMeshObjects) == 0x000098, "Member 'UAJBPrimaryBeforehand::StaticMeshObjects' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, AnimMontageObjects) == 0x0000A8, "Member 'UAJBPrimaryBeforehand::AnimMontageObjects' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, AnimSequenceObjects) == 0x0000B8, "Member 'UAJBPrimaryBeforehand::AnimSequenceObjects' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, BlendSpaceObjects) == 0x0000C8, "Member 'UAJBPrimaryBeforehand::BlendSpaceObjects' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryBeforehand, OtherObjects) == 0x0000D8, "Member 'UAJBPrimaryBeforehand::OtherObjects' has a wrong offset!");

// Class AJB.AJBPrimaryEmote
// 0x0018 (0x0050 - 0x0038)
class UAJBPrimaryEmote final : public UAJBPrimaryDataAsset
{
public:
	int32                                         emoteId;                                           // 0x0038(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           EmoteAnimMontage;                                  // 0x0040(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTexture*                               EmoteIconTexture;                                  // 0x0048(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPrimaryEmote">();
	}
	static class UAJBPrimaryEmote* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPrimaryEmote>();
	}
};
static_assert(alignof(UAJBPrimaryEmote) == 0x000008, "Wrong alignment on UAJBPrimaryEmote");
static_assert(sizeof(UAJBPrimaryEmote) == 0x000050, "Wrong size on UAJBPrimaryEmote");
static_assert(offsetof(UAJBPrimaryEmote, emoteId) == 0x000038, "Member 'UAJBPrimaryEmote::emoteId' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryEmote, EmoteAnimMontage) == 0x000040, "Member 'UAJBPrimaryEmote::EmoteAnimMontage' has a wrong offset!");
static_assert(offsetof(UAJBPrimaryEmote, EmoteIconTexture) == 0x000048, "Member 'UAJBPrimaryEmote::EmoteIconTexture' has a wrong offset!");

// Class AJB.AJBPrimaryCharacterClass
// 0x0050 (0x0088 - 0x0038)
class UAJBPrimaryCharacterClass final : public UAJBPrimaryDataAsset
{
public:
	TMap<struct FGameplayTag, TSubclassOf<class AAJBInGameCharacter>> AJBInGameCharacterClasses;     // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, UObjectWrapper, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPrimaryCharacterClass">();
	}
	static class UAJBPrimaryCharacterClass* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPrimaryCharacterClass>();
	}
};
static_assert(alignof(UAJBPrimaryCharacterClass) == 0x000008, "Wrong alignment on UAJBPrimaryCharacterClass");
static_assert(sizeof(UAJBPrimaryCharacterClass) == 0x000088, "Wrong size on UAJBPrimaryCharacterClass");
static_assert(offsetof(UAJBPrimaryCharacterClass, AJBInGameCharacterClasses) == 0x000038, "Member 'UAJBPrimaryCharacterClass::AJBInGameCharacterClasses' has a wrong offset!");

// Class AJB.AJBPrimaryRewardPlayerIconID
// 0x0050 (0x0088 - 0x0038)
class UAJBPrimaryRewardPlayerIconID final : public UAJBPrimaryDataAsset
{
public:
	TMap<int32, int32>                            PlayerIconIDMap;                                   // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPrimaryRewardPlayerIconID">();
	}
	static class UAJBPrimaryRewardPlayerIconID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPrimaryRewardPlayerIconID>();
	}
};
static_assert(alignof(UAJBPrimaryRewardPlayerIconID) == 0x000008, "Wrong alignment on UAJBPrimaryRewardPlayerIconID");
static_assert(sizeof(UAJBPrimaryRewardPlayerIconID) == 0x000088, "Wrong size on UAJBPrimaryRewardPlayerIconID");
static_assert(offsetof(UAJBPrimaryRewardPlayerIconID, PlayerIconIDMap) == 0x000038, "Member 'UAJBPrimaryRewardPlayerIconID::PlayerIconIDMap' has a wrong offset!");

// Class AJB.AJBPrimaryRewardStandSkinID
// 0x0050 (0x0088 - 0x0038)
class UAJBPrimaryRewardStandSkinID final : public UAJBPrimaryDataAsset
{
public:
	TMap<int32, struct FAJBRewardIconInfoList>    RewardIconInfo;                                    // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPrimaryRewardStandSkinID">();
	}
	static class UAJBPrimaryRewardStandSkinID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPrimaryRewardStandSkinID>();
	}
};
static_assert(alignof(UAJBPrimaryRewardStandSkinID) == 0x000008, "Wrong alignment on UAJBPrimaryRewardStandSkinID");
static_assert(sizeof(UAJBPrimaryRewardStandSkinID) == 0x000088, "Wrong size on UAJBPrimaryRewardStandSkinID");
static_assert(offsetof(UAJBPrimaryRewardStandSkinID, RewardIconInfo) == 0x000038, "Member 'UAJBPrimaryRewardStandSkinID::RewardIconInfo' has a wrong offset!");

// Class AJB.AJBPrimaryRewardCharaSkinID
// 0x0050 (0x0088 - 0x0038)
class UAJBPrimaryRewardCharaSkinID final : public UAJBPrimaryDataAsset
{
public:
	TMap<int32, struct FAJBRewardIconInfoList>    RewardIconInfo;                                    // 0x0038(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBPrimaryRewardCharaSkinID">();
	}
	static class UAJBPrimaryRewardCharaSkinID* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBPrimaryRewardCharaSkinID>();
	}
};
static_assert(alignof(UAJBPrimaryRewardCharaSkinID) == 0x000008, "Wrong alignment on UAJBPrimaryRewardCharaSkinID");
static_assert(sizeof(UAJBPrimaryRewardCharaSkinID) == 0x000088, "Wrong size on UAJBPrimaryRewardCharaSkinID");
static_assert(offsetof(UAJBPrimaryRewardCharaSkinID, RewardIconInfo) == 0x000038, "Member 'UAJBPrimaryRewardCharaSkinID::RewardIconInfo' has a wrong offset!");

// Class AJB.AJBRetainerBox
// 0x0000 (0x0148 - 0x0148)
class UAJBRetainerBox final : public URetainerBox
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBRetainerBox">();
	}
	static class UAJBRetainerBox* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBRetainerBox>();
	}
};
static_assert(alignof(UAJBRetainerBox) == 0x000008, "Wrong alignment on UAJBRetainerBox");
static_assert(sizeof(UAJBRetainerBox) == 0x000148, "Wrong size on UAJBRetainerBox");

// Class AJB.AJBSettings
// 0x01B0 (0x01D8 - 0x0028)
class UAJBSettings final : public UObject
{
public:
	TMap<EAJBFontSizeType, int32>                 FontSizeMap;                                       // 0x0028(0x0050)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	int32                                         DifficultyMaxNum;                                  // 0x0078(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ChangeColorLivingPlayerCount;                      // 0x007C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseFadeInTime;                                    // 0x0080(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         BaseFadeOutTime;                                   // 0x0084(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   MenuBGLevelName;                                   // 0x0088(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePlayerIconRelativePath;                     // 0x0090(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x7];                                       // 0x0091(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 PlayerIconDistributionPath;                        // 0x0098(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerIconEditorPath;                              // 0x00A8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerIconDevelopPath;                             // 0x00B8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerIconCabinetPath;                             // 0x00C8(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SettingNPCMinNum;                                  // 0x00D8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGameStartFadeInTime;                             // 0x00DC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         InGameStartFadeOutTime;                            // 0x00E0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableReplaySystem;                               // 0x00E4(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bCreateUniqueReplayData;                           // 0x00E5(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bDebugForceFullReplay;                             // 0x00E6(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAllowCreateMovieBlocking;                         // 0x00E7(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighlightVersion;                                  // 0x00E8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         MinReplayRecordHz;                                 // 0x00EC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLoadOperationParameter;                     // 0x00F0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCheckOperationParameterVersion;             // 0x00F1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_F2[0x2];                                       // 0x00F2(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DefaultAddCredit;                                  // 0x00F4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableDebugDisplay;                               // 0x00F8(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForLocationTest;                                // 0x00F9(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForNegotiations;                                // 0x00FA(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsForElectricalTest;                              // 0x00FB(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsHWSignatureAuth;                                // 0x00FC(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnableAMActivation;                             // 0x00FD(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_FE[0x2];                                       // 0x00FE(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 NetErrorComebackMap;                               // 0x0100(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EMoneyPrice;                                       // 0x0110(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseDebugClosedArcadeTimeSchedule;                 // 0x0114(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAJBDevCloseTimeInfo>           DevCloseTimes;                                     // 0x0118(0x0010)(Edit, ZeroConstructor, Config, NativeAccessSpecifierPublic)
	bool                                          bEnableSkinCustomDebug;                            // 0x0128(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_129[0x3];                                      // 0x0129(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AutoPlayTestMode;                                  // 0x012C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MUCHAServerLocalIP;                                // 0x0130(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 NetworkInterfaceName;                              // 0x0140(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ContentRouterGatewayIP;                            // 0x0150(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         DedicatedServerOnlineBeaconPortOffset;             // 0x0160(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEMoneyBrandTest;                            // 0x0164(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bForceDevelopEMoneyServer;                         // 0x0165(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnablePromotionMode;                              // 0x0166(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_167[0x1];                                      // 0x0167(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardPercentURL;                                  // 0x0168(0x0010)(Edit, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoystickPlayLow;                                   // 0x0178(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoystickPlayHigh;                                  // 0x017C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoystickRightPlayHighInGame;                       // 0x0180(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         JoystickLeftPlayHighInGame;                        // 0x0184(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseYButtonAsVictoryShot;                          // 0x0188(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_189[0x3];                                      // 0x0189(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         VictoryShotComporess;                              // 0x018C(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableInputCountForDev;                           // 0x0190(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_191[0x7];                                      // 0x0191(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   StartUpNextLevel;                                  // 0x0198(0x0008)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScreenShotMaxUploadSpeed;                          // 0x01A0(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighlightMaxUploadSpeed;                           // 0x01A4(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         HighlightDataSize;                                 // 0x01A8(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         HighlightUploadCheckInterval;                      // 0x01AC(0x0004)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShowShopSupportWebSiteInfo;                       // 0x01B0(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableAllCharacters;                           // 0x01B1(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableAllStages;                               // 0x01B2(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisabledDamageDisplay;                          // 0x01B3(0x0001)(Edit, ZeroConstructor, Config, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1B4[0x4];                                      // 0x01B4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  DebugTags;                                         // 0x01B8(0x0020)(Edit, Config, NativeAccessSpecifierPublic)

public:
	static void AppendDebugTags(const struct FGameplayTagContainer& TagContainerIn);
	static bool GetAllowCreateMovieBlocking();
	static int32 GetAutoPlayTestMode();
	static bool GetAvailableAllCharacters();
	static bool GetAvailableAllStages();
	static int32 GetChangeColorLivingPlayerCount();
	static class FString GetContentRouterGatewayIP();
	static struct FGameplayTagContainer GetDebugTags();
	static int32 GetDefaultCredit();
	static int32 GetDifficultyMaxNum();
	static int32 GetEMoneyPrice();
	static bool GetEnableCheckOperationParameterVersion();
	static bool GetEnableLoadOperationParameter();
	static bool GetEnableSkinCustomDebug();
	static int32 GetHighlightVersion();
	static float GetInGameStartFadeInTime();
	static float GetInGameStartFadeOutTime();
	static float GetJoystickLeftPlayHighInGame();
	static float GetJoystickRightPlayHighInGame();
	static class FName GetMenuBGLevelName();
	static class FString GetMUCHAServerLocalIP();
	static class FString GetNetErrorComebackMap();
	static class FString GetPlayerIconCabinetPath();
	static class FString GetPlayerIconDevelopPath();
	static class FString GetPlayerIconDistributionPath();
	static class FString GetPlayerIconEditorPath();
	static class FString GetRewardPercentURL();
	static int32 GetSettingNPCMinNum();
	static class FName GetStartUpNextLevelName();
	static bool GetUseYButtonAsVictoryShot();
	static bool IsDisabledDamageDisplay();
	static bool IsEnableAMActivation();
	static bool IsEnableDebugDisplay();
	static bool IsEnableEMoneyBrandTest();
	static bool IsEnableInputCountForDev();
	static bool IsEnablePlayerIconRelativePath();
	static bool IsEnablePromotionMode();
	static bool IsForElectricalTest();
	static bool IsForLocationTest();
	static bool IsForNegotiations();
	static bool IsHWSignatureAuth();
	static bool IsShowShopSupportWebSiteInfo();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBSettings">();
	}
	static class UAJBSettings* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBSettings>();
	}
};
static_assert(alignof(UAJBSettings) == 0x000008, "Wrong alignment on UAJBSettings");
static_assert(sizeof(UAJBSettings) == 0x0001D8, "Wrong size on UAJBSettings");
static_assert(offsetof(UAJBSettings, FontSizeMap) == 0x000028, "Member 'UAJBSettings::FontSizeMap' has a wrong offset!");
static_assert(offsetof(UAJBSettings, DifficultyMaxNum) == 0x000078, "Member 'UAJBSettings::DifficultyMaxNum' has a wrong offset!");
static_assert(offsetof(UAJBSettings, ChangeColorLivingPlayerCount) == 0x00007C, "Member 'UAJBSettings::ChangeColorLivingPlayerCount' has a wrong offset!");
static_assert(offsetof(UAJBSettings, BaseFadeInTime) == 0x000080, "Member 'UAJBSettings::BaseFadeInTime' has a wrong offset!");
static_assert(offsetof(UAJBSettings, BaseFadeOutTime) == 0x000084, "Member 'UAJBSettings::BaseFadeOutTime' has a wrong offset!");
static_assert(offsetof(UAJBSettings, MenuBGLevelName) == 0x000088, "Member 'UAJBSettings::MenuBGLevelName' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnablePlayerIconRelativePath) == 0x000090, "Member 'UAJBSettings::bEnablePlayerIconRelativePath' has a wrong offset!");
static_assert(offsetof(UAJBSettings, PlayerIconDistributionPath) == 0x000098, "Member 'UAJBSettings::PlayerIconDistributionPath' has a wrong offset!");
static_assert(offsetof(UAJBSettings, PlayerIconEditorPath) == 0x0000A8, "Member 'UAJBSettings::PlayerIconEditorPath' has a wrong offset!");
static_assert(offsetof(UAJBSettings, PlayerIconDevelopPath) == 0x0000B8, "Member 'UAJBSettings::PlayerIconDevelopPath' has a wrong offset!");
static_assert(offsetof(UAJBSettings, PlayerIconCabinetPath) == 0x0000C8, "Member 'UAJBSettings::PlayerIconCabinetPath' has a wrong offset!");
static_assert(offsetof(UAJBSettings, SettingNPCMinNum) == 0x0000D8, "Member 'UAJBSettings::SettingNPCMinNum' has a wrong offset!");
static_assert(offsetof(UAJBSettings, InGameStartFadeInTime) == 0x0000DC, "Member 'UAJBSettings::InGameStartFadeInTime' has a wrong offset!");
static_assert(offsetof(UAJBSettings, InGameStartFadeOutTime) == 0x0000E0, "Member 'UAJBSettings::InGameStartFadeOutTime' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnableReplaySystem) == 0x0000E4, "Member 'UAJBSettings::bEnableReplaySystem' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bCreateUniqueReplayData) == 0x0000E5, "Member 'UAJBSettings::bCreateUniqueReplayData' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bDebugForceFullReplay) == 0x0000E6, "Member 'UAJBSettings::bDebugForceFullReplay' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bAllowCreateMovieBlocking) == 0x0000E7, "Member 'UAJBSettings::bAllowCreateMovieBlocking' has a wrong offset!");
static_assert(offsetof(UAJBSettings, HighlightVersion) == 0x0000E8, "Member 'UAJBSettings::HighlightVersion' has a wrong offset!");
static_assert(offsetof(UAJBSettings, MinReplayRecordHz) == 0x0000EC, "Member 'UAJBSettings::MinReplayRecordHz' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnableLoadOperationParameter) == 0x0000F0, "Member 'UAJBSettings::bEnableLoadOperationParameter' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnableCheckOperationParameterVersion) == 0x0000F1, "Member 'UAJBSettings::bEnableCheckOperationParameterVersion' has a wrong offset!");
static_assert(offsetof(UAJBSettings, DefaultAddCredit) == 0x0000F4, "Member 'UAJBSettings::DefaultAddCredit' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnableDebugDisplay) == 0x0000F8, "Member 'UAJBSettings::bEnableDebugDisplay' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bIsForLocationTest) == 0x0000F9, "Member 'UAJBSettings::bIsForLocationTest' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bIsForNegotiations) == 0x0000FA, "Member 'UAJBSettings::bIsForNegotiations' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bIsForElectricalTest) == 0x0000FB, "Member 'UAJBSettings::bIsForElectricalTest' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bIsHWSignatureAuth) == 0x0000FC, "Member 'UAJBSettings::bIsHWSignatureAuth' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bIsEnableAMActivation) == 0x0000FD, "Member 'UAJBSettings::bIsEnableAMActivation' has a wrong offset!");
static_assert(offsetof(UAJBSettings, NetErrorComebackMap) == 0x000100, "Member 'UAJBSettings::NetErrorComebackMap' has a wrong offset!");
static_assert(offsetof(UAJBSettings, EMoneyPrice) == 0x000110, "Member 'UAJBSettings::EMoneyPrice' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bUseDebugClosedArcadeTimeSchedule) == 0x000114, "Member 'UAJBSettings::bUseDebugClosedArcadeTimeSchedule' has a wrong offset!");
static_assert(offsetof(UAJBSettings, DevCloseTimes) == 0x000118, "Member 'UAJBSettings::DevCloseTimes' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnableSkinCustomDebug) == 0x000128, "Member 'UAJBSettings::bEnableSkinCustomDebug' has a wrong offset!");
static_assert(offsetof(UAJBSettings, AutoPlayTestMode) == 0x00012C, "Member 'UAJBSettings::AutoPlayTestMode' has a wrong offset!");
static_assert(offsetof(UAJBSettings, MUCHAServerLocalIP) == 0x000130, "Member 'UAJBSettings::MUCHAServerLocalIP' has a wrong offset!");
static_assert(offsetof(UAJBSettings, NetworkInterfaceName) == 0x000140, "Member 'UAJBSettings::NetworkInterfaceName' has a wrong offset!");
static_assert(offsetof(UAJBSettings, ContentRouterGatewayIP) == 0x000150, "Member 'UAJBSettings::ContentRouterGatewayIP' has a wrong offset!");
static_assert(offsetof(UAJBSettings, DedicatedServerOnlineBeaconPortOffset) == 0x000160, "Member 'UAJBSettings::DedicatedServerOnlineBeaconPortOffset' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnableEMoneyBrandTest) == 0x000164, "Member 'UAJBSettings::bEnableEMoneyBrandTest' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bForceDevelopEMoneyServer) == 0x000165, "Member 'UAJBSettings::bForceDevelopEMoneyServer' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnablePromotionMode) == 0x000166, "Member 'UAJBSettings::bEnablePromotionMode' has a wrong offset!");
static_assert(offsetof(UAJBSettings, RewardPercentURL) == 0x000168, "Member 'UAJBSettings::RewardPercentURL' has a wrong offset!");
static_assert(offsetof(UAJBSettings, JoystickPlayLow) == 0x000178, "Member 'UAJBSettings::JoystickPlayLow' has a wrong offset!");
static_assert(offsetof(UAJBSettings, JoystickPlayHigh) == 0x00017C, "Member 'UAJBSettings::JoystickPlayHigh' has a wrong offset!");
static_assert(offsetof(UAJBSettings, JoystickRightPlayHighInGame) == 0x000180, "Member 'UAJBSettings::JoystickRightPlayHighInGame' has a wrong offset!");
static_assert(offsetof(UAJBSettings, JoystickLeftPlayHighInGame) == 0x000184, "Member 'UAJBSettings::JoystickLeftPlayHighInGame' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bUseYButtonAsVictoryShot) == 0x000188, "Member 'UAJBSettings::bUseYButtonAsVictoryShot' has a wrong offset!");
static_assert(offsetof(UAJBSettings, VictoryShotComporess) == 0x00018C, "Member 'UAJBSettings::VictoryShotComporess' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bEnableInputCountForDev) == 0x000190, "Member 'UAJBSettings::bEnableInputCountForDev' has a wrong offset!");
static_assert(offsetof(UAJBSettings, StartUpNextLevel) == 0x000198, "Member 'UAJBSettings::StartUpNextLevel' has a wrong offset!");
static_assert(offsetof(UAJBSettings, ScreenShotMaxUploadSpeed) == 0x0001A0, "Member 'UAJBSettings::ScreenShotMaxUploadSpeed' has a wrong offset!");
static_assert(offsetof(UAJBSettings, HighlightMaxUploadSpeed) == 0x0001A4, "Member 'UAJBSettings::HighlightMaxUploadSpeed' has a wrong offset!");
static_assert(offsetof(UAJBSettings, HighlightDataSize) == 0x0001A8, "Member 'UAJBSettings::HighlightDataSize' has a wrong offset!");
static_assert(offsetof(UAJBSettings, HighlightUploadCheckInterval) == 0x0001AC, "Member 'UAJBSettings::HighlightUploadCheckInterval' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bShowShopSupportWebSiteInfo) == 0x0001B0, "Member 'UAJBSettings::bShowShopSupportWebSiteInfo' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bAvailableAllCharacters) == 0x0001B1, "Member 'UAJBSettings::bAvailableAllCharacters' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bAvailableAllStages) == 0x0001B2, "Member 'UAJBSettings::bAvailableAllStages' has a wrong offset!");
static_assert(offsetof(UAJBSettings, bIsDisabledDamageDisplay) == 0x0001B3, "Member 'UAJBSettings::bIsDisabledDamageDisplay' has a wrong offset!");
static_assert(offsetof(UAJBSettings, DebugTags) == 0x0001B8, "Member 'UAJBSettings::DebugTags' has a wrong offset!");

// Class AJB.AJBSpringArmComponent
// 0x0000 (0x02C0 - 0x02C0)
class UAJBSpringArmComponent final : public USpringArmComponent
{
public:
	void InitializeLocation();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBSpringArmComponent">();
	}
	static class UAJBSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBSpringArmComponent>();
	}
};
static_assert(alignof(UAJBSpringArmComponent) == 0x000008, "Wrong alignment on UAJBSpringArmComponent");
static_assert(sizeof(UAJBSpringArmComponent) == 0x0002C0, "Wrong size on UAJBSpringArmComponent");

// Class AJB.AJBStaticMeshComponent
// 0x0000 (0x05F0 - 0x05F0)
class UAJBStaticMeshComponent final : public UStaticMeshComponent
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBStaticMeshComponent">();
	}
	static class UAJBStaticMeshComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBStaticMeshComponent>();
	}
};
static_assert(alignof(UAJBStaticMeshComponent) == 0x000008, "Wrong alignment on UAJBStaticMeshComponent");
static_assert(sizeof(UAJBStaticMeshComponent) == 0x0005F0, "Wrong size on UAJBStaticMeshComponent");

// Class AJB.AJBStringTableManagerComponent
// 0x0008 (0x00F8 - 0x00F0)
class UAJBStringTableManagerComponent : public UActorComponent
{
public:
	class UStringTable*                           StringTable;                                       // 0x00F0(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	void GetStringFromTable(const struct FGameplayTag& Tag, bool* bResult, class FString* String);
	void GetStringFromTableByKey(const class FString& Key, bool* bResult, class FString* String);

	class FName GetStringTablePath() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBStringTableManagerComponent">();
	}
	static class UAJBStringTableManagerComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBStringTableManagerComponent>();
	}
};
static_assert(alignof(UAJBStringTableManagerComponent) == 0x000008, "Wrong alignment on UAJBStringTableManagerComponent");
static_assert(sizeof(UAJBStringTableManagerComponent) == 0x0000F8, "Wrong size on UAJBStringTableManagerComponent");
static_assert(offsetof(UAJBStringTableManagerComponent, StringTable) == 0x0000F0, "Member 'UAJBStringTableManagerComponent::StringTable' has a wrong offset!");

// Class AJB.AJBSystemTestFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAJBSystemTestFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static void DoInfiniteLoop();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBSystemTestFunctionLibrary">();
	}
	static class UAJBSystemTestFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBSystemTestFunctionLibrary>();
	}
};
static_assert(alignof(UAJBSystemTestFunctionLibrary) == 0x000008, "Wrong alignment on UAJBSystemTestFunctionLibrary");
static_assert(sizeof(UAJBSystemTestFunctionLibrary) == 0x000028, "Wrong size on UAJBSystemTestFunctionLibrary");

// Class AJB.AJBTestModeGameMode
// 0x0000 (0x03C8 - 0x03C8)
class AAJBTestModeGameMode final : public AAJBGameModeBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBTestModeGameMode">();
	}
	static class AAJBTestModeGameMode* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBTestModeGameMode>();
	}
};
static_assert(alignof(AAJBTestModeGameMode) == 0x000008, "Wrong alignment on AAJBTestModeGameMode");
static_assert(sizeof(AAJBTestModeGameMode) == 0x0003C8, "Wrong size on AAJBTestModeGameMode");

// Class AJB.AJBTestModeHUD
// 0x0000 (0x0518 - 0x0518)
class AAJBTestModeHUD final : public AAJBHUDBase
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBTestModeHUD">();
	}
	static class AAJBTestModeHUD* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBTestModeHUD>();
	}
};
static_assert(alignof(AAJBTestModeHUD) == 0x000008, "Wrong alignment on AAJBTestModeHUD");
static_assert(sizeof(AAJBTestModeHUD) == 0x000518, "Wrong size on AAJBTestModeHUD");

// Class AJB.AJBTestModePlayerController
// 0x0040 (0x0738 - 0x06F8)
class AAJBTestModePlayerController final : public AAJBPlayerControllerBase
{
public:
	UMulticastDelegateProperty_                   OnEnter;                                           // 0x06F8(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnUp;                                              // 0x0708(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	UMulticastDelegateProperty_                   OnDown;                                            // 0x0718(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPrivate)
	uint8                                         Pad_728[0x10];                                     // 0x0728(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBTestModePlayerController">();
	}
	static class AAJBTestModePlayerController* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBTestModePlayerController>();
	}
};
static_assert(alignof(AAJBTestModePlayerController) == 0x000008, "Wrong alignment on AAJBTestModePlayerController");
static_assert(sizeof(AAJBTestModePlayerController) == 0x000738, "Wrong size on AAJBTestModePlayerController");
static_assert(offsetof(AAJBTestModePlayerController, OnEnter) == 0x0006F8, "Member 'AAJBTestModePlayerController::OnEnter' has a wrong offset!");
static_assert(offsetof(AAJBTestModePlayerController, OnUp) == 0x000708, "Member 'AAJBTestModePlayerController::OnUp' has a wrong offset!");
static_assert(offsetof(AAJBTestModePlayerController, OnDown) == 0x000718, "Member 'AAJBTestModePlayerController::OnDown' has a wrong offset!");

// Class AJB.AJBTextBlock
// 0x0008 (0x0218 - 0x0210)
class UAJBTextBlock final : public UTextBlock
{
public:
	EAJBFontSizeType                              FontSizeType;                                      // 0x0210(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_211[0x7];                                      // 0x0211(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBTextBlock">();
	}
	static class UAJBTextBlock* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBTextBlock>();
	}
};
static_assert(alignof(UAJBTextBlock) == 0x000008, "Wrong alignment on UAJBTextBlock");
static_assert(sizeof(UAJBTextBlock) == 0x000218, "Wrong size on UAJBTextBlock");
static_assert(offsetof(UAJBTextBlock, FontSizeType) == 0x000210, "Member 'UAJBTextBlock::FontSizeType' has a wrong offset!");

// Class AJB.AJBUtilityFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UAJBUtilityFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UActorComponent* AddComponentByClass(class AActor* Owner, class UClass* ComponentClass);
	static void ApplyExposureSettings(struct FPostProcessSettings& ApplyTarget, const struct FPostProcessSettings& ApplySrc);
	static bool CanAJBArcadeGamePlay(const class UObject* WorldContextObject);
	static void ChangeUSIOInputProperty_DeadZone(class APlayerController* PlayerController, float DeadZone);
	static void ChangeUSIOInputProperty_Exponent(class APlayerController* PlayerController, float Exponent);
	static void ChangeUSIOInputProperty_Invert(class APlayerController* PlayerController, bool bInvert);
	static void ChangeUSIOInputProperty_Sensitivity(class APlayerController* PlayerController, float Sensitivity);
	static bool CheckAnimationLoop(class UAnimationAsset* TargetAnimation);
	static bool CheckDefaultListener(class UAkComponent* in_pListener);
	static EAJBPadIconType ConvertAJBInGamePadIconKeyAction(const class UObject* WorldContextObject, EAJBPadIconType UIPadIconType);
	static class ULevelSequencePlayer* CreateAJBLevelSequencePlayer(class UObject* WorldContextObject, class ULevelSequence* LevelSequence, const struct FMovieSceneSequencePlaybackSettings& Settings, class AAJBLevelSequenceActor** OutActor);
	static void FindAJBViewportWidgetOfClass(const class UObject* WorldContextObject, TSubclassOf<class UAJBUserWidget> AJBWidgetClass, bool* bSuccess, class UAJBUserWidget** OutWidget);
	static void FindAJBViewportWidgetsOfClass(const class UObject* WorldContextObject, TSubclassOf<class UAJBUserWidget> AJBWidgetClass, bool* bSuccess, TArray<class UAJBUserWidget*>* OutWidgets);
	static void ForceStreamOutTextures();
	static void ForceUpdateOverlaps(class USceneComponent* Component);
	static int32 GetAJBArcadeLimitAdditionalCredit(const class UObject* WorldContextObject);
	static int32 GetAJBArcadeLimitNumPossessionPP(const class UObject* WorldContextObject);
	static class UAJBArcadeTimeManager* GetAJBArcadeTimeManager(const class UObject* WorldContextObject, bool* bIsValid);
	static void GetAJBCharacterInfoList(const class UObject* WorldContextObject, TArray<struct FAJBCharacterInfo>* OutCharacterInfoList);
	static class AAJBInGameCharacter* GetAJBControlledInGameCharacter(const class AController* Controller, bool* bIsValid);
	static float GetAJBDefaultGravityZ();
	static class UAJBGameInstance* GetAJBGameInstanceFromWorldContextObjectChecked(const class UObject* WorldContextObject);
	static class UAJBHighlightManager* GetAJBHighlightManager(const class UObject* WorldContextObject, bool* bIsValid);
	static class AAJBInGamePlayerController* GetAJBHighlightOnlyInGamePlayerController(const class UObject* WorldContextObject, bool* bIsValid);
	static class UAJBGameDataStorageManager* GetAJBInGameDataStorageManager(const class UObject* WorldContextObject, bool* bIsValid);
	static class AAJBInGameGameState* GetAJBInGameGameState(const class UObject* WorldContextObject, bool* bIsValid);
	static class AAJBInGameHUD* GetAJBInGameHUD(const class UObject* WorldContextObject, bool* bIsValid, int32 PlayerIndex);
	static EAJBPadIconType GetAJBInGamePadIconByKeyAction(const class UObject* WorldContextObject, class FName KeyActionName);
	static class AAJBInGamePlayerController* GetAJBInGamePlayerController(const class UObject* WorldContextObject, bool* bIsValid);
	static int32 GetAJBLimitCoinNumber();
	static int32 GetAJBMaxBuyPP(const class UObject* WorldContextObject);
	static void GetAllActorsByLevelName(const class UObject* WorldContextObject, class FName LevelName, TSubclassOf<class AActor> ActorClass, TArray<class AActor*>* OutActors);
	static bool GetCharacterInfoByCharaIndex(const class UObject* WorldContextObject, int32 Index_0, struct FAJBCharacterInfo* Out);
	static bool GetCharacterInfoByCharaTag(const class UObject* WorldContextObject, const struct FGameplayTag& Tag, struct FAJBCharacterInfo* Out);
	static float GetConnectionTimeout(const class UObject* WorldContextObject);
	static EAJBDayOfWeek GetDayOfWeek(const struct FDateTime& Date);
	static void GetInGameEffectPoolManagers(const class UObject* WorldContextObject, TSubclassOf<class AAJBInGameEffectPoolManager> EffectPoolManagerClass, TArray<class AAJBInGameEffectPoolManager*>* OutEffectPoolManagers);
	static float GetInitialConnectTimeout(const class UObject* WorldContextObject);
	static void GetJoinPawns(class UObject* WorldContextObject, TSubclassOf<class APawn> PawnClass, TArray<class APawn*>* OutPawns);
	static void GetJoinPlayerControllers(class UObject* WorldContextObject, TArray<class APlayerController*>* OutPlayerControllers);
	static void GetNPCAJBCharacterInfoList(const class UObject* WorldContextObject, TArray<struct FAJBCharacterInfo>* OutCharacterInfoList);
	static int32 GetStageIdFromLevelName(const class UObject* WorldContextObject);
	static bool HasGameplayTagFromStaticMesh(class UStaticMesh* TargetStaticMesh, const struct FGameplayTag& TagToCheck, bool bExactMatch);
	static bool IsAJBArcadeTerminateGame(const class UObject* WorldContextObject);
	static bool IsAJBOfflineMode(class UObject* WorldContextObject);
	static bool IsCommandlet();
	static bool IsDistribution();
	static bool IsEditor();
	static bool IsEditorPreview(const class UObject* WorldContextObject);
	static bool IsEnableGachaSchedule(const class UObject* WorldContextObject);
	static bool IsShipping();
	static bool IsSphereInBox(const struct FVector& SphereLocation, float SphereRadius, const struct FVector& BoxLocation, const struct FRotator& BoxRotation, const struct FVector& BoxExtent);
	static bool IsStandalone();
	static bool IsTestBuild();
	static class UTexture2D* LoadTexture2DFromDisk(const class FString& FullFilePath, const class FString& Filename, EAJBImageFormatType ImageFormat, bool* bOutValid, int32* OutWidth, int32* OutHeight);
	static bool MakeGameplayTagByName(const class FString& TagName, bool ErrorIfNotFound, struct FGameplayTag* OutTag);
	static class UObject* NewObjectFromBlueprint(class UObject* WorldContextObject, class UClass* InClass);
	static void ParseStringToDateTime(struct FDateTime* OutDateTime, const class FString& InDateTimeString);
	static void ParseStringToScheduleDateTime(struct FDateTime* OutDateTime, const class FString& InDateTimeString);
	static void Screenshot(const class FString& InFilename, bool bInShowUI);
	static void SetAJBArcadeGameCoinLock(const class UObject* WorldContextObject, bool bLock);
	static void SetAllowCullDistanceVolume(class UPrimitiveComponent* Component, bool bAllow);
	static void SetConnectionTimeout(const class UObject* WorldContextObject, float NewTimeSec);
	static void SetInitialConnectTimeout(const class UObject* WorldContextObject, float NewTimeSec);
	static void SwitchPlayerKind_Impl(const class AActor* Target, const class AActor* ViewingActor, EAJBSwitchPlayerKindOutPin* OutBranches);
	static class AActor* TryGetOwnerOfClass(class AActor* InActor, class UClass* InClass);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBUtilityFunctionLibrary">();
	}
	static class UAJBUtilityFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBUtilityFunctionLibrary>();
	}
};
static_assert(alignof(UAJBUtilityFunctionLibrary) == 0x000008, "Wrong alignment on UAJBUtilityFunctionLibrary");
static_assert(sizeof(UAJBUtilityFunctionLibrary) == 0x000028, "Wrong size on UAJBUtilityFunctionLibrary");

// Class AJB.AJBVersion
// 0x0030 (0x0058 - 0x0028)
class UAJBVersion final : public UObject
{
public:
	class FString                                 BuildName;                                         // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VersionNumber;                                     // 0x0038(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BuildDate;                                         // 0x0048(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, Config, HasGetValueTypeHash, NativeAccessSpecifierPublic)

public:
	static class FString GetBuildDate();
	static class FString GetBuildName();
	static class FString GetVersionNumber();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBVersion">();
	}
	static class UAJBVersion* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBVersion>();
	}
};
static_assert(alignof(UAJBVersion) == 0x000008, "Wrong alignment on UAJBVersion");
static_assert(sizeof(UAJBVersion) == 0x000058, "Wrong size on UAJBVersion");
static_assert(offsetof(UAJBVersion, BuildName) == 0x000028, "Member 'UAJBVersion::BuildName' has a wrong offset!");
static_assert(offsetof(UAJBVersion, VersionNumber) == 0x000038, "Member 'UAJBVersion::VersionNumber' has a wrong offset!");
static_assert(offsetof(UAJBVersion, BuildDate) == 0x000048, "Member 'UAJBVersion::BuildDate' has a wrong offset!");

// Class AJB.AJBVideoRecorder
// 0x0168 (0x0490 - 0x0328)
class AAJBVideoRecorder final : public AActor
{
public:
	int32                                         VideoWidth;                                        // 0x0328(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VideoHeight;                                       // 0x032C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordingTimeInSecond;                             // 0x0330(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovieFadingTimeInSecond;                           // 0x0334(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RecordingFps;                                      // 0x0338(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         MovieQuality;                                      // 0x033C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSyncFrame;                                        // 0x0340(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_341[0x7];                                      // 0x0341(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 CodecName;                                         // 0x0348(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Filename;                                          // 0x0358(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         ThumbnailCaptureTime;                              // 0x0368(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_36C[0x4];                                      // 0x036C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStopCapture;                                     // 0x0370(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishedCreateMovie;                             // 0x0380(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnFinishedCreatingDummyMovieData;                  // 0x0390(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bIsInterrupted;                                    // 0x03A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3A1[0x1F];                                     // 0x03A1(0x001F)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         CapturedFrames;                                    // 0x03C0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	TArray<struct FColor>                         LastFrameData;                                     // 0x03D0(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	struct FAJBImageData                          LogoImageData;                                     // 0x03E0(0x0018)(NativeAccessSpecifierPrivate)
	struct FAJBImageData                          PostImageData;                                     // 0x03F8(0x0018)(NativeAccessSpecifierPrivate)
	uint8                                         Pad_410[0x20];                                     // 0x0410(0x0020)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 DuplicatedFrameNoList;                             // 0x0430(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_440[0x10];                                     // 0x0440(0x0010)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FColor>                         ThumbnailColorBuffer;                              // 0x0450(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	class UTexture2D*                             CaptureFrameTexture;                               // 0x0460(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ThumbnailWidth;                                    // 0x0468(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	int32                                         ThumbnailHeight;                                   // 0x046C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	class FString                                 TestModeTransitionHindranceName;                   // 0x0470(0x0010)(ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_480[0x10];                                     // 0x0480(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CreateDummyMovieData();
	void CreateThumbnailData();
	bool FinalizeAviWriter();
	float GetProgress();
	void GetThumbnailData(TArray<struct FColor>* Color, int32* Width, int32* Height, bool* Result);
	class UTexture2D* GetThumbnailTexture();
	void OnTryToTransitTestModeDuringCreatingMovie();
	void RequestCreatingMovieData();
	bool StartCapture();
	void StopCapture();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBVideoRecorder">();
	}
	static class AAJBVideoRecorder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBVideoRecorder>();
	}
};
static_assert(alignof(AAJBVideoRecorder) == 0x000008, "Wrong alignment on AAJBVideoRecorder");
static_assert(sizeof(AAJBVideoRecorder) == 0x000490, "Wrong size on AAJBVideoRecorder");
static_assert(offsetof(AAJBVideoRecorder, VideoWidth) == 0x000328, "Member 'AAJBVideoRecorder::VideoWidth' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, VideoHeight) == 0x00032C, "Member 'AAJBVideoRecorder::VideoHeight' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, RecordingTimeInSecond) == 0x000330, "Member 'AAJBVideoRecorder::RecordingTimeInSecond' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, MovieFadingTimeInSecond) == 0x000334, "Member 'AAJBVideoRecorder::MovieFadingTimeInSecond' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, RecordingFps) == 0x000338, "Member 'AAJBVideoRecorder::RecordingFps' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, MovieQuality) == 0x00033C, "Member 'AAJBVideoRecorder::MovieQuality' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, bSyncFrame) == 0x000340, "Member 'AAJBVideoRecorder::bSyncFrame' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, CodecName) == 0x000348, "Member 'AAJBVideoRecorder::CodecName' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, Filename) == 0x000358, "Member 'AAJBVideoRecorder::Filename' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, ThumbnailCaptureTime) == 0x000368, "Member 'AAJBVideoRecorder::ThumbnailCaptureTime' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, OnStopCapture) == 0x000370, "Member 'AAJBVideoRecorder::OnStopCapture' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, OnFinishedCreateMovie) == 0x000380, "Member 'AAJBVideoRecorder::OnFinishedCreateMovie' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, OnFinishedCreatingDummyMovieData) == 0x000390, "Member 'AAJBVideoRecorder::OnFinishedCreatingDummyMovieData' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, bIsInterrupted) == 0x0003A0, "Member 'AAJBVideoRecorder::bIsInterrupted' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, CapturedFrames) == 0x0003C0, "Member 'AAJBVideoRecorder::CapturedFrames' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, LastFrameData) == 0x0003D0, "Member 'AAJBVideoRecorder::LastFrameData' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, LogoImageData) == 0x0003E0, "Member 'AAJBVideoRecorder::LogoImageData' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, PostImageData) == 0x0003F8, "Member 'AAJBVideoRecorder::PostImageData' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, DuplicatedFrameNoList) == 0x000430, "Member 'AAJBVideoRecorder::DuplicatedFrameNoList' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, ThumbnailColorBuffer) == 0x000450, "Member 'AAJBVideoRecorder::ThumbnailColorBuffer' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, CaptureFrameTexture) == 0x000460, "Member 'AAJBVideoRecorder::CaptureFrameTexture' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, ThumbnailWidth) == 0x000468, "Member 'AAJBVideoRecorder::ThumbnailWidth' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, ThumbnailHeight) == 0x00046C, "Member 'AAJBVideoRecorder::ThumbnailHeight' has a wrong offset!");
static_assert(offsetof(AAJBVideoRecorder, TestModeTransitionHindranceName) == 0x000470, "Member 'AAJBVideoRecorder::TestModeTransitionHindranceName' has a wrong offset!");

// Class AJB.AJBWaterwaySoundManagerBase
// 0x0000 (0x0378 - 0x0378)
class AAJBWaterwaySoundManagerBase final : public AAJBInGame2DGeoManager
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBWaterwaySoundManagerBase">();
	}
	static class AAJBWaterwaySoundManagerBase* GetDefaultObj()
	{
		return GetDefaultObjImpl<AAJBWaterwaySoundManagerBase>();
	}
};
static_assert(alignof(AAJBWaterwaySoundManagerBase) == 0x000008, "Wrong alignment on AAJBWaterwaySoundManagerBase");
static_assert(sizeof(AAJBWaterwaySoundManagerBase) == 0x000378, "Wrong size on AAJBWaterwaySoundManagerBase");

// Class AJB.AJBWindowWidget
// 0x0078 (0x02C0 - 0x0248)
class UAJBWindowWidget : public UAJBUserWidget
{
public:
	UMulticastDelegateProperty_                   OnOpeningWindowDispatcher;                         // 0x0248(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnOpenedWindowDispatcher;                          // 0x0258(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClosingWindowDispatcher;                         // 0x0268(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnClosedWindowDispatcher;                          // 0x0278(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	bool                                          bDefaultCollapsedWindow;                           // 0x0288(0x0001)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBCreditDisplayType                         CreditDisplayType;                                 // 0x0289(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_28A[0x6];                                      // 0x028A(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class UAJBBackGroundWidget>       BackGroundWidgetClass;                             // 0x0290(0x0008)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UAJBBackGroundWidget*                   BackGroundWidget;                                  // 0x0298(0x0008)(BlueprintVisible, ExportObject, BlueprintReadOnly, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBUIWindowState                             WindowState;                                       // 0x02A0(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2A1[0x17];                                     // 0x02A1(0x0017)(Fixing Size After Last Property [ Dumper-7 ])
	bool                                          bErrorWindow;                                      // 0x02B8(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2B9[0x7];                                      // 0x02B9(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void CallClosedWindowEvent(bool bChangedCollapsedWindow);
	void CallOpenedWindowEvent();
	void CloseWindow();
	void CurveAnimationFinishDelegate(TDelegate<void()> Delegate, class UWidget* AnimWidget, int32 AnimSequence);
	bool IsPlayingCurveAnimation(class UWidget* AnimWidget, int32 AnimSequence);
	void OnClosingWindow();
	void OnOpeningWindow();
	void OpenWindow();
	void OverrideCreditDisplayType(EAJBCreditDisplayType Type);
	void OverrideErrorWindowFlag(bool bNewFlag);
	void PlayCurveAnimation(class UWidget* AnimWidget, int32 AnimSequence, bool bPlayingCheck, EUMGSequencePlayMode PlayMode, int32 NumLoopToPlay);
	void RegisterCurve_Angle(class UWidget* AnimWidget, class UCurveFloat* Curve, int32 AnimSequence);
	void RegisterCurve_Scale(class UWidget* AnimWidget, class UCurveBase* Curve, int32 AnimSequence);
	void RegisterCurve_Trans(class UWidget* AnimWidget, class UCurveVector* CurveVector, int32 AnimSequence);
	void RegisterCurve_TransX(class UWidget* AnimWidget, class UCurveFloat* Curve, int32 AnimSequence);
	void RegisterCurve_TransY(class UWidget* AnimWidget, class UCurveFloat* Curve, int32 AnimSequence);
	void StopCurveAnimation(class UWidget* AnimWidget, int32 AnimSequence);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBWindowWidget">();
	}
	static class UAJBWindowWidget* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBWindowWidget>();
	}
};
static_assert(alignof(UAJBWindowWidget) == 0x000008, "Wrong alignment on UAJBWindowWidget");
static_assert(sizeof(UAJBWindowWidget) == 0x0002C0, "Wrong size on UAJBWindowWidget");
static_assert(offsetof(UAJBWindowWidget, OnOpeningWindowDispatcher) == 0x000248, "Member 'UAJBWindowWidget::OnOpeningWindowDispatcher' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, OnOpenedWindowDispatcher) == 0x000258, "Member 'UAJBWindowWidget::OnOpenedWindowDispatcher' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, OnClosingWindowDispatcher) == 0x000268, "Member 'UAJBWindowWidget::OnClosingWindowDispatcher' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, OnClosedWindowDispatcher) == 0x000278, "Member 'UAJBWindowWidget::OnClosedWindowDispatcher' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, bDefaultCollapsedWindow) == 0x000288, "Member 'UAJBWindowWidget::bDefaultCollapsedWindow' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, CreditDisplayType) == 0x000289, "Member 'UAJBWindowWidget::CreditDisplayType' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, BackGroundWidgetClass) == 0x000290, "Member 'UAJBWindowWidget::BackGroundWidgetClass' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, BackGroundWidget) == 0x000298, "Member 'UAJBWindowWidget::BackGroundWidget' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, WindowState) == 0x0002A0, "Member 'UAJBWindowWidget::WindowState' has a wrong offset!");
static_assert(offsetof(UAJBWindowWidget, bErrorWindow) == 0x0002B8, "Member 'UAJBWindowWidget::bErrorWindow' has a wrong offset!");

// Class AJB.AJBWinPlatformUtils
// 0x0000 (0x0028 - 0x0028)
class UAJBWinPlatformUtils final : public UBlueprintFunctionLibrary
{
public:
	static bool IsConnectTouchPanel();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJBWinPlatformUtils">();
	}
	static class UAJBWinPlatformUtils* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJBWinPlatformUtils>();
	}
};
static_assert(alignof(UAJBWinPlatformUtils) == 0x000008, "Wrong alignment on UAJBWinPlatformUtils");
static_assert(sizeof(UAJBWinPlatformUtils) == 0x000028, "Wrong size on UAJBWinPlatformUtils");

// Class AJB.AJB_HighlightSpringArmComponent
// 0x0010 (0x02D0 - 0x02C0)
class UAJB_HighlightSpringArmComponent final : public USpringArmComponent
{
public:
	uint8                                         Pad_2C0[0x10];                                     // 0x02C0(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void SetTargetRotation(const struct FRotator& desireRot);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"AJB_HighlightSpringArmComponent">();
	}
	static class UAJB_HighlightSpringArmComponent* GetDefaultObj()
	{
		return GetDefaultObjImpl<UAJB_HighlightSpringArmComponent>();
	}
};
static_assert(alignof(UAJB_HighlightSpringArmComponent) == 0x000008, "Wrong alignment on UAJB_HighlightSpringArmComponent");
static_assert(sizeof(UAJB_HighlightSpringArmComponent) == 0x0002D0, "Wrong size on UAJB_HighlightSpringArmComponent");

// Class AJB.EventTagLocker
// 0x0018 (0x0340 - 0x0328)
class AEventTagLocker final : public AActor
{
public:
	struct FGameplayTag                           EventTag;                                          // 0x0328(0x0008)(Edit, BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AEventTagLockHolder*                    HolderRef;                                         // 0x0330(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	bool                                          IsRequesting;                                      // 0x0338(0x0001)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPrivate)
	uint8                                         Pad_339[0x7];                                      // 0x0339(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void RequestLockWithTag(const struct FGameplayTag& EventTagIn);
	void RequestUnlock();
	void SetHolder(class AEventTagLockHolder* HolderRefIn);

	bool IsEventTagLocked() const;
	bool IsLockRequesting() const;
	bool IsValid() const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTagLocker">();
	}
	static class AEventTagLocker* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventTagLocker>();
	}
};
static_assert(alignof(AEventTagLocker) == 0x000008, "Wrong alignment on AEventTagLocker");
static_assert(sizeof(AEventTagLocker) == 0x000340, "Wrong size on AEventTagLocker");
static_assert(offsetof(AEventTagLocker, EventTag) == 0x000328, "Member 'AEventTagLocker::EventTag' has a wrong offset!");
static_assert(offsetof(AEventTagLocker, HolderRef) == 0x000330, "Member 'AEventTagLocker::HolderRef' has a wrong offset!");
static_assert(offsetof(AEventTagLocker, IsRequesting) == 0x000338, "Member 'AEventTagLocker::IsRequesting' has a wrong offset!");

// Class AJB.EventTagLockHolder
// 0x0070 (0x0398 - 0x0328)
class AEventTagLockHolder final : public AActor
{
public:
	UMulticastDelegateProperty_                   Locked;                                            // 0x0328(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   Unlocked;                                          // 0x0338(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	TMap<struct FGameplayTag, int32>              EventTagLockCounts;                                // 0x0348(0x0050)(ZeroConstructor, NativeAccessSpecifierPrivate)

public:
	struct FGameplayTagContainer GetLockedEventTags() const;
	bool IsLocked(const struct FGameplayTag& EventTag, bool bExactMatch) const;
	int32 LockedCount(const struct FGameplayTag& EventTag, bool bExactMatch) const;

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"EventTagLockHolder">();
	}
	static class AEventTagLockHolder* GetDefaultObj()
	{
		return GetDefaultObjImpl<AEventTagLockHolder>();
	}
};
static_assert(alignof(AEventTagLockHolder) == 0x000008, "Wrong alignment on AEventTagLockHolder");
static_assert(sizeof(AEventTagLockHolder) == 0x000398, "Wrong size on AEventTagLockHolder");
static_assert(offsetof(AEventTagLockHolder, Locked) == 0x000328, "Member 'AEventTagLockHolder::Locked' has a wrong offset!");
static_assert(offsetof(AEventTagLockHolder, Unlocked) == 0x000338, "Member 'AEventTagLockHolder::Unlocked' has a wrong offset!");
static_assert(offsetof(AEventTagLockHolder, EventTagLockCounts) == 0x000348, "Member 'AEventTagLockHolder::EventTagLockCounts' has a wrong offset!");

// Class AJB.FadeInActionProxy
// 0x0020 (0x0050 - 0x0030)
class UFadeInActionProxy final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   Finished;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFadeInActionProxy* FadeIn(class UObject* WorldContextObject, const float OverrideFadeTime);

	void OnEndFade(EAJBFadeType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeInActionProxy">();
	}
	static class UFadeInActionProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeInActionProxy>();
	}
};
static_assert(alignof(UFadeInActionProxy) == 0x000008, "Wrong alignment on UFadeInActionProxy");
static_assert(sizeof(UFadeInActionProxy) == 0x000050, "Wrong size on UFadeInActionProxy");
static_assert(offsetof(UFadeInActionProxy, Finished) == 0x000030, "Member 'UFadeInActionProxy::Finished' has a wrong offset!");

// Class AJB.FadeOutActionProxy
// 0x0020 (0x0050 - 0x0030)
class UFadeOutActionProxy final : public UBlueprintAsyncActionBase
{
public:
	UMulticastDelegateProperty_                   Finished;                                          // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	uint8                                         Pad_40[0x10];                                      // 0x0040(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UFadeOutActionProxy* FadeOut(class UObject* WorldContextObject, const float OverrideFadeTime);

	void OnEndFade(EAJBFadeType Type);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FadeOutActionProxy">();
	}
	static class UFadeOutActionProxy* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFadeOutActionProxy>();
	}
};
static_assert(alignof(UFadeOutActionProxy) == 0x000008, "Wrong alignment on UFadeOutActionProxy");
static_assert(sizeof(UFadeOutActionProxy) == 0x000050, "Wrong size on UFadeOutActionProxy");
static_assert(offsetof(UFadeOutActionProxy, Finished) == 0x000030, "Member 'UFadeOutActionProxy::Finished' has a wrong offset!");

// Class AJB.GetAssetDependenciesCommandlet
// 0x00B0 (0x0130 - 0x0080)
class UGetAssetDependenciesCommandlet final : public UCommandlet
{
public:
	uint8                                         Pad_80[0xB0];                                      // 0x0080(0x00B0)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"GetAssetDependenciesCommandlet">();
	}
	static class UGetAssetDependenciesCommandlet* GetDefaultObj()
	{
		return GetDefaultObjImpl<UGetAssetDependenciesCommandlet>();
	}
};
static_assert(alignof(UGetAssetDependenciesCommandlet) == 0x000008, "Wrong alignment on UGetAssetDependenciesCommandlet");
static_assert(sizeof(UGetAssetDependenciesCommandlet) == 0x000130, "Wrong size on UGetAssetDependenciesCommandlet");

// Class AJB.ImageUtilFunctionLibrary
// 0x0000 (0x0028 - 0x0028)
class UImageUtilFunctionLibrary final : public UBlueprintFunctionLibrary
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"ImageUtilFunctionLibrary">();
	}
	static class UImageUtilFunctionLibrary* GetDefaultObj()
	{
		return GetDefaultObjImpl<UImageUtilFunctionLibrary>();
	}
};
static_assert(alignof(UImageUtilFunctionLibrary) == 0x000008, "Wrong alignment on UImageUtilFunctionLibrary");
static_assert(sizeof(UImageUtilFunctionLibrary) == 0x000028, "Wrong size on UImageUtilFunctionLibrary");

// Class AJB.VictoryShotCapture
// 0x0030 (0x0358 - 0x0328)
class AVictoryShotCapture final : public AActor
{
public:
	int32                                         Width;                                             // 0x0328(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x032C(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class UTextureRenderTarget2D*                 RenderTarget;                                      // 0x0330(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         ColorBuffer;                                       // 0x0338(0x0010)(ZeroConstructor, NativeAccessSpecifierPrivate)
	uint8                                         Pad_348[0x10];                                     // 0x0348(0x0010)(Fixing Struct Size After Last Property [ Dumper-7 ])

public:
	void Capture();
	TArray<struct FColor> GetColorBuffer(int32* Width_0, int32* Height_0);
	void Init();

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"VictoryShotCapture">();
	}
	static class AVictoryShotCapture* GetDefaultObj()
	{
		return GetDefaultObjImpl<AVictoryShotCapture>();
	}
};
static_assert(alignof(AVictoryShotCapture) == 0x000008, "Wrong alignment on AVictoryShotCapture");
static_assert(sizeof(AVictoryShotCapture) == 0x000358, "Wrong size on AVictoryShotCapture");
static_assert(offsetof(AVictoryShotCapture, Width) == 0x000328, "Member 'AVictoryShotCapture::Width' has a wrong offset!");
static_assert(offsetof(AVictoryShotCapture, Height) == 0x00032C, "Member 'AVictoryShotCapture::Height' has a wrong offset!");
static_assert(offsetof(AVictoryShotCapture, RenderTarget) == 0x000330, "Member 'AVictoryShotCapture::RenderTarget' has a wrong offset!");
static_assert(offsetof(AVictoryShotCapture, ColorBuffer) == 0x000338, "Member 'AVictoryShotCapture::ColorBuffer' has a wrong offset!");

}

