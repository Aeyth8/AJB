#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBRecording

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "AJB_structs.hpp"
#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "BP_AJBComponentBase_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_AJBRecording.BP_AJBRecording_C
// 0x00F0 (0x01E0 - 0x00F0)
class UBP_AJBRecording_C final : public UBP_AJBComponentBase_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00F0(0x0008)(Transient, DuplicateTransient)
	TArray<class AAJBInGameCharacterBase*>        RecordingTargetList;                               // 0x00F8(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance)
	float                                         RecordTime;                                        // 0x0108(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         RecordLimit;                                       // 0x010C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<float>                                 RecordingLeftTimeList;                             // 0x0110(0x0010)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance)
	class UWB_RecordingMarkerWidget_C*            MarkerWidget;                                      // 0x0120(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UWB_RecordingReticleWidget_C*           ReticleWidget;                                     // 0x0128(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ShowRecordingUIDistance;                           // 0x0130(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_134[0x4];                                      // 0x0134(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AAJBInGameCharacterBase*                TargetCharacter;                                   // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                TargetLocation;                                    // 0x0140(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              CurrentPosition;                                   // 0x014C(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector2D                              TargetPosition;                                    // 0x0154(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ReticleInterpSpeed;                                // 0x015C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAutoHit;                                          // 0x0160(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_161[0x3];                                      // 0x0161(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         TargetSizeX;                                       // 0x0164(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         TargetSizeY;                                       // 0x0168(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_16C[0x4];                                      // 0x016C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           BeginAutoAimingSETag;                              // 0x0170(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           EndAutoAimingSETag;                                // 0x0178(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           ReticleSwitchedSETag;                              // 0x0180(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	TSoftObjectPtr<class AActor>                  AutoAimingTargetCache;                             // 0x0188(0x0028)(Edit, BlueprintVisible, DisableEditOnInstance, HasGetValueTypeHash)
	struct FTimerHandle                           TimerHandle_SyncAutoHitParam;                      // 0x01B0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor)
	bool                                          bDuringTimeStop;                                   // 0x01B8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bDebugShowAttackRange;                             // 0x01B9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_1BA[0x2];                                      // 0x01BA(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                AutoHitStartLocation;                              // 0x01BC(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                AutoHitEndLocation;                                // 0x01C8(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FVector                                AutoHitTargetStandLocation;                        // 0x01D4(0x000C)(Edit, BlueprintVisible, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

public:
	void ExecuteUbergraph_BP_AJBRecording(int32 EntryPoint);
	void MC_SyncAutoHitParam(class AAJBInGameCharacterBase* TargetCharacter_0, const struct FVector& TargetLocation_0);
	void ROS_SyncAutoHitParam(class AAJBInGameCharacterBase* TargetCharacter_0, const struct FVector& TargetLocation_0);
	void SyncAutoHitParam();
	void OnReticleSwitched();
	void OnEndAutoAiming();
	void OnBeginAutoAiming();
	void ReceiveBeginPlay();
	void ReceiveTick(float DeltaSeconds);
	void AddRecordingTargetServer(class ABP_AJBInGameCharacter_C* TargetCharacterBP);
	void NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty);
	void OnRelatedCharacterBecomeLastSurvivor();
	void RemoveTargetByIndex(int32 Index_0);
	void AddTargetByCharacterBase(class AAJBInGameCharacterBase* TargetCharacter_0);
	void UpdateLeftTime(float DeltaSeconds, TArray<int32>* RemoveIndexes);
	void TrySpawnRecordingEmphasizeActor();
	void GetMostNearestTarget(class AAJBInGameCharacterBase** TargetCharacter_0, struct FVector* TargetLocation_0);
	void CheckTarget2D(const struct FVector2D& Point, bool* bTarget);
	void TryChangeEnableMarker(bool bEnable, class AAJBInGameCharacterBase* TargetCharacter_0);
	void TryChangeEnableRecordingUI(bool bEnable);
	void CalcTargetList2D(TArray<class AAJBInGameCharacterBase*>& InList, TArray<struct FST_RecordingTargetInfo>* OutList);
	void GetDistanceMostNearestTarget(float* Distance);
	void CheckTargetExist(bool* bExist);
	void CalcTargetListAttackRange(TArray<class AAJBInGameCharacterBase*>& InList, TArray<class AAJBInGameCharacterBase*>* OutList);
	void CalcTargetMostNearestCameraLocation(TArray<class AAJBInGameCharacterBase*>& InList, TArray<struct FVector>& InLocationList, class AAJBInGameCharacterBase** TargetCharacter_0, struct FVector* TargetLocation_0);
	void CheckTargetInAttackRange(class AAJBInGameCharacterBase* TargetCharacter_0, bool* bInAttackRange);
	void RemoveTargets(class ABP_AJBInGameCharacter_C* TargetCharacterBP);
	void RemoveTargetByCharacterBP(class AAJBInGameCharacterBase* AJBCharacterBase);
	void TryAddTargets(class ABP_AJBInGameCharacter_C* TargetCharacterBP);
	void ChangeMarkerTarget(class AAJBInGameCharacterBase* TargetCharacter_0);
	void CheckTargetCondition(TArray<class AAJBInGameCharacterBase*>& InList, TArray<class AAJBInGameCharacterBase*>* OutList);
	void CheckRecordLimit(bool* bLimit);
	void RemoveMostOldestTargets();
	void CalcPosition(const struct FVector2D& InPosition, bool bOutOfScreen, struct FVector2D* OutPosition);
	void CalcTargetObstacle(TArray<struct FST_RecordingTargetInfo>& InList, TArray<class AAJBInGameCharacterBase*>* OutList, TArray<struct FVector>* OutLocationList);
	void TraceTarget(const struct FVector& StartLocation, const struct FVector& EndLocation, bool* bSuccess);
	void CheckRemoveTarget(TArray<int32>* RemoveIndexes);
	void ShouldRemoveTarget(class AAJBInGameCharacterBase* TargetCharacter_0, bool* bShouldRemove);
	void ShouldAllRemoveTarget(bool* bShouldRemove);
	void RemoveAllTarget();
	void ShouldDisplayRecordingUI(bool* bShouldDisplay);
	void ShouldEnableAutoAim(bool* bShoudEnable);
	void UpdateReticlePosition(float DeltaSeconds);
	void UpdateTargetInfo();
	void GetTargetLocations(class AAJBInGameCharacterBase* TargetCharacter_0, struct FVector* ActorLocation, struct FVector* HeadLocation);
	void InitAutoHitVariables();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_AJBRecording_C">();
	}
	static class UBP_AJBRecording_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_AJBRecording_C>();
	}
};
static_assert(alignof(UBP_AJBRecording_C) == 0x000008, "Wrong alignment on UBP_AJBRecording_C");
static_assert(sizeof(UBP_AJBRecording_C) == 0x0001E0, "Wrong size on UBP_AJBRecording_C");
static_assert(offsetof(UBP_AJBRecording_C, UberGraphFrame) == 0x0000F0, "Member 'UBP_AJBRecording_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, RecordingTargetList) == 0x0000F8, "Member 'UBP_AJBRecording_C::RecordingTargetList' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, RecordTime) == 0x000108, "Member 'UBP_AJBRecording_C::RecordTime' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, RecordLimit) == 0x00010C, "Member 'UBP_AJBRecording_C::RecordLimit' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, RecordingLeftTimeList) == 0x000110, "Member 'UBP_AJBRecording_C::RecordingLeftTimeList' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, MarkerWidget) == 0x000120, "Member 'UBP_AJBRecording_C::MarkerWidget' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, ReticleWidget) == 0x000128, "Member 'UBP_AJBRecording_C::ReticleWidget' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, ShowRecordingUIDistance) == 0x000130, "Member 'UBP_AJBRecording_C::ShowRecordingUIDistance' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, TargetCharacter) == 0x000138, "Member 'UBP_AJBRecording_C::TargetCharacter' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, TargetLocation) == 0x000140, "Member 'UBP_AJBRecording_C::TargetLocation' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, CurrentPosition) == 0x00014C, "Member 'UBP_AJBRecording_C::CurrentPosition' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, TargetPosition) == 0x000154, "Member 'UBP_AJBRecording_C::TargetPosition' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, ReticleInterpSpeed) == 0x00015C, "Member 'UBP_AJBRecording_C::ReticleInterpSpeed' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, bAutoHit) == 0x000160, "Member 'UBP_AJBRecording_C::bAutoHit' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, TargetSizeX) == 0x000164, "Member 'UBP_AJBRecording_C::TargetSizeX' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, TargetSizeY) == 0x000168, "Member 'UBP_AJBRecording_C::TargetSizeY' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, BeginAutoAimingSETag) == 0x000170, "Member 'UBP_AJBRecording_C::BeginAutoAimingSETag' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, EndAutoAimingSETag) == 0x000178, "Member 'UBP_AJBRecording_C::EndAutoAimingSETag' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, ReticleSwitchedSETag) == 0x000180, "Member 'UBP_AJBRecording_C::ReticleSwitchedSETag' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, AutoAimingTargetCache) == 0x000188, "Member 'UBP_AJBRecording_C::AutoAimingTargetCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, TimerHandle_SyncAutoHitParam) == 0x0001B0, "Member 'UBP_AJBRecording_C::TimerHandle_SyncAutoHitParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, bDuringTimeStop) == 0x0001B8, "Member 'UBP_AJBRecording_C::bDuringTimeStop' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, bDebugShowAttackRange) == 0x0001B9, "Member 'UBP_AJBRecording_C::bDebugShowAttackRange' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, AutoHitStartLocation) == 0x0001BC, "Member 'UBP_AJBRecording_C::AutoHitStartLocation' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, AutoHitEndLocation) == 0x0001C8, "Member 'UBP_AJBRecording_C::AutoHitEndLocation' has a wrong offset!");
static_assert(offsetof(UBP_AJBRecording_C, AutoHitTargetStandLocation) == 0x0001D4, "Member 'UBP_AJBRecording_C::AutoHitTargetStandLocation' has a wrong offset!");

}

