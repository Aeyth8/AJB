#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: FlowState

#include "Basic.hpp"

#include "CoreUObject_classes.hpp"
#include "Engine_classes.hpp"


namespace SDK
{

// Class FlowState.FlowStateInterface
// 0x0000 (0x0000 - 0x0000)
class IFlowStateInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowStateInterface">();
	}
	static class IFlowStateInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<IFlowStateInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IFlowStateInterface) == 0x000001, "Wrong alignment on IFlowStateInterface");
static_assert(sizeof(IFlowStateInterface) == 0x000001, "Wrong size on IFlowStateInterface");

// Class FlowState.FlowStateUtil
// 0x0000 (0x0028 - 0x0028)
class UFlowStateUtil final : public UBlueprintFunctionLibrary
{
public:
	static bool ChangeState(struct FFlowStateHandler& StateHandler, const struct FGameplayTag& NextStateTag);
	static class UStateObj* FindFlowState(const struct FFlowStateHandler& StateHandler, const struct FGameplayTag& NextStateTag);
	static void InitializeFlowState(struct FFlowStateHandler& InStateHandler);
	static void TickFlowState(struct FFlowStateHandler& StateHandler, float DeltaSconde);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"FlowStateUtil">();
	}
	static class UFlowStateUtil* GetDefaultObj()
	{
		return GetDefaultObjImpl<UFlowStateUtil>();
	}
};
static_assert(alignof(UFlowStateUtil) == 0x000008, "Wrong alignment on UFlowStateUtil");
static_assert(sizeof(UFlowStateUtil) == 0x000028, "Wrong size on UFlowStateUtil");

// Class FlowState.StateObj
// 0x0038 (0x0060 - 0x0028)
class UStateObj final : public UObject
{
public:
	bool                                          IsAutoTransition;                                  // 0x0028(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_29[0x7];                                       // 0x0029(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnBegin;                                           // 0x0030(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnTick;                                            // 0x0040(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)
	UMulticastDelegateProperty_                   OnEnd;                                             // 0x0050(0x0010)(ZeroConstructor, InstancedReference, BlueprintAssignable, NativeAccessSpecifierPublic)

public:
	void CallOnBegin(const struct FGameplayTag& PrevState);
	void CallOnEnd(const struct FGameplayTag& NextState);
	void CallOnTick(float DeltaSecond);

public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"StateObj">();
	}
	static class UStateObj* GetDefaultObj()
	{
		return GetDefaultObjImpl<UStateObj>();
	}
};
static_assert(alignof(UStateObj) == 0x000008, "Wrong alignment on UStateObj");
static_assert(sizeof(UStateObj) == 0x000060, "Wrong size on UStateObj");
static_assert(offsetof(UStateObj, IsAutoTransition) == 0x000028, "Member 'UStateObj::IsAutoTransition' has a wrong offset!");
static_assert(offsetof(UStateObj, OnBegin) == 0x000030, "Member 'UStateObj::OnBegin' has a wrong offset!");
static_assert(offsetof(UStateObj, OnTick) == 0x000040, "Member 'UStateObj::OnTick' has a wrong offset!");
static_assert(offsetof(UStateObj, OnEnd) == 0x000050, "Member 'UStateObj::OnEnd' has a wrong offset!");

// Class FlowState.TransitionInterface
// 0x0000 (0x0000 - 0x0000)
class ITransitionInterface final
{
public:
	static class UClass* StaticClass()
	{
		return StaticClassImpl<"TransitionInterface">();
	}
	static class ITransitionInterface* GetDefaultObj()
	{
		return GetDefaultObjImpl<ITransitionInterface>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(ITransitionInterface) == 0x000001, "Wrong alignment on ITransitionInterface");
static_assert(sizeof(ITransitionInterface) == 0x000001, "Wrong size on ITransitionInterface");

}

