#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BI_AJBInterface

#include "Basic.hpp"

#include "AJB_structs.hpp"
#include "CoreUObject_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BI_AJBInterface.BI_AJBInterface_C
// 0x0000 (0x0000 - 0x0000)
class IBI_AJBInterface_C final
{
public:
	void CheckTargetSelf(class AActor* DamageCauser, bool bForDamageOverlap, bool bIgnoreMovableStand, bool bIncludeSelf, bool bAfterReflectShouldHitOwner, bool* bTarget);
	void AJBDamage(class AActor* DamagedActor, int32 DamageForHPAP, int32 DamageForAAP, int32 CutDamage, const struct FGameplayTag& DamageType, int32 SerialNumber, EDamagePriority DamagePriority, float AttackDistance, class AActor* DamageCauser, bool WithSeparatedStandAttack, bool HitEnemysSeparatedStand, bool bPenetrateAP, bool bNotUseCollision, bool IsEndured, const struct FAJBDamageDisplayParams& DamageDisplayParams, const struct FAJBDamageDisplayProperty& DamageDisplayProperty);
	void OwnHitParam(bool* bCharacter, bool* bLeftAP, struct FGameplayTag* ParticleTagBlockedByAAP, struct FGameplayTag* SETagBlockedByAAP, struct FGameplayTag* ParticleTagBlocked);
	bool IfCheckDamageOverlap();
	void DamageOverlapped(class AActor* DamageCauser, const struct FVector& HitLocation, bool bPenetrating, const struct FGameplayTag& FactorTag, bool bInvalidDamage);
	void CheckDisableDamage(class AActor* DamageCauser, bool bIgnoreSelf, bool* bDisableDamage);
	void CheckDisablePassive(class AActor* PassiveCauser, const struct FGameplayTag& PassiveTag, bool bIgnoreSelf, bool* bDisablePassive);
	void CheckDisableAreaDamage(bool* bDisableAreadamage);
	void OnDamageDisabled();
	void OnPassiveDisabled();
	void OnAreaDamageDisabled();
	void CheckNoDamage(class AActor* DamageCauser, bool* bNoDamage);
	void IsReactedByReticule(bool* bResult);
	void IgnoreTrace(class AActor* Owner, bool bPairOnly, bool* bIgnore);
	void CheckDisableDirectDamage(class AActor* DamageCauser, bool* bDisableDirectDamage);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BI_AJBInterface_C">();
	}
	static class IBI_AJBInterface_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<IBI_AJBInterface_C>();
	}

	class UObject* AsUObject()
	{
		return reinterpret_cast<UObject*>(this);
	}
	const class UObject* AsUObject() const
	{
		return reinterpret_cast<const UObject*>(this);
	}
};
static_assert(alignof(IBI_AJBInterface_C) == 0x000001, "Wrong alignment on IBI_AJBInterface_C");
static_assert(sizeof(IBI_AJBInterface_C) == 0x000001, "Wrong size on IBI_AJBInterface_C");

}

