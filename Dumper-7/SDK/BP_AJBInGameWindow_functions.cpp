#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBInGameWindow

#include "Basic.hpp"

#include "BP_AJBInGameWindow_classes.hpp"
#include "BP_AJBInGameWindow_parameters.hpp"


namespace SDK
{

// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.ExecuteUbergraph_BP_AJBInGameWindow
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::ExecuteUbergraph_BP_AJBInGameWindow(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "ExecuteUbergraph_BP_AJBInGameWindow");

	Params::BP_AJBInGameWindow_C_ExecuteUbergraph_BP_AJBInGameWindow Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.ReceiveActorBeginOverlap
// (Event, Public, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::ReceiveActorBeginOverlap(class AActor* OtherActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "ReceiveActorBeginOverlap");

	Params::BP_AJBInGameWindow_C_ReceiveActorBeginOverlap Parms{};

	Parms.OtherActor = OtherActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.SpawnBreakEffectWithAttack
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Breaker                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::SpawnBreakEffectWithAttack(class ABP_AJBInGameCharacter_C* Breaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "SpawnBreakEffectWithAttack");

	Params::BP_AJBInGameWindow_C_SpawnBreakEffectWithAttack Parms{};

	Parms.Breaker = Breaker;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.BreakWindowOnAttack_OnAll
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Breaker                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::BreakWindowOnAttack_OnAll(class ABP_AJBInGameCharacter_C* Breaker)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "BreakWindowOnAttack_OnAll");

	Params::BP_AJBInGameWindow_C_BreakWindowOnAttack_OnAll Parms{};

	Parms.Breaker = Breaker;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.BreakWindowOnAttack_OnServer
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::BreakWindowOnAttack_OnServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "BreakWindowOnAttack_OnServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.ResetWindow
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::ResetWindow()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "ResetWindow");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.ResetWindowLocal
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::ResetWindowLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "ResetWindowLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnROSInteract
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ServerIsInteractingPlayer                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::OnROSInteract(class AActor* InteractingActor, bool ServerIsInteractingPlayer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnROSInteract");

	Params::BP_AJBInGameWindow_C_OnROSInteract Parms{};

	Parms.InteractingActor = InteractingActor;
	Parms.ServerIsInteractingPlayer = ServerIsInteractingPlayer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.BreakWindowLocal
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::BreakWindowLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "BreakWindowLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.NotifyToPassThruWindow
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::NotifyToPassThruWindow(class ABP_AJBInGameCharacter_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "NotifyToPassThruWindow");

	Params::BP_AJBInGameWindow_C_NotifyToPassThruWindow Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_AJBInGameWindow_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.NotifyTheWorld
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAJBInGameCharacter*              Operator                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGeneralTiming                          Timing                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bOperatorIsEmpty                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "NotifyTheWorld");

	Params::BP_AJBInGameWindow_C_NotifyTheWorld Parms{};

	Parms.Operator = Operator;
	Parms.Time = Time;
	Parms.Timing = Timing;
	Parms.bEnable = bEnable;
	Parms.bOperatorIsEmpty = bOperatorIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnInteractionBlocked
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::OnInteractionBlocked(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnInteractionBlocked");

	Params::BP_AJBInGameWindow_C_OnInteractionBlocked Parms{};

	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnSucceededLongPress_Local
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::OnSucceededLongPress_Local()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnSucceededLongPress_Local");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnInteract
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractActor                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::OnInteract(class AActor* InteractActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnInteract");

	Params::BP_AJBInGameWindow_C_OnInteract Parms{};

	Parms.InteractActor = InteractActor;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnAreaDamageDisabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::OnAreaDamageDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnAreaDamageDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnPassiveDisabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::OnPassiveDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnPassiveDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnDamageDisabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::OnDamageDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnDamageDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.DamageOverlapped
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPenetrating                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              FactorTag                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bInvalidDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::DamageOverlapped(class AActor* DamageCauser, const struct FVector& HitLocation, bool bPenetrating, const struct FGameplayTag& FactorTag, bool bInvalidDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "DamageOverlapped");

	Params::BP_AJBInGameWindow_C_DamageOverlapped Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.HitLocation = std::move(HitLocation);
	Parms.bPenetrating = bPenetrating;
	Parms.FactorTag = std::move(FactorTag);
	Parms.bInvalidDamage = bInvalidDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.AJBDamage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageForHPAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageForAAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CutDamage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamagePriority                         DamagePriority                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AttackDistance                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    WithSeparatedStandAttack                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    HitEnemysSeparatedStand                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrateAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bNotUseCollision                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsEndured                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FAJBDamageDisplayParams&   DamageDisplayParams                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FAJBDamageDisplayProperty& DamageDisplayProperty                                  (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::AJBDamage(class AActor* DamagedActor, int32 DamageForHPAP, int32 DamageForAAP, int32 CutDamage, const struct FGameplayTag& DamageType, int32 SerialNumber, EDamagePriority DamagePriority, float AttackDistance, class AActor* DamageCauser, bool WithSeparatedStandAttack, bool HitEnemysSeparatedStand, bool bPenetrateAP, bool bNotUseCollision, bool IsEndured, const struct FAJBDamageDisplayParams& DamageDisplayParams, const struct FAJBDamageDisplayProperty& DamageDisplayProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "AJBDamage");

	Params::BP_AJBInGameWindow_C_AJBDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.DamageForHPAP = DamageForHPAP;
	Parms.DamageForAAP = DamageForAAP;
	Parms.CutDamage = CutDamage;
	Parms.DamageType = std::move(DamageType);
	Parms.SerialNumber = SerialNumber;
	Parms.DamagePriority = DamagePriority;
	Parms.AttackDistance = AttackDistance;
	Parms.DamageCauser = DamageCauser;
	Parms.WithSeparatedStandAttack = WithSeparatedStandAttack;
	Parms.HitEnemysSeparatedStand = HitEnemysSeparatedStand;
	Parms.bPenetrateAP = bPenetrateAP;
	Parms.bNotUseCollision = bNotUseCollision;
	Parms.IsEndured = IsEndured;
	Parms.DamageDisplayParams = std::move(DamageDisplayParams);
	Parms.DamageDisplayProperty = std::move(DamageDisplayProperty);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.UserConstructionScript
// (Event, Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.GetEntranceOfCounterpart
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_AJBInGameWindow_C::GetEntranceOfCounterpart()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "GetEntranceOfCounterpart");

	Params::BP_AJBInGameWindow_C_GetEntranceOfCounterpart Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.GetInteractCenter
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_AJBInGameWindow_C::GetInteractCenter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "GetInteractCenter");

	Params::BP_AJBInGameWindow_C_GetInteractCenter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IsBroken
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::IsBroken()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IsBroken");

	Params::BP_AJBInGameWindow_C_IsBroken Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnRep_bRep_TriggeredToBreak
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameWindow_C::OnRep_bRep_TriggeredToBreak()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnRep_bRep_TriggeredToBreak");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IfEnteringOriginToCounterpart
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::IfEnteringOriginToCounterpart(class AActor* Actor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IfEnteringOriginToCounterpart");

	Params::BP_AJBInGameWindow_C_IfEnteringOriginToCounterpart Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.RotationOfBreakWindowEffect
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOriginToCounterpart                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)

struct FRotator ABP_AJBInGameWindow_C::RotationOfBreakWindowEffect(bool bOriginToCounterpart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "RotationOfBreakWindowEffect");

	Params::BP_AJBInGameWindow_C_RotationOfBreakWindowEffect Parms{};

	Parms.bOriginToCounterpart = bOriginToCounterpart;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.GetBreakerCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Breaker                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_AJBInGameCharacter_C**        BreakerCharacter                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::GetBreakerCharacter(class AActor* Breaker, class ABP_AJBInGameCharacter_C** BreakerCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "GetBreakerCharacter");

	Params::BP_AJBInGameWindow_C_GetBreakerCharacter Parms{};

	Parms.Breaker = Breaker;

	UObject::ProcessEvent(Func, &Parms);

	if (BreakerCharacter != nullptr)
		*BreakerCharacter = Parms.BreakerCharacter;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.InteractInstantly
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::InteractInstantly(class ABP_AJBInGameCharacter_C* Character)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "InteractInstantly");

	Params::BP_AJBInGameWindow_C_InteractInstantly Parms{};

	Parms.Character = Character;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.Interactable
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceLength                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::Interactable(class ABP_AJBInGameCharacter_C* Character, float TraceLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "Interactable");

	Params::BP_AJBInGameWindow_C_Interactable Parms{};

	Parms.Character = Character;
	Parms.TraceLength = TraceLength;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.TryGetInteractableText
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         OperatorCharacter                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FText*                            InteractMessage                                        (Parm, OutParm)

void ABP_AJBInGameWindow_C::TryGetInteractableText(class ABP_AJBInGameCharacter_C* OperatorCharacter, bool* bSuccess, class FText* InteractMessage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "TryGetInteractableText");

	Params::BP_AJBInGameWindow_C_TryGetInteractableText Parms{};

	Parms.OperatorCharacter = OperatorCharacter;

	UObject::ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	if (InteractMessage != nullptr)
		*InteractMessage = std::move(Parms.InteractMessage);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.CheckErrorCondition
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bErrorCondition                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// uint8*                                  ErrorType                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::CheckErrorCondition(bool* bErrorCondition, uint8* ErrorType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "CheckErrorCondition");

	Params::BP_AJBInGameWindow_C_CheckErrorCondition Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bErrorCondition != nullptr)
		*bErrorCondition = Parms.bErrorCondition;

	if (ErrorType != nullptr)
		*ErrorType = Parms.ErrorType;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OnLocalInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::OnLocalInteract(class AActor* InteractingActor, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OnLocalInteract");

	Params::BP_AJBInGameWindow_C_OnLocalInteract Parms{};

	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.GetInteractState
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// uint8*                                  InteractState                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::GetInteractState(uint8* InteractState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "GetInteractState");

	Params::BP_AJBInGameWindow_C_GetInteractState Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (InteractState != nullptr)
		*InteractState = Parms.InteractState;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.GetInteractPriority
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32*                                  Priority                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::GetInteractPriority(int32* Priority)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "GetInteractPriority");

	Params::BP_AJBInGameWindow_C_GetInteractPriority Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Priority != nullptr)
		*Priority = Parms.Priority;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.GetInteractBoundForCulling
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Center                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Radius                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::GetInteractBoundForCulling(class AActor* InteractingActor, struct FVector* Center, float* Radius)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "GetInteractBoundForCulling");

	Params::BP_AJBInGameWindow_C_GetInteractBoundForCulling Parms{};

	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	if (Center != nullptr)
		*Center = std::move(Parms.Center);

	if (Radius != nullptr)
		*Radius = Parms.Radius;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IfNeedsExclusiveInteractStrictly
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::IfNeedsExclusiveInteractStrictly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IfNeedsExclusiveInteractStrictly");

	Params::BP_AJBInGameWindow_C_IfNeedsExclusiveInteractStrictly Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IfBlockInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractingActor                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::IfBlockInteract(class AActor* InteractingActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IfBlockInteract");

	Params::BP_AJBInGameWindow_C_IfBlockInteract Parms{};

	Parms.InteractingActor = InteractingActor;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.ShouldPrioritizedThanPrepaidSkillCancel
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bShouldPriorirized                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::ShouldPrioritizedThanPrepaidSkillCancel(bool* bShouldPriorirized)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "ShouldPrioritizedThanPrepaidSkillCancel");

	Params::BP_AJBInGameWindow_C_ShouldPrioritizedThanPrepaidSkillCancel Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldPriorirized != nullptr)
		*bShouldPriorirized = Parms.bShouldPriorirized;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.NormalOfEntrance
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOriginToCounterpart                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_AJBInGameWindow_C::NormalOfEntrance(bool bOriginToCounterpart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "NormalOfEntrance");

	Params::BP_AJBInGameWindow_C_NormalOfEntrance Parms{};

	Parms.bOriginToCounterpart = bOriginToCounterpart;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.LocationExitTo
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOriginToCounterpart                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_AJBInGameWindow_C::LocationExitTo(bool bOriginToCounterpart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "LocationExitTo");

	Params::BP_AJBInGameWindow_C_LocationExitTo Parms{};

	Parms.bOriginToCounterpart = bOriginToCounterpart;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.LocationExitFrom
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOriginToCounterpart                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_AJBInGameWindow_C::LocationExitFrom(bool bOriginToCounterpart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "LocationExitFrom");

	Params::BP_AJBInGameWindow_C_LocationExitFrom Parms{};

	Parms.bOriginToCounterpart = bOriginToCounterpart;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.LocationEnterTo
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bOriginToCounterpart                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_AJBInGameWindow_C::LocationEnterTo(bool bOriginToCounterpart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "LocationEnterTo");

	Params::BP_AJBInGameWindow_C_LocationEnterTo Parms{};

	Parms.bOriginToCounterpart = bOriginToCounterpart;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.LocationEnterFrom
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bOriginToCounterpart                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector ABP_AJBInGameWindow_C::LocationEnterFrom(class ABP_AJBInGameCharacter_C* Character, bool bOriginToCounterpart)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "LocationEnterFrom");

	Params::BP_AJBInGameWindow_C_LocationEnterFrom Parms{};

	Parms.Character = Character;
	Parms.bOriginToCounterpart = bOriginToCounterpart;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.CheckNoDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bNoDamage                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::CheckNoDamage(class AActor* DamageCauser, bool* bNoDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "CheckNoDamage");

	Params::BP_AJBInGameWindow_C_CheckNoDamage Parms{};

	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

	if (bNoDamage != nullptr)
		*bNoDamage = Parms.bNoDamage;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.CheckDisableAreaDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bDisableAreadamage                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::CheckDisableAreaDamage(bool* bDisableAreadamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "CheckDisableAreaDamage");

	Params::BP_AJBInGameWindow_C_CheckDisableAreaDamage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDisableAreadamage != nullptr)
		*bDisableAreadamage = Parms.bDisableAreadamage;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.CheckDisablePassive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           PassiveCauser                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              PassiveTag                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bDisablePassive                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::CheckDisablePassive(class AActor* PassiveCauser, const struct FGameplayTag& PassiveTag, bool bIgnoreSelf, bool* bDisablePassive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "CheckDisablePassive");

	Params::BP_AJBInGameWindow_C_CheckDisablePassive Parms{};

	Parms.PassiveCauser = PassiveCauser;
	Parms.PassiveTag = std::move(PassiveTag);
	Parms.bIgnoreSelf = bIgnoreSelf;

	UObject::ProcessEvent(Func, &Parms);

	if (bDisablePassive != nullptr)
		*bDisablePassive = Parms.bDisablePassive;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.CheckDisableDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bDisableDamage                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::CheckDisableDamage(class AActor* DamageCauser, bool bIgnoreSelf, bool* bDisableDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "CheckDisableDamage");

	Params::BP_AJBInGameWindow_C_CheckDisableDamage Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.bIgnoreSelf = bIgnoreSelf;

	UObject::ProcessEvent(Func, &Parms);

	if (bDisableDamage != nullptr)
		*bDisableDamage = Parms.bDisableDamage;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IfCheckDamageOverlap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::IfCheckDamageOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IfCheckDamageOverlap");

	Params::BP_AJBInGameWindow_C_IfCheckDamageOverlap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.OwnHitParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bCharacter                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bLeftAP                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FGameplayTag*                    ParticleTagBlockedByAAP                                (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag*                    SETagBlockedByAAP                                      (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag*                    ParticleTagBlocked                                     (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameWindow_C::OwnHitParam(bool* bCharacter, bool* bLeftAP, struct FGameplayTag* ParticleTagBlockedByAAP, struct FGameplayTag* SETagBlockedByAAP, struct FGameplayTag* ParticleTagBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "OwnHitParam");

	Params::BP_AJBInGameWindow_C_OwnHitParam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bCharacter != nullptr)
		*bCharacter = Parms.bCharacter;

	if (bLeftAP != nullptr)
		*bLeftAP = Parms.bLeftAP;

	if (ParticleTagBlockedByAAP != nullptr)
		*ParticleTagBlockedByAAP = std::move(Parms.ParticleTagBlockedByAAP);

	if (SETagBlockedByAAP != nullptr)
		*SETagBlockedByAAP = std::move(Parms.SETagBlockedByAAP);

	if (ParticleTagBlocked != nullptr)
		*ParticleTagBlocked = std::move(Parms.ParticleTagBlocked);
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.CheckTargetSelf
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bForDamageOverlap                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIgnoreMovableStand                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIncludeSelf                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bAfterReflectShouldHitOwner                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bTarget                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::CheckTargetSelf(class AActor* DamageCauser, bool bForDamageOverlap, bool bIgnoreMovableStand, bool bIncludeSelf, bool bAfterReflectShouldHitOwner, bool* bTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "CheckTargetSelf");

	Params::BP_AJBInGameWindow_C_CheckTargetSelf Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.bForDamageOverlap = bForDamageOverlap;
	Parms.bIgnoreMovableStand = bIgnoreMovableStand;
	Parms.bIncludeSelf = bIncludeSelf;
	Parms.bAfterReflectShouldHitOwner = bAfterReflectShouldHitOwner;

	UObject::ProcessEvent(Func, &Parms);

	if (bTarget != nullptr)
		*bTarget = Parms.bTarget;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IsReactedByReticule
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::IsReactedByReticule(bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IsReactedByReticule");

	Params::BP_AJBInGameWindow_C_IsReactedByReticule Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IgnoreTrace
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Owner_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPairOnly                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bIgnore                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::IgnoreTrace(class AActor* Owner_0, bool bPairOnly, bool* bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IgnoreTrace");

	Params::BP_AJBInGameWindow_C_IgnoreTrace Parms{};

	Parms.Owner_0 = Owner_0;
	Parms.bPairOnly = bPairOnly;

	UObject::ProcessEvent(Func, &Parms);

	if (bIgnore != nullptr)
		*bIgnore = Parms.bIgnore;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.CheckDisableDirectDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bDisableDirectDamage                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameWindow_C::CheckDisableDirectDamage(class AActor* DamageCauser, bool* bDisableDirectDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "CheckDisableDirectDamage");

	Params::BP_AJBInGameWindow_C_CheckDisableDirectDamage Parms{};

	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

	if (bDisableDirectDamage != nullptr)
		*bDisableDirectDamage = Parms.bDisableDirectDamage;
}


// Function BP_AJBInGameWindow.BP_AJBInGameWindow_C.IsSmallWindow
// (Event, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameWindow_C::IsSmallWindow() const
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameWindow_C", "IsSmallWindow");

	Params::BP_AJBInGameWindow_C_IsSmallWindow Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}

}

