#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBInGameProjectile

#include "Basic.hpp"

#include "BP_AJBInGameProjectile_classes.hpp"
#include "BP_AJBInGameProjectile_parameters.hpp"


namespace SDK
{

// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ExecuteUbergraph_BP_AJBInGameProjectile
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::ExecuteUbergraph_BP_AJBInGameProjectile(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ExecuteUbergraph_BP_AJBInGameProjectile");

	Params::BP_AJBInGameProjectile_C_ExecuteUbergraph_BP_AJBInGameProjectile Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.SpawnDisappearParticle
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::SpawnDisappearParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "SpawnDisappearParticle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ROS_CancelLocal
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::ROS_CancelLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ROS_CancelLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CancelLocal
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::CancelLocal()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CancelLocal");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnCancel
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::OnCancel()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnCancel");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.MC_CancelServer
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::MC_CancelServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "MC_CancelServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CancelServer
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::CancelServer()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CancelServer");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnPassiveAddedAfterSetCauser
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              AddCondition                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              CauserType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::OnPassiveAddedAfterSetCauser(const struct FGameplayTag& AddCondition, class UObject* Causer, const struct FGameplayTag& CauserType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnPassiveAddedAfterSetCauser");

	Params::BP_AJBInGameProjectile_C_OnPassiveAddedAfterSetCauser Parms{};

	Parms.AddCondition = std::move(AddCondition);
	Parms.Causer = Causer;
	Parms.CauserType = std::move(CauserType);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnCritical
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::OnCritical()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnCritical");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnBecomeLastSurvivor
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bBitesTheDust                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::OnBecomeLastSurvivor(bool bBitesTheDust)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnBecomeLastSurvivor");

	Params::BP_AJBInGameProjectile_C_OnBecomeLastSurvivor Parms{};

	Parms.bBitesTheDust = bBitesTheDust;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnCharacterDead
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DeadActor                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::OnCharacterDead(const struct FGameplayTag& DamageType, class AActor* DeadActor, class AActor* DamageCauser)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnCharacterDead");

	Params::BP_AJBInGameProjectile_C_OnCharacterDead Parms{};

	Parms.DamageType = std::move(DamageType);
	Parms.DeadActor = DeadActor;
	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.DelayedDestroy
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DelaySec                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::DelayedDestroy(float DelaySec)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "DelayedDestroy");

	Params::BP_AJBInGameProjectile_C_DelayedDestroy Parms{};

	Parms.DelaySec = DelaySec;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.MC_DestroySelf
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::MC_DestroySelf(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "MC_DestroySelf");

	Params::BP_AJBInGameProjectile_C_MC_DestroySelf Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ROS_NotifyBlockingOnProjectileOwnerEnv
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_AJBBlockingRushSkill_C*       BlockingSkillComponent                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bSeparateStandAttack                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::ROS_NotifyBlockingOnProjectileOwnerEnv(const struct FVector& Location, const struct FVector& Normal, class UBP_AJBBlockingRushSkill_C* BlockingSkillComponent, bool bSeparateStandAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ROS_NotifyBlockingOnProjectileOwnerEnv");

	Params::BP_AJBInGameProjectile_C_ROS_NotifyBlockingOnProjectileOwnerEnv Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.BlockingSkillComponent = BlockingSkillComponent;
	Parms.bSeparateStandAttack = bSeparateStandAttack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.RequestHitEffect_Core
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bCharacter                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bLeftAP                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ParticleTagBlockedByAAP                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              ParticleTagBlocked                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::RequestHitEffect_Core(const struct FVector& Location, const struct FVector& Normal, const struct FRotator& Rotation, bool bCharacter, bool bLeftAP, bool bBlocking, bool bHeadShot, EPhysicalSurface SurfaceType, bool bBlockedByAAP, const struct FGameplayTag& ParticleTagBlockedByAAP, const struct FGameplayTag& ParticleTagBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "RequestHitEffect_Core");

	Params::BP_AJBInGameProjectile_C_RequestHitEffect_Core Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.Rotation = std::move(Rotation);
	Parms.bCharacter = bCharacter;
	Parms.bLeftAP = bLeftAP;
	Parms.bBlocking = bBlocking;
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.ParticleTagBlockedByAAP = std::move(ParticleTagBlockedByAAP);
	Parms.ParticleTagBlocked = std::move(ParticleTagBlocked);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.MC_RequestHitEffect
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bCharacter                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bLeftAP                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ParticleTagBlockedByAAP                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              ParticleTagBlocked                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::MC_RequestHitEffect(const struct FVector& Location, const struct FVector& Normal, const struct FRotator& Rotation, bool bCharacter, bool bLeftAP, bool bBlocking, bool bHeadShot, EPhysicalSurface SurfaceType, bool bBlockedByAAP, const struct FGameplayTag& ParticleTagBlockedByAAP, const struct FGameplayTag& ParticleTagBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "MC_RequestHitEffect");

	Params::BP_AJBInGameProjectile_C_MC_RequestHitEffect Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.Rotation = std::move(Rotation);
	Parms.bCharacter = bCharacter;
	Parms.bLeftAP = bLeftAP;
	Parms.bBlocking = bBlocking;
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.ParticleTagBlockedByAAP = std::move(ParticleTagBlockedByAAP);
	Parms.ParticleTagBlocked = std::move(ParticleTagBlocked);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ROS_RequestHitEffect
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bCharacter                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bLeftAP                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ParticleTagBlockedByAAP                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              ParticleTagBlocked                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::ROS_RequestHitEffect(const struct FVector& Location, const struct FVector& Normal, const struct FRotator& Rotation, bool bCharacter, bool bLeftAP, bool bBlocking, bool bHeadShot, EPhysicalSurface SurfaceType, bool bBlockedByAAP, const struct FGameplayTag& ParticleTagBlockedByAAP, const struct FGameplayTag& ParticleTagBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ROS_RequestHitEffect");

	Params::BP_AJBInGameProjectile_C_ROS_RequestHitEffect Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.Rotation = std::move(Rotation);
	Parms.bCharacter = bCharacter;
	Parms.bLeftAP = bLeftAP;
	Parms.bBlocking = bBlocking;
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.ParticleTagBlockedByAAP = std::move(ParticleTagBlockedByAAP);
	Parms.ParticleTagBlocked = std::move(ParticleTagBlocked);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.RequestHitEffect
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  Rotation                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bCharacter                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bLeftAP                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ParticleTagBlockedByAAP                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              ParticleTagBlocked                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::RequestHitEffect(const struct FVector& Location, const struct FVector& Normal, const struct FRotator& Rotation, bool bCharacter, bool bLeftAP, bool bBlocking, bool bHeadShot, EPhysicalSurface SurfaceType, bool bBlockedByAAP, const struct FGameplayTag& ParticleTagBlockedByAAP, const struct FGameplayTag& ParticleTagBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "RequestHitEffect");

	Params::BP_AJBInGameProjectile_C_RequestHitEffect Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.Rotation = std::move(Rotation);
	Parms.bCharacter = bCharacter;
	Parms.bLeftAP = bLeftAP;
	Parms.bBlocking = bBlocking;
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.ParticleTagBlockedByAAP = std::move(ParticleTagBlockedByAAP);
	Parms.ParticleTagBlocked = std::move(ParticleTagBlocked);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnHitObjectiveCollision_Local
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitNormal_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        HitSurfaceType_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::OnHitObjectiveCollision_Local(class AActor* HitActor, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0, EPhysicalSurface HitSurfaceType_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnHitObjectiveCollision_Local");

	Params::BP_AJBInGameProjectile_C_OnHitObjectiveCollision_Local Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.HitNormal_0 = std::move(HitNormal_0);
	Parms.HitSurfaceType_0 = HitSurfaceType_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ReceiveEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ReceiveEndPlay");

	Params::BP_AJBInGameProjectile_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.BeginObjectiveCollisionOverlap
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                SweepResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_AJBInGameProjectile_C::BeginObjectiveCollisionOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "BeginObjectiveCollisionOverlap");

	Params::BP_AJBInGameProjectile_C_BeginObjectiveCollisionOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnHitObjectiveCollision_Server
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::OnHitObjectiveCollision_Server(const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnHitObjectiveCollision_Server");

	Params::BP_AJBInGameProjectile_C_OnHitObjectiveCollision_Server Parms{};

	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnHitObjectiveCollision_All
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::OnHitObjectiveCollision_All()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnHitObjectiveCollision_All");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.MC_HitObjectiveCollision
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::MC_HitObjectiveCollision()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "MC_HitObjectiveCollision");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ROS_HitObjectiveCollision
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::ROS_HitObjectiveCollision(const struct FVector& HitLocation_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ROS_HitObjectiveCollision");

	Params::BP_AJBInGameProjectile_C_ROS_HitObjectiveCollision Parms{};

	Parms.HitLocation_0 = std::move(HitLocation_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ROS_OnDamageOverlap
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::ROS_OnDamageOverlap(class AActor* HitActor, const struct FVector& Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ROS_OnDamageOverlap");

	Params::BP_AJBInGameProjectile_C_ROS_OnDamageOverlap Parms{};

	Parms.HitActor = HitActor;
	Parms.Location = std::move(Location);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnDamageOverlap
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::OnDamageOverlap(class AActor* HitActor, const struct FVector& HitLocation_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnDamageOverlap");

	Params::BP_AJBInGameProjectile_C_OnDamageOverlap Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnPassiveSkillAffecting
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSuccess                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitNormal_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrate_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::OnPassiveSkillAffecting(bool bSuccess, class AActor* HitActor, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0, bool bHeadShot, bool bPenetrate_0, float CuttingRate)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnPassiveSkillAffecting");

	Params::BP_AJBInGameProjectile_C_OnPassiveSkillAffecting Parms{};

	Parms.bSuccess = bSuccess;
	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.HitNormal_0 = std::move(HitNormal_0);
	Parms.bHeadShot = bHeadShot;
	Parms.bPenetrate_0 = bPenetrate_0;
	Parms.CuttingRate = CuttingRate;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_AJBInGameProjectile_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ROS_TryServerConsume
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitNormal_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrate_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bFirstHit                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDisableDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bReflect                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FRotator&                  ReflectRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ReflectSkillTag_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bAvoidSkill                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::ROS_TryServerConsume(class AActor* HitActor, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0, bool bHeadShot, bool bPenetrate_0, bool bFirstHit, float CuttingRate, EPhysicalSurface SurfaceType, bool bDisableDamage, bool bReflect, const struct FRotator& ReflectRotation, bool bBlocking, bool bBlockedByAAP, const struct FGameplayTag& ReflectSkillTag_0, bool bAvoidSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ROS_TryServerConsume");

	Params::BP_AJBInGameProjectile_C_ROS_TryServerConsume Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.HitNormal_0 = std::move(HitNormal_0);
	Parms.bHeadShot = bHeadShot;
	Parms.bPenetrate_0 = bPenetrate_0;
	Parms.bFirstHit = bFirstHit;
	Parms.CuttingRate = CuttingRate;
	Parms.SurfaceType = SurfaceType;
	Parms.bDisableDamage = bDisableDamage;
	Parms.bReflect = bReflect;
	Parms.ReflectRotation = std::move(ReflectRotation);
	Parms.bBlocking = bBlocking;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.ReflectSkillTag_0 = std::move(ReflectSkillTag_0);
	Parms.bAvoidSkill = bAvoidSkill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.MC_TryServerConsume
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDisableDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bReflect                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::MC_TryServerConsume(class AActor* HitActor, const struct FVector& HitLocation_0, bool bHeadShot, EPhysicalSurface SurfaceType, bool bDisableDamage, float CuttingRate, bool bBlockedByAAP, bool bReflect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "MC_TryServerConsume");

	Params::BP_AJBInGameProjectile_C_MC_TryServerConsume Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.bDisableDamage = bDisableDamage;
	Parms.CuttingRate = CuttingRate;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.bReflect = bReflect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.TryServerConsume
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitNormal_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrate_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bFirstHit                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDisableDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bReflect                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FRotator&                  ReflectRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ReflectSkillTag_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bAvoidSkill                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::TryServerConsume(class AActor* HitActor, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0, bool bHeadShot, bool bPenetrate_0, bool bFirstHit, float CuttingRate, EPhysicalSurface SurfaceType, bool bDisableDamage, bool bReflect, const struct FRotator& ReflectRotation, bool bBlocking, bool bBlockedByAAP, const struct FGameplayTag& ReflectSkillTag_0, bool bAvoidSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "TryServerConsume");

	Params::BP_AJBInGameProjectile_C_TryServerConsume Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.HitNormal_0 = std::move(HitNormal_0);
	Parms.bHeadShot = bHeadShot;
	Parms.bPenetrate_0 = bPenetrate_0;
	Parms.bFirstHit = bFirstHit;
	Parms.CuttingRate = CuttingRate;
	Parms.SurfaceType = SurfaceType;
	Parms.bDisableDamage = bDisableDamage;
	Parms.bReflect = bReflect;
	Parms.ReflectRotation = std::move(ReflectRotation);
	Parms.bBlocking = bBlocking;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.ReflectSkillTag_0 = std::move(ReflectSkillTag_0);
	Parms.bAvoidSkill = bAvoidSkill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.SpawnParticle
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   SpawnLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   SpawnNormal                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::SpawnParticle(const struct FVector& SpawnLocation, const struct FVector& SpawnNormal, bool bBlocking, bool bHeadShot, class AActor* HitActor, EPhysicalSurface SurfaceType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "SpawnParticle");

	Params::BP_AJBInGameProjectile_C_SpawnParticle Parms{};

	Parms.SpawnLocation = std::move(SpawnLocation);
	Parms.SpawnNormal = std::move(SpawnNormal);
	Parms.bBlocking = bBlocking;
	Parms.bHeadShot = bHeadShot;
	Parms.HitActor = HitActor;
	Parms.SurfaceType = SurfaceType;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.LocalConsume
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSucceed                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::LocalConsume(bool bSucceed)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "LocalConsume");

	Params::BP_AJBInGameProjectile_C_LocalConsume Parms{};

	Parms.bSucceed = bSucceed;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnMC_ProjectileHit
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDisableDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bReflect                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::OnMC_ProjectileHit(class AActor* HitActor, const struct FVector& HitLocation_0, bool bHeadShot, EPhysicalSurface SurfaceType, bool bDisableDamage, float CuttingRate, bool bBlockedByAAP, bool bReflect)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnMC_ProjectileHit");

	Params::BP_AJBInGameProjectile_C_OnMC_ProjectileHit Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.bDisableDamage = bDisableDamage;
	Parms.CuttingRate = CuttingRate;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.bReflect = bReflect;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnROS_ProjectileHit
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitNormal_0                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrate_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bFirstHit                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDisableDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bReflect                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FRotator&                  ReflectRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ReflectSkillTag_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bAvoidSkill                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::OnROS_ProjectileHit(class AActor* HitActor, const struct FVector& HitLocation_0, const struct FVector& HitNormal_0, bool bHeadShot, bool bPenetrate_0, bool bFirstHit, float CuttingRate, bool bDisableDamage, bool bReflect, const struct FRotator& ReflectRotation, bool bBlocking, const struct FGameplayTag& ReflectSkillTag_0, bool bAvoidSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnROS_ProjectileHit");

	Params::BP_AJBInGameProjectile_C_OnROS_ProjectileHit Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.HitNormal_0 = std::move(HitNormal_0);
	Parms.bHeadShot = bHeadShot;
	Parms.bPenetrate_0 = bPenetrate_0;
	Parms.bFirstHit = bFirstHit;
	Parms.CuttingRate = CuttingRate;
	Parms.bDisableDamage = bDisableDamage;
	Parms.bReflect = bReflect;
	Parms.ReflectRotation = std::move(ReflectRotation);
	Parms.bBlocking = bBlocking;
	Parms.ReflectSkillTag_0 = std::move(ReflectSkillTag_0);
	Parms.bAvoidSkill = bAvoidSkill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnProjectileHit
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    FromSweep                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                SweepResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrate_0                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bFirstHit                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::OnProjectileHit(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool FromSweep, const struct FHitResult& SweepResult, bool bHeadShot, bool bPenetrate_0, bool bFirstHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnProjectileHit");

	Params::BP_AJBInGameProjectile_C_OnProjectileHit Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.FromSweep = FromSweep;
	Parms.SweepResult = std::move(SweepResult);
	Parms.bHeadShot = bHeadShot;
	Parms.bPenetrate_0 = bPenetrate_0;
	Parms.bFirstHit = bFirstHit;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ROS_DestroySelf
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::ROS_DestroySelf()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ROS_DestroySelf");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckRange
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::CheckRange()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckRange");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ReceiveTick");

	Params::BP_AJBInGameProjectile_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_AJBInGameProjectile_C::BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_AJBInGameProjectile_C_BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.NotifyTheWorld
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAJBInGameCharacter*              Operator                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGeneralTiming                          Timing                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bOperatorIsEmpty                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "NotifyTheWorld");

	Params::BP_AJBInGameProjectile_C_NotifyTheWorld Parms{};

	Parms.Operator = Operator;
	Parms.Time = Time;
	Parms.Timing = Timing;
	Parms.bEnable = bEnable;
	Parms.bOperatorIsEmpty = bOperatorIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ForceSpawn
// (Net, NetMulticast, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::ForceSpawn()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ForceSpawn");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnAreaDamageDisabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::OnAreaDamageDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnAreaDamageDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnPassiveDisabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::OnPassiveDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnPassiveDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnDamageDisabled
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::OnDamageDisabled()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnDamageDisabled");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.DamageOverlapped
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPenetrating                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              FactorTag                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bInvalidDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::DamageOverlapped(class AActor* DamageCauser, const struct FVector& HitLocation_0, bool bPenetrating, const struct FGameplayTag& FactorTag, bool bInvalidDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "DamageOverlapped");

	Params::BP_AJBInGameProjectile_C_DamageOverlapped Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.bPenetrating = bPenetrating;
	Parms.FactorTag = std::move(FactorTag);
	Parms.bInvalidDamage = bInvalidDamage;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.AJBDamage
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageForHPAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   DamageForAAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CutDamage                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamagePriority                         DamagePriority                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AttackDistance                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    WithSeparatedStandAttack                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    HitEnemysSeparatedStand                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrateAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bNotUseCollision                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    IsEndured                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FAJBDamageDisplayParams&   DamageDisplayParams                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FAJBDamageDisplayProperty& DamageDisplayProperty                                  (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::AJBDamage(class AActor* DamagedActor, int32 DamageForHPAP, int32 DamageForAAP, int32 CutDamage, const struct FGameplayTag& DamageType, int32 SerialNumber_0, EDamagePriority DamagePriority, float AttackDistance, class AActor* DamageCauser, bool WithSeparatedStandAttack, bool HitEnemysSeparatedStand, bool bPenetrateAP, bool bNotUseCollision, bool IsEndured, const struct FAJBDamageDisplayParams& DamageDisplayParams, const struct FAJBDamageDisplayProperty& DamageDisplayProperty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "AJBDamage");

	Params::BP_AJBInGameProjectile_C_AJBDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.DamageForHPAP = DamageForHPAP;
	Parms.DamageForAAP = DamageForAAP;
	Parms.CutDamage = CutDamage;
	Parms.DamageType = std::move(DamageType);
	Parms.SerialNumber_0 = SerialNumber_0;
	Parms.DamagePriority = DamagePriority;
	Parms.AttackDistance = AttackDistance;
	Parms.DamageCauser = DamageCauser;
	Parms.WithSeparatedStandAttack = WithSeparatedStandAttack;
	Parms.HitEnemysSeparatedStand = HitEnemysSeparatedStand;
	Parms.bPenetrateAP = bPenetrateAP;
	Parms.bNotUseCollision = bNotUseCollision;
	Parms.IsEndured = IsEndured;
	Parms.DamageDisplayParams = std::move(DamageDisplayParams);
	Parms.DamageDisplayProperty = std::move(DamageDisplayProperty);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnCollisionOverlap
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComponent                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                SweepResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_AJBInGameProjectile_C::OnCollisionOverlap(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComponent, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnCollisionOverlap");

	Params::BP_AJBInGameProjectile_C_OnCollisionOverlap Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComponent = OtherComponent;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetPoliticDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32*                                  Damage_0                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetPoliticDamage(bool bHeadShot, int32* Damage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetPoliticDamage");

	Params::BP_AJBInGameProjectile_C_GetPoliticDamage Parms{};

	Parms.bHeadShot = bHeadShot;

	UObject::ProcessEvent(Func, &Parms);

	if (Damage_0 != nullptr)
		*Damage_0 = Parms.Damage_0;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckHeadShot
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bHeadShot                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckHeadShot(class AActor* HitActor, const struct FVector& Location, const struct FVector& Direction, bool* bHeadShot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckHeadShot");

	Params::BP_AJBInGameProjectile_C_CheckHeadShot Parms{};

	Parms.HitActor = HitActor;
	Parms.Location = std::move(Location);
	Parms.Direction = std::move(Direction);

	UObject::ProcessEvent(Func, &Parms);

	if (bHeadShot != nullptr)
		*bHeadShot = Parms.bHeadShot;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.DebugDrawHitLocation
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::DebugDrawHitLocation(const struct FVector& HitLocation_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "DebugDrawHitLocation");

	Params::BP_AJBInGameProjectile_C_DebugDrawHitLocation Parms{};

	Parms.HitLocation_0 = std::move(HitLocation_0);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.PlayHitSE
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::PlayHitSE(class AActor* HitActor, const struct FVector& HitLocation_0, bool bHeadShot, EPhysicalSurface SurfaceType, float CuttingRate, bool bBlockedByAAP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "PlayHitSE");

	Params::BP_AJBInGameProjectile_C_PlayHitSE Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation_0 = std::move(HitLocation_0);
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.CuttingRate = CuttingRate;
	Parms.bBlockedByAAP = bBlockedByAAP;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckCharacterIsAlive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bIsAlive                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckCharacterIsAlive(class AActor* Actor, bool* bIsAlive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckCharacterIsAlive");

	Params::BP_AJBInGameProjectile_C_CheckCharacterIsAlive Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	if (bIsAlive != nullptr)
		*bIsAlive = Parms.bIsAlive;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetMovementLength
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float*                                  Length                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetMovementLength(float* Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetMovementLength");

	Params::BP_AJBInGameProjectile_C_GetMovementLength Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Length != nullptr)
		*Length = Parms.Length;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.SetLeftPlayHitSETime
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::SetLeftPlayHitSETime()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "SetLeftPlayHitSETime");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckPossiblePlayHitSE
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   bPossible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckPossiblePlayHitSE(bool* bPossible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckPossiblePlayHitSE");

	Params::BP_AJBInGameProjectile_C_CheckPossiblePlayHitSE Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bPossible != nullptr)
		*bPossible = Parms.bPossible;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.UpdateLeftPlayHitSETime
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::UpdateLeftPlayHitSETime(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "UpdateLeftPlayHitSETime");

	Params::BP_AJBInGameProjectile_C_UpdateLeftPlayHitSETime Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.SetLeftSpawnDecalDistance
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::SetLeftSpawnDecalDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "SetLeftSpawnDecalDistance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.UpdateLeftSpawnDecalDistance
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::UpdateLeftSpawnDecalDistance()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "UpdateLeftSpawnDecalDistance");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckPossibleSpawnDecal
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   bPossible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckPossibleSpawnDecal(bool* bPossible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckPossibleSpawnDecal");

	Params::BP_AJBInGameProjectile_C_CheckPossibleSpawnDecal Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bPossible != nullptr)
		*bPossible = Parms.bPossible;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ApplyProjectileParameter
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::ApplyProjectileParameter()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ApplyProjectileParameter");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetAppropriateCharaParam
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTag*                    CharaParam                                             (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetAppropriateCharaParam(struct FGameplayTag* CharaParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetAppropriateCharaParam");

	Params::BP_AJBInGameProjectile_C_GetAppropriateCharaParam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharaParam != nullptr)
		*CharaParam = std::move(Parms.CharaParam);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ShouldCheckRange
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   bShouldCheckRange                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::ShouldCheckRange(bool* bShouldCheckRange)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ShouldCheckRange");

	Params::BP_AJBInGameProjectile_C_ShouldCheckRange Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldCheckRange != nullptr)
		*bShouldCheckRange = Parms.bShouldCheckRange;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckSeparateStandAttack
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           DamageOwner                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSeparateStandAttack                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckSeparateStandAttack(class AActor* DamageOwner, bool* bSeparateStandAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckSeparateStandAttack");

	Params::BP_AJBInGameProjectile_C_CheckSeparateStandAttack Parms{};

	Parms.DamageOwner = DamageOwner;

	UObject::ProcessEvent(Func, &Parms);

	if (bSeparateStandAttack != nullptr)
		*bSeparateStandAttack = Parms.bSeparateStandAttack;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ShouldRequestHitEffect
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bCharacter                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bBlocking                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bShouldRequest                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::ShouldRequestHitEffect(bool bCharacter, bool bBlocking, bool* bShouldRequest)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ShouldRequestHitEffect");

	Params::BP_AJBInGameProjectile_C_ShouldRequestHitEffect Parms{};

	Parms.bCharacter = bCharacter;
	Parms.bBlocking = bBlocking;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldRequest != nullptr)
		*bShouldRequest = Parms.bShouldRequest;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckPenetrate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bPenetrate_0                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckPenetrate(class AActor* TargetActor, bool* bPenetrate_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckPenetrate");

	Params::BP_AJBInGameProjectile_C_CheckPenetrate Parms{};

	Parms.TargetActor = TargetActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bPenetrate_0 != nullptr)
		*bPenetrate_0 = Parms.bPenetrate_0;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckIgnoreAddPassive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bIgnore                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckIgnoreAddPassive(class AActor* HitActor, bool* bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckIgnoreAddPassive");

	Params::BP_AJBInGameProjectile_C_CheckIgnoreAddPassive Parms{};

	Parms.HitActor = HitActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bIgnore != nullptr)
		*bIgnore = Parms.bIgnore;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CalcDamageOnSeparate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  Damage_0                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::CalcDamageOnSeparate(int32* Damage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CalcDamageOnSeparate");

	Params::BP_AJBInGameProjectile_C_CalcDamageOnSeparate Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Damage_0 != nullptr)
		*Damage_0 = Parms.Damage_0;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CalcDamageOnHeadShot
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  Damage_0                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::CalcDamageOnHeadShot(int32* Damage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CalcDamageOnHeadShot");

	Params::BP_AJBInGameProjectile_C_CalcDamageOnHeadShot Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Damage_0 != nullptr)
		*Damage_0 = Parms.Damage_0;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.ShouldAttenuation
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   bShouldAttenuation                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::ShouldAttenuation(bool* bShouldAttenuation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "ShouldAttenuation");

	Params::BP_AJBInGameProjectile_C_ShouldAttenuation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldAttenuation != nullptr)
		*bShouldAttenuation = Parms.bShouldAttenuation;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CalcDamageOnDefault
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32*                                  Damage_0                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::CalcDamageOnDefault(int32* Damage_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CalcDamageOnDefault");

	Params::BP_AJBInGameProjectile_C_CalcDamageOnDefault Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Damage_0 != nullptr)
		*Damage_0 = Parms.Damage_0;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetMoveLengthUsedHitLocation
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float*                                  MoveLength                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetMoveLengthUsedHitLocation(float* MoveLength)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetMoveLengthUsedHitLocation");

	Params::BP_AJBInGameProjectile_C_GetMoveLengthUsedHitLocation Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (MoveLength != nullptr)
		*MoveLength = Parms.MoveLength;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OnRep_bRepTimeStopOnInitial
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameProjectile_C::OnRep_bRepTimeStopOnInitial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OnRep_bRepTimeStopOnInitial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetLengthFromOwner
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// float*                                  Length                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetLengthFromOwner(float* Length)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetLengthFromOwner");

	Params::BP_AJBInGameProjectile_C_GetLengthFromOwner Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Length != nullptr)
		*Length = Parms.Length;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.UpdateStateTime
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::UpdateStateTime(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "UpdateStateTime");

	Params::BP_AJBInGameProjectile_C_UpdateStateTime Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckTargetSelf
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bForDamageOverlap                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIgnoreMovableStand                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIncludeSelf                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bAfterReflectShouldHitOwner                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bTarget                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckTargetSelf(class AActor* DamageCauser, bool bForDamageOverlap, bool bIgnoreMovableStand, bool bIncludeSelf, bool bAfterReflectShouldHitOwner, bool* bTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckTargetSelf");

	Params::BP_AJBInGameProjectile_C_CheckTargetSelf Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.bForDamageOverlap = bForDamageOverlap;
	Parms.bIgnoreMovableStand = bIgnoreMovableStand;
	Parms.bIncludeSelf = bIncludeSelf;
	Parms.bAfterReflectShouldHitOwner = bAfterReflectShouldHitOwner;

	UObject::ProcessEvent(Func, &Parms);

	if (bTarget != nullptr)
		*bTarget = Parms.bTarget;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.OwnHitParam
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bCharacter                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bLeftAP                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FGameplayTag*                    ParticleTagBlockedByAAP                                (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag*                    SETagBlockedByAAP                                      (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag*                    ParticleTagBlocked                                     (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::OwnHitParam(bool* bCharacter, bool* bLeftAP, struct FGameplayTag* ParticleTagBlockedByAAP, struct FGameplayTag* SETagBlockedByAAP, struct FGameplayTag* ParticleTagBlocked)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "OwnHitParam");

	Params::BP_AJBInGameProjectile_C_OwnHitParam Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bCharacter != nullptr)
		*bCharacter = Parms.bCharacter;

	if (bLeftAP != nullptr)
		*bLeftAP = Parms.bLeftAP;

	if (ParticleTagBlockedByAAP != nullptr)
		*ParticleTagBlockedByAAP = std::move(Parms.ParticleTagBlockedByAAP);

	if (SETagBlockedByAAP != nullptr)
		*SETagBlockedByAAP = std::move(Parms.SETagBlockedByAAP);

	if (ParticleTagBlocked != nullptr)
		*ParticleTagBlocked = std::move(Parms.ParticleTagBlocked);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.IfCheckDamageOverlap
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBInGameProjectile_C::IfCheckDamageOverlap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "IfCheckDamageOverlap");

	Params::BP_AJBInGameProjectile_C_IfCheckDamageOverlap Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckDisableDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bDisableDamage                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckDisableDamage(class AActor* DamageCauser, bool bIgnoreSelf, bool* bDisableDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckDisableDamage");

	Params::BP_AJBInGameProjectile_C_CheckDisableDamage Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.bIgnoreSelf = bIgnoreSelf;

	UObject::ProcessEvent(Func, &Parms);

	if (bDisableDamage != nullptr)
		*bDisableDamage = Parms.bDisableDamage;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckDisablePassive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           PassiveCauser                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              PassiveTag                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bDisablePassive                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckDisablePassive(class AActor* PassiveCauser, const struct FGameplayTag& PassiveTag, bool bIgnoreSelf, bool* bDisablePassive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckDisablePassive");

	Params::BP_AJBInGameProjectile_C_CheckDisablePassive Parms{};

	Parms.PassiveCauser = PassiveCauser;
	Parms.PassiveTag = std::move(PassiveTag);
	Parms.bIgnoreSelf = bIgnoreSelf;

	UObject::ProcessEvent(Func, &Parms);

	if (bDisablePassive != nullptr)
		*bDisablePassive = Parms.bDisablePassive;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckDisableAreaDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bDisableAreadamage                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckDisableAreaDamage(bool* bDisableAreadamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckDisableAreaDamage");

	Params::BP_AJBInGameProjectile_C_CheckDisableAreaDamage Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bDisableAreadamage != nullptr)
		*bDisableAreadamage = Parms.bDisableAreadamage;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckNoDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bNoDamage                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckNoDamage(class AActor* DamageCauser, bool* bNoDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckNoDamage");

	Params::BP_AJBInGameProjectile_C_CheckNoDamage Parms{};

	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

	if (bNoDamage != nullptr)
		*bNoDamage = Parms.bNoDamage;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.IsReactedByReticule
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::IsReactedByReticule(bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "IsReactedByReticule");

	Params::BP_AJBInGameProjectile_C_IsReactedByReticule Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.IgnoreTrace
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Owner_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPairOnly                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bIgnore                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::IgnoreTrace(class AActor* Owner_0, bool bPairOnly, bool* bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "IgnoreTrace");

	Params::BP_AJBInGameProjectile_C_IgnoreTrace Parms{};

	Parms.Owner_0 = Owner_0;
	Parms.bPairOnly = bPairOnly;

	UObject::ProcessEvent(Func, &Parms);

	if (bIgnore != nullptr)
		*bIgnore = Parms.bIgnore;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.CheckDisableDirectDamage
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bDisableDirectDamage                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameProjectile_C::CheckDisableDirectDamage(class AActor* DamageCauser, bool* bDisableDirectDamage)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "CheckDisableDirectDamage");

	Params::BP_AJBInGameProjectile_C_CheckDisableDirectDamage Parms{};

	Parms.DamageCauser = DamageCauser;

	UObject::ProcessEvent(Func, &Parms);

	if (bDisableDirectDamage != nullptr)
		*bDisableDirectDamage = Parms.bDisableDirectDamage;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float*                                  Duration                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetDuration(float* Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetDuration");

	Params::BP_AJBInGameProjectile_C_GetDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Duration != nullptr)
		*Duration = Parms.Duration;
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetPassiveSkillTag
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag*                    PassiveSkillTag_0                                      (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetPassiveSkillTag(struct FGameplayTag* PassiveSkillTag_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetPassiveSkillTag");

	Params::BP_AJBInGameProjectile_C_GetPassiveSkillTag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PassiveSkillTag_0 != nullptr)
		*PassiveSkillTag_0 = std::move(Parms.PassiveSkillTag_0);
}


// Function BP_AJBInGameProjectile.BP_AJBInGameProjectile_C.GetCauserOwnerCharacterBP
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C**        CharacterBP                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameProjectile_C::GetCauserOwnerCharacterBP(class ABP_AJBInGameCharacter_C** CharacterBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameProjectile_C", "GetCauserOwnerCharacterBP");

	Params::BP_AJBInGameProjectile_C_GetCauserOwnerCharacterBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterBP != nullptr)
		*CharacterBP = Parms.CharacterBP;
}

}

