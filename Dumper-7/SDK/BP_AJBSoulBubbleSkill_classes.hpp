#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBSoulBubbleSkill

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "BP_AJBSkillBase_classes.hpp"
#include "AJB_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_AJBSoulBubbleSkill.BP_AJBSoulBubbleSkill_C
// 0x00D8 (0x02C0 - 0x01E8)
class UBP_AJBSoulBubbleSkill_C final : public UBP_AJBSkillBase_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_AJBSoulBubbleSkill_C;            // 0x01E8(0x0008)(Transient, DuplicateTransient)
	class AActor*                                 DamageCauserCache;                                 // 0x01F0(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           DamageTypeCache;                                   // 0x01F8(0x0008)(Edit, BlueprintVisible, Transient, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         SerialNumberCache;                                 // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AttackDistanceCache;                               // 0x0204(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         KilledCharacterIdCache;                            // 0x0208(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          WithSeparatedStandAttackCache;                     // 0x0209(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          HitEnemysSeparatedStandCache;                      // 0x020A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_20B[0x1];                                      // 0x020B(0x0001)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         UltimateSkillSerialNumberIfInEffectCache;          // 0x020C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          WasCriticalStateCache;                             // 0x0210(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_211[0x3];                                      // 0x0211(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DeadPlayerIDCache;                                 // 0x0214(0x0004)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UAnimMontage*                           LastHamonMontage;                                  // 0x0218(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         LastHamonSceneMaxTime_s_;                          // 0x0220(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	uint8                                         Pad_224[0x4];                                      // 0x0224(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           LastHamonParticleTag;                              // 0x0228(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class ABP_AJBInGameParticleEffect_C*          LastHamonParticle;                                 // 0x0230(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	struct FGameplayTag                           LastHamonSETag;                                    // 0x0238(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class UAkComponent*                           LastHamonSE;                                       // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           LastHamonVoiceTag;                                 // 0x0248(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         CreatingBubbleSceneMaxTime_s_;                     // 0x0250(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	float                                         MaxWaitTime_s_;                                    // 0x0254(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	class AActor*                                 SoulBubbleItem;                                    // 0x0258(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	bool                                          IsCompletedLastHamonMontage;                       // 0x0260(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	bool                                          HasActivatedValue;                                 // 0x0261(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	uint8                                         Pad_262[0x2];                                      // 0x0262(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         DamageRateToVampire___;                            // 0x0264(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsHamonRateEnabled;                                // 0x0268(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_269[0x3];                                      // 0x0269(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         StopLastHamonMontageBlendTime;                     // 0x026C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          WasSoulBubbleSpawned;                              // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	bool                                          IsCreatingBubbleTiming;                            // 0x0271(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	uint8                                         Pad_272[0x6];                                      // 0x0272(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FName                                   LastHamonAnim_DeathSection;                        // 0x0278(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class FName                                   LastHamonAnim_LastHamonSection;                    // 0x0280(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          IsLastHamonVoiceCalledValue;                       // 0x0288(0x0001)(Edit, BlueprintVisible, ZeroConstructor, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay)
	uint8                                         Pad_289[0x7];                                      // 0x0289(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SoulBubbleCameraType;                              // 0x0290(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           SignalTypeTag;                                     // 0x0298(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTagContainer                  KeepAfterDeathTagWithFloat;                        // 0x02A0(0x0020)(Edit, BlueprintVisible, DisableEditOnInstance)

public:
	void ExecuteUbergraph_BP_AJBSoulBubbleSkill(int32 EntryPoint);
	void MC_SnapDeathCameraToPlayerCamera(class UCameraComponent* DeathCamera, const struct FVector& NewLocation, const struct FRotator& NewRotation);
	void UnbindEventsOnRunning();
	void BindEventsOnRunning();
	void MC_OnSpawnBubble();
	void PutSignalPinForPair_Server();
	void ROC_PutSignalPin(class AActor* SoulBubbleItem_0);
	void PutSignalPin_WithOwner_OnOwner(class AActor* SoulBubbleItem_0);
	void MC_OnBeginState_Waiting();
	void KillImmidiately_Server(bool IsForcedWithoutBubble);
	void MC_CancelAllEffect();
	void ForceEnd_Server();
	void InactivateSoulBubbleSkill();
	void ActivateSoulBubbleSkill();
	void OnPairDead_Server(const struct FGameplayTag& DamageType, class AActor* DeadActor, class AActor* DamageCauser);
	void MC_OnEndState();
	void MC_OnBeginState_Death();
	void MC_OnBeginState_LastHamon(bool ShouldSkipDeathMotion);
	void OnStateDeath_Server();
	void CleanSkillObjects();
	void ROS_NotifyOnBeginCreatingBubbleScene();
	void ROS_NotifyOnBeginDeathScene();
	void TickState_Waiting(float DeltaSeconds);
	void BeginState_Waiting_Server();
	void StateTick_CreatingBubble(float DeltaSeconds);
	void EndState_Server();
	void BeginState_Death_Server();
	void BeginState_CreatingBubble_Server();
	void TickState(float DeltaSeconds);
	void BeginState_LastHamon_Server();
	void TickState_Ready(float DeltaSeconds);
	void OnOwnerSprinkleSP();
	void OnOwnerDied_Server(class AActor* DamageCauser, const struct FGameplayTag& DamageType, int32 SerialNumber_0, float AttackDistance, uint8 KilledCharacterId, bool WithSeparatedStandAttack, bool HitEnemysSeparatedStand, int32 UltimateSkillSerialNumberIfInEffect, bool WasCriticalState, int32 DeadPlayerId);
	void Pause_LastHamonActivatedParticle();
	void Resume_LastHamonActivatedParticle();
	void Play_LastHamonActivatedParticle();
	void End_LastHamonEffect();
	void Run_LastHamonEffect();
	void Clear_LastHamonEffect();
	void Play_SoulBubbleAnimation(bool ShouldSkipDeathMotion);
	void OnCompleted_3678079442FD5371BBA769BCEAFC03BC(class FName NotifyName);
	void OnBlendOut_3678079442FD5371BBA769BCEAFC03BC(class FName NotifyName);
	void OnInterrupted_3678079442FD5371BBA769BCEAFC03BC(class FName NotifyName);
	void OnNotifyBegin_3678079442FD5371BBA769BCEAFC03BC(class FName NotifyName);
	void OnNotifyEnd_3678079442FD5371BBA769BCEAFC03BC(class FName NotifyName);
	void ShouldSpawnSoulBubble(bool* ShouldSpawn);
	void GetSoulBubbleSpawnLocation(struct FVector* Location);
	void SpawnSoulBubble(class AActor** SpawnedSoulBubble);
	void IsBeginingLastHamonAvailable(bool* IsAvailable);
	void HasActivated(bool* HasActivated_0);
	void IsRunning(bool* IsRunning_0);
	void IsLastHamonVoiceCalled(bool* IsLastHamonVoiceCalled_0);
	void RiseIsLastHamonVoiceCalledFlag(bool Value);
	void GetVampireDamageRate(float* VampireDamageRate);
	void ShouldApplyHamonRateDirectly(bool* ShouldApplyDirectly);
	void IsHamonRateEnabledSkill(bool* IsEnabled);
	void StateBeginPlay(bool bShouldRestore);
	void OnCancel();
	void OnActive();
	void OnInactive();
	void ReceiveTick(float DeltaSeconds);
	void NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty);
	void ApplySkillParameter();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_AJBSoulBubbleSkill_C">();
	}
	static class UBP_AJBSoulBubbleSkill_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_AJBSoulBubbleSkill_C>();
	}
};
static_assert(alignof(UBP_AJBSoulBubbleSkill_C) == 0x000008, "Wrong alignment on UBP_AJBSoulBubbleSkill_C");
static_assert(sizeof(UBP_AJBSoulBubbleSkill_C) == 0x0002C0, "Wrong size on UBP_AJBSoulBubbleSkill_C");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, UberGraphFrame_BP_AJBSoulBubbleSkill_C) == 0x0001E8, "Member 'UBP_AJBSoulBubbleSkill_C::UberGraphFrame_BP_AJBSoulBubbleSkill_C' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, DamageCauserCache) == 0x0001F0, "Member 'UBP_AJBSoulBubbleSkill_C::DamageCauserCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, DamageTypeCache) == 0x0001F8, "Member 'UBP_AJBSoulBubbleSkill_C::DamageTypeCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, SerialNumberCache) == 0x000200, "Member 'UBP_AJBSoulBubbleSkill_C::SerialNumberCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, AttackDistanceCache) == 0x000204, "Member 'UBP_AJBSoulBubbleSkill_C::AttackDistanceCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, KilledCharacterIdCache) == 0x000208, "Member 'UBP_AJBSoulBubbleSkill_C::KilledCharacterIdCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, WithSeparatedStandAttackCache) == 0x000209, "Member 'UBP_AJBSoulBubbleSkill_C::WithSeparatedStandAttackCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, HitEnemysSeparatedStandCache) == 0x00020A, "Member 'UBP_AJBSoulBubbleSkill_C::HitEnemysSeparatedStandCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, UltimateSkillSerialNumberIfInEffectCache) == 0x00020C, "Member 'UBP_AJBSoulBubbleSkill_C::UltimateSkillSerialNumberIfInEffectCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, WasCriticalStateCache) == 0x000210, "Member 'UBP_AJBSoulBubbleSkill_C::WasCriticalStateCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, DeadPlayerIDCache) == 0x000214, "Member 'UBP_AJBSoulBubbleSkill_C::DeadPlayerIDCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonMontage) == 0x000218, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonMontage' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonSceneMaxTime_s_) == 0x000220, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonSceneMaxTime_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonParticleTag) == 0x000228, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonParticleTag' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonParticle) == 0x000230, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonParticle' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonSETag) == 0x000238, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonSETag' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonSE) == 0x000240, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonSE' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonVoiceTag) == 0x000248, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonVoiceTag' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, CreatingBubbleSceneMaxTime_s_) == 0x000250, "Member 'UBP_AJBSoulBubbleSkill_C::CreatingBubbleSceneMaxTime_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, MaxWaitTime_s_) == 0x000254, "Member 'UBP_AJBSoulBubbleSkill_C::MaxWaitTime_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, SoulBubbleItem) == 0x000258, "Member 'UBP_AJBSoulBubbleSkill_C::SoulBubbleItem' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, IsCompletedLastHamonMontage) == 0x000260, "Member 'UBP_AJBSoulBubbleSkill_C::IsCompletedLastHamonMontage' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, HasActivatedValue) == 0x000261, "Member 'UBP_AJBSoulBubbleSkill_C::HasActivatedValue' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, DamageRateToVampire___) == 0x000264, "Member 'UBP_AJBSoulBubbleSkill_C::DamageRateToVampire___' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, IsHamonRateEnabled) == 0x000268, "Member 'UBP_AJBSoulBubbleSkill_C::IsHamonRateEnabled' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, StopLastHamonMontageBlendTime) == 0x00026C, "Member 'UBP_AJBSoulBubbleSkill_C::StopLastHamonMontageBlendTime' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, WasSoulBubbleSpawned) == 0x000270, "Member 'UBP_AJBSoulBubbleSkill_C::WasSoulBubbleSpawned' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, IsCreatingBubbleTiming) == 0x000271, "Member 'UBP_AJBSoulBubbleSkill_C::IsCreatingBubbleTiming' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonAnim_DeathSection) == 0x000278, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonAnim_DeathSection' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, LastHamonAnim_LastHamonSection) == 0x000280, "Member 'UBP_AJBSoulBubbleSkill_C::LastHamonAnim_LastHamonSection' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, IsLastHamonVoiceCalledValue) == 0x000288, "Member 'UBP_AJBSoulBubbleSkill_C::IsLastHamonVoiceCalledValue' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, SoulBubbleCameraType) == 0x000290, "Member 'UBP_AJBSoulBubbleSkill_C::SoulBubbleCameraType' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, SignalTypeTag) == 0x000298, "Member 'UBP_AJBSoulBubbleSkill_C::SignalTypeTag' has a wrong offset!");
static_assert(offsetof(UBP_AJBSoulBubbleSkill_C, KeepAfterDeathTagWithFloat) == 0x0002A0, "Member 'UBP_AJBSoulBubbleSkill_C::KeepAfterDeathTagWithFloat' has a wrong offset!");

}

