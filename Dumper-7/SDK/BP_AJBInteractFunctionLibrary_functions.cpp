#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBInteractFunctionLibrary

#include "Basic.hpp"

#include "BP_AJBInteractFunctionLibrary_classes.hpp"
#include "BP_AJBInteractFunctionLibrary_parameters.hpp"


namespace SDK
{

// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.FindInteractLocationForZipper
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Start                                                  (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxGapWidth                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTagContainer&     DesiredInteractType                                    (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag*                    DecidedInteractType                                    (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// struct FTransform*                      FirstTransform                                         (Parm, OutParm, IsPlainOldData, NoDestructor)
// struct FVector*                         SecondLocation                                         (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         LocationOfInjectionCounterpart                         (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         LocationOfInjectionOrigin                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          HitActor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent**             HitComponent                                           (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBInteractFunctionLibrary_C::FindInteractLocationForZipper(const struct FVector& Start, const struct FVector& End, float MaxGapWidth, const struct FGameplayTagContainer& DesiredInteractType, class UObject* __WorldContext, struct FGameplayTag* DecidedInteractType, struct FTransform* FirstTransform, struct FVector* SecondLocation, struct FVector* LocationOfInjectionCounterpart, struct FVector* LocationOfInjectionOrigin, class AActor** HitActor, class UPrimitiveComponent** HitComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "FindInteractLocationForZipper");

	Params::BP_AJBInteractFunctionLibrary_C_FindInteractLocationForZipper Parms{};

	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.MaxGapWidth = MaxGapWidth;
	Parms.DesiredInteractType = std::move(DesiredInteractType);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DecidedInteractType != nullptr)
		*DecidedInteractType = std::move(Parms.DecidedInteractType);

	if (FirstTransform != nullptr)
		*FirstTransform = std::move(Parms.FirstTransform);

	if (SecondLocation != nullptr)
		*SecondLocation = std::move(Parms.SecondLocation);

	if (LocationOfInjectionCounterpart != nullptr)
		*LocationOfInjectionCounterpart = std::move(Parms.LocationOfInjectionCounterpart);

	if (LocationOfInjectionOrigin != nullptr)
		*LocationOfInjectionOrigin = std::move(Parms.LocationOfInjectionOrigin);

	if (HitActor != nullptr)
		*HitActor = Parms.HitActor;

	if (HitComponent != nullptr)
		*HitComponent = Parms.HitComponent;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.TestIfInteractableComponentHit
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FHitResult&                HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// const struct FGameplayTagContainer&     InteractTypesToCheck                                   (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
// struct FGameplayTag*                    InteractResult                                         (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

bool UBP_AJBInteractFunctionLibrary_C::TestIfInteractableComponentHit(const struct FHitResult& HitResult, const struct FGameplayTagContainer& InteractTypesToCheck, class UObject* __WorldContext, struct FGameplayTag* InteractResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "TestIfInteractableComponentHit");

	Params::BP_AJBInteractFunctionLibrary_C_TestIfInteractableComponentHit Parms{};

	Parms.HitResult = std::move(HitResult);
	Parms.InteractTypesToCheck = std::move(InteractTypesToCheck);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (InteractResult != nullptr)
		*InteractResult = std::move(Parms.InteractResult);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.IsInteractableComponent
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UPrimitiveComponent*              Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTagContainer&     InteractTypes                                          (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
// struct FGameplayTag*                    InteractResult                                         (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

bool UBP_AJBInteractFunctionLibrary_C::IsInteractableComponent(class UPrimitiveComponent* Component, const struct FGameplayTagContainer& InteractTypes, class UObject* __WorldContext, struct FGameplayTag* InteractResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "IsInteractableComponent");

	Params::BP_AJBInteractFunctionLibrary_C_IsInteractableComponent Parms{};

	Parms.Component = Component;
	Parms.InteractTypes = std::move(InteractTypes);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (InteractResult != nullptr)
		*InteractResult = std::move(Parms.InteractResult);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.GetValidStaticMeshFromComponent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UActorComponent*                  Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UStaticMesh**                     StaticMesh                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_AJBInteractFunctionLibrary_C::GetValidStaticMeshFromComponent(class UActorComponent* Component, class UObject* __WorldContext, class UStaticMesh** StaticMesh)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "GetValidStaticMeshFromComponent");

	Params::BP_AJBInteractFunctionLibrary_C_GetValidStaticMeshFromComponent Parms{};

	Parms.Component = Component;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (StaticMesh != nullptr)
		*StaticMesh = Parms.StaticMesh;

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.HasValidGameplayTag
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UStaticMesh*                      StaticMesh                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTagContainer&     InteractTypes                                          (BlueprintVisible, BlueprintReadOnly, Parm)
// const struct FGameplayTag&              TargetInteractType                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)
// struct FGameplayTag*                    OutInteractType                                        (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

bool UBP_AJBInteractFunctionLibrary_C::HasValidGameplayTag(class UStaticMesh* StaticMesh, const struct FGameplayTagContainer& InteractTypes, const struct FGameplayTag& TargetInteractType, class UObject* __WorldContext, struct FGameplayTag* OutInteractType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "HasValidGameplayTag");

	Params::BP_AJBInteractFunctionLibrary_C_HasValidGameplayTag Parms{};

	Parms.StaticMesh = StaticMesh;
	Parms.InteractTypes = std::move(InteractTypes);
	Parms.TargetInteractType = std::move(TargetInteractType);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutInteractType != nullptr)
		*OutInteractType = std::move(Parms.OutInteractType);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.Box2DContainsBox2D
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FBox2D&                    BoxOuter                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FBox2D&                    BoxInner                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_AJBInteractFunctionLibrary_C::Box2DContainsBox2D(const struct FBox2D& BoxOuter, const struct FBox2D& BoxInner, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "Box2DContainsBox2D");

	Params::BP_AJBInteractFunctionLibrary_C_Box2DContainsBox2D Parms{};

	Parms.BoxOuter = std::move(BoxOuter);
	Parms.BoxInner = std::move(BoxInner);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.Box2DContainsPosition2D
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FBox2D&                    Box                                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FVector2D&                 Position                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_AJBInteractFunctionLibrary_C::Box2DContainsPosition2D(const struct FBox2D& Box, const struct FVector2D& Position, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "Box2DContainsPosition2D");

	Params::BP_AJBInteractFunctionLibrary_C_Box2DContainsPosition2D Parms{};

	Parms.Box = std::move(Box);
	Parms.Position = std::move(Position);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.TransformBox
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FBox&                      Box                                                    (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// const struct FTransform&                Transform                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FTransform*                      NewParam2                                              (Parm, OutParm, IsPlainOldData, NoDestructor)

void UBP_AJBInteractFunctionLibrary_C::TransformBox(const struct FBox& Box, const struct FTransform& Transform, class UObject* __WorldContext, struct FTransform* NewParam2)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "TransformBox");

	Params::BP_AJBInteractFunctionLibrary_C_TransformBox Parms{};

	Parms.Box = std::move(Box);
	Parms.Transform = std::move(Transform);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewParam2 != nullptr)
		*NewParam2 = std::move(Parms.NewParam2);
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.FindTraceLocationsFromPlayerCamera
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGamePlayerController_C*  PlayerController                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   InteractingActorLocation                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceDistanceStartFromCamera                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceDistanceEndFromCamera                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bTraceable                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector*                         TraceStartLocation                                     (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         TraceEndLocation                                       (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBInteractFunctionLibrary_C::FindTraceLocationsFromPlayerCamera(class ABP_AJBInGamePlayerController_C* PlayerController, const struct FVector& InteractingActorLocation, float TraceDistanceStartFromCamera, float TraceDistanceEndFromCamera, float TraceRadius, class UObject* __WorldContext, bool* bTraceable, struct FVector* TraceStartLocation, struct FVector* TraceEndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "FindTraceLocationsFromPlayerCamera");

	Params::BP_AJBInteractFunctionLibrary_C_FindTraceLocationsFromPlayerCamera Parms{};

	Parms.PlayerController = PlayerController;
	Parms.InteractingActorLocation = std::move(InteractingActorLocation);
	Parms.TraceDistanceStartFromCamera = TraceDistanceStartFromCamera;
	Parms.TraceDistanceEndFromCamera = TraceDistanceEndFromCamera;
	Parms.TraceRadius = TraceRadius;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bTraceable != nullptr)
		*bTraceable = Parms.bTraceable;

	if (TraceStartLocation != nullptr)
		*TraceStartLocation = std::move(Parms.TraceStartLocation);

	if (TraceEndLocation != nullptr)
		*TraceEndLocation = std::move(Parms.TraceEndLocation);
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.GetRadiusOfLargestCharacter
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UBP_AJBInteractFunctionLibrary_C::GetRadiusOfLargestCharacter(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "GetRadiusOfLargestCharacter");

	Params::BP_AJBInteractFunctionLibrary_C_GetRadiusOfLargestCharacter Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.IsInteractableHitAtFront
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   FrontVector                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FHitResult&                HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_AJBInteractFunctionLibrary_C::IsInteractableHitAtFront(const struct FVector& FrontVector, const struct FHitResult& HitResult, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "IsInteractableHitAtFront");

	Params::BP_AJBInteractFunctionLibrary_C_IsInteractableHitAtFront Parms{};

	Parms.FrontVector = std::move(FrontVector);
	Parms.HitResult = std::move(HitResult);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.IsInteractableDirection
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           InteractTarget                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AngleFromForwardVector                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UBP_AJBInteractFunctionLibrary_C::IsInteractableDirection(class ABP_AJBInGameCharacter_C* Character, class AActor* InteractTarget, float AngleFromForwardVector, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "IsInteractableDirection");

	Params::BP_AJBInteractFunctionLibrary_C_IsInteractableDirection Parms{};

	Parms.Character = Character;
	Parms.InteractTarget = InteractTarget;
	Parms.AngleFromForwardVector = AngleFromForwardVector;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.GetHalfHeightOfLargestCharacter
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

float UBP_AJBInteractFunctionLibrary_C::GetHalfHeightOfLargestCharacter(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "GetHalfHeightOfLargestCharacter");

	Params::BP_AJBInteractFunctionLibrary_C_GetHalfHeightOfLargestCharacter Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.AdjustLocationOfZipperInjection
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    AdjustOrigin                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32                                   TrialNum                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InInteractionBuffer                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   CounterpartBaseWorldLocation                           (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   CounterpartForwardVector                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDebug                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bFound                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector*                         Location                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBInteractFunctionLibrary_C::AdjustLocationOfZipperInjection(bool AdjustOrigin, int32 TrialNum, float InInteractionBuffer, const struct FVector& CounterpartBaseWorldLocation, const struct FVector& CounterpartForwardVector, bool bDebug, class UObject* __WorldContext, bool* bFound, struct FVector* Location)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "AdjustLocationOfZipperInjection");

	Params::BP_AJBInteractFunctionLibrary_C_AdjustLocationOfZipperInjection Parms{};

	Parms.AdjustOrigin = AdjustOrigin;
	Parms.TrialNum = TrialNum;
	Parms.InInteractionBuffer = InInteractionBuffer;
	Parms.CounterpartBaseWorldLocation = std::move(CounterpartBaseWorldLocation);
	Parms.CounterpartForwardVector = std::move(CounterpartForwardVector);
	Parms.bDebug = bDebug;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bFound != nullptr)
		*bFound = Parms.bFound;

	if (Location != nullptr)
		*Location = std::move(Parms.Location);
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.FindTraceLocationsFromCharacterCamera
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   InteractingActorLocation                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceDistanceStartFromCamera                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceDistanceEndFromCamera                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceRadius                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bTraceable                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector*                         TraceStartLocation                                     (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         TraceEndLocation                                       (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBInteractFunctionLibrary_C::FindTraceLocationsFromCharacterCamera(class ABP_AJBInGameCharacter_C* Character, const struct FVector& InteractingActorLocation, float TraceDistanceStartFromCamera, float TraceDistanceEndFromCamera, float TraceRadius, class UObject* __WorldContext, bool* bTraceable, struct FVector* TraceStartLocation, struct FVector* TraceEndLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "FindTraceLocationsFromCharacterCamera");

	Params::BP_AJBInteractFunctionLibrary_C_FindTraceLocationsFromCharacterCamera Parms{};

	Parms.Character = Character;
	Parms.InteractingActorLocation = std::move(InteractingActorLocation);
	Parms.TraceDistanceStartFromCamera = TraceDistanceStartFromCamera;
	Parms.TraceDistanceEndFromCamera = TraceDistanceEndFromCamera;
	Parms.TraceRadius = TraceRadius;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bTraceable != nullptr)
		*bTraceable = Parms.bTraceable;

	if (TraceStartLocation != nullptr)
		*TraceStartLocation = std::move(Parms.TraceStartLocation);

	if (TraceEndLocation != nullptr)
		*TraceEndLocation = std::move(Parms.TraceEndLocation);
}


// Function BP_AJBInteractFunctionLibrary.BP_AJBInteractFunctionLibrary_C.GetPoliticWallDepth
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UActorComponent*                  Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  WallDepth                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBInteractFunctionLibrary_C::GetPoliticWallDepth(class UActorComponent* Component, class UObject* __WorldContext, float* WallDepth)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("BP_AJBInteractFunctionLibrary_C", "GetPoliticWallDepth");

	Params::BP_AJBInteractFunctionLibrary_C_GetPoliticWallDepth Parms{};

	Parms.Component = Component;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (WallDepth != nullptr)
		*WallDepth = Parms.WallDepth;
}

}

