#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AJB

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "Engine_structs.hpp"
#include "InputCore_structs.hpp"
#undef NO_ERROR


namespace SDK
{

// Enum AJB.EAJBNetAPIResult
// NumValues: 0x001E
enum class EAJBNetAPIResult : uint8
{
	OK                                       = 0,
	NG                                       = 1,
	MAINTENANCE                              = 2,
	SESSION_NG                               = 3,
	SESSION_TIMEOUT                          = 4,
	VERSION_INVALID                          = 5,
	REQEST_ERROR                             = 6,
	USER_ID                                  = 7,
	PARAMETER_EXIST                          = 8,
	PARAMETER_TYPE                           = 9,
	NUMBER_LLIMIT                            = 10,
	NUMBER_ULIMIT                            = 11,
	STRLEN_LLIMIT                            = 12,
	STRLEN_ULIMIT                            = 13,
	CHAR_TYPE                                = 14,
	NG_WORD                                  = 15,
	BLACK_LIST_USER                          = 16,
	LOGIN_DUPLICATE                          = 17,
	UID_DUPLICATE                            = 18,
	AMID_DUPLICATE                           = 19,
	HTTP_ERROR_HOST_NOT_FOUND                = 20,
	HTTP_ERROR_TIMEOUT                       = 21,
	HTTP_ERROR_OTHER                         = 22,
	UENET_ERROR_CONNECTION_LOST              = 23,
	UENET_ERROR_CONNECTION_TIMEOUT           = 24,
	UENET_ERROR_OTHER                        = 25,
	FAILD_MATCHING                           = 26,
	NOT_HELD_MATHING                         = 27,
	APPVERSION_NOT_LATEST                    = 28,
	EAJBNetAPIResult_MAX                     = 29,
};

// Enum AJB.ERewardItemType
// NumValues: 0x000A
enum class ERewardItemType : uint8
{
	Ticket                                   = 0,
	CharacterSkin                            = 1,
	StandSkin                                = 2,
	EmotePose                                = 3,
	EmoteVoice                               = 4,
	PlayerIcon                               = 5,
	PlayerTitle                              = 6,
	Coin                                     = 7,
	ProfileCard                              = 8,
	ERewardItemType_MAX                      = 9,
};

// Enum AJB.EAJBBNCardStatus
// NumValues: 0x0008
enum class EAJBBNCardStatus : uint8
{
	Normal                                   = 0,
	BrandNew                                 = 1,
	Ban                                      = 2,
	CardLock                                 = 3,
	NotSupport                               = 4,
	AJBBan                                   = 5,
	Error                                    = 99,
	EAJBBNCardStatus_MAX                     = 100,
};

// Enum AJB.EGameRewardType
// NumValues: 0x0004
enum class EGameRewardType : uint8
{
	MatchResult                              = 0,
	LevelUp                                  = 1,
	Achieve                                  = 2,
	EGameRewardType_MAX                      = 3,
};

// Enum AJB.ERewardCategory
// NumValues: 0x0004
enum class ERewardCategory : uint8
{
	None                                     = 0,
	PreReleased                              = 1,
	ChallengeOnly                            = 2,
	ERewardCategory_MAX                      = 3,
};

// Enum AJB.EAJBLimitedBounusSign
// NumValues: 0x0003
enum class EAJBLimitedBounusSign : uint8
{
	PLUS                                     = 0,
	MULTIPLY                                 = 1,
	EAJBLimitedBounusSign_MAX                = 2,
};

// Enum AJB.EPlayMode
// NumValues: 0x000C
enum class EPlayMode : uint8
{
	None                                     = 0,
	Solo                                     = 1,
	Pair                                     = 2,
	Shop                                     = 3,
	ShopCompetition                          = 4,
	Tutorial                                 = 5,
	Training                                 = 6,
	ShopCompetitionPair                      = 7,
	ShopExchange                             = 8,
	PVESolo                                  = 9,
	PVEPair                                  = 10,
	EPlayMode_MAX                            = 11,
};

// Enum AJB.EAJBRewardReceivingStatus
// NumValues: 0x0007
enum class EAJBRewardReceivingStatus : uint8
{
	Success                                  = 0,
	Failed_LackOfTicket                      = 1,
	Failed_Guest                             = 2,
	Failed_GachaID                           = 3,
	Already                                  = 4,
	Failed_NetError                          = 255,
	EAJBRewardReceivingStatus_MAX            = 256,
};

// Enum AJB.EAJBGachaType
// NumValues: 0x0004
enum class EAJBGachaType : uint8
{
	Unknown                                  = 0,
	LuckyDraw                                = 1,
	PremiumDraw                              = 2,
	EAJBGachaType_MAX                        = 3,
};

// Enum AJB.EAJBFadeType
// NumValues: 0x0003
enum class EAJBFadeType : uint8
{
	FadeIn                                   = 0,
	FadeOut                                  = 1,
	EAJBFadeType_MAX                         = 2,
};

// Enum AJB.EAJBInputMode
// NumValues: 0x0007
enum class EAJBInputMode : uint8
{
	None                                     = 0,
	InGame                                   = 1,
	UI                                       = 2,
	InGameAndUI                              = 3,
	VictoryShot                              = 4,
	EmoteSelect                              = 5,
	EAJBInputMode_MAX                        = 6,
};

// Enum AJB.EStandAccompanyTransition
// NumValues: 0x0005
enum class EStandAccompanyTransition : uint8
{
	NotAccompany                             = 0,
	ForwardAccompany                         = 1,
	Accompany                                = 2,
	BackwardAccompany                        = 3,
	EStandAccompanyTransition_MAX            = 4,
};

// Enum AJB.EAJBBoardLEDPattern
// NumValues: 0x0005
enum class EAJBBoardLEDPattern : uint8
{
	Normal                                   = 0,
	Alive                                    = 1,
	Retire                                   = 2,
	ALLOff                                   = 3,
	EAJBBoardLEDPattern_MAX                  = 4,
};

// Enum AJB.EAMStatus
// NumValues: 0x0006
enum class EAMStatus : uint8
{
	SystemCheck                              = 0,
	TestMode                                 = 1,
	NOTICE                                   = 2,
	Attract                                  = 3,
	GamePlaying                              = 4,
	EAMStatus_MAX                            = 5,
};

// Enum AJB.ECloseScheduleType
// NumValues: 0x0004
enum class ECloseScheduleType : uint8
{
	WEEK                                     = 0,
	DAY                                      = 1,
	OFF                                      = 2,
	ECloseScheduleType_MAX                   = 3,
};

// Enum AJB.EShopEventPlayerType
// NumValues: 0x0003
enum class EShopEventPlayerType : uint8
{
	PLAYER                                   = 0,
	CAMERA                                   = 1,
	EShopEventPlayerType_MAX                 = 2,
};

// Enum AJB.EExtraPPKind
// NumValues: 0x0003
enum class EExtraPPKind : uint8
{
	NONE                                     = 0,
	EXTRAPP                                  = 1,
	EExtraPPKind_MAX                         = 2,
};

// Enum AJB.EPurchaseLimitPP
// NumValues: 0x0007
enum class EPurchaseLimitPP : uint8
{
	None                                     = 0,
	Credit3                                  = 1,
	Credit5                                  = 2,
	Credit6                                  = 3,
	Credit7                                  = 4,
	Credit8                                  = 5,
	EPurchaseLimitPP_MAX                     = 6,
};

// Enum AJB.EAJBArcadeAdditionalCreditState
// NumValues: 0x0003
enum class EAJBArcadeAdditionalCreditState : uint8
{
	Available                                = 0,
	AlreadyPurchased                         = 1,
	EAJBArcadeAdditionalCreditState_MAX      = 2,
};

// Enum AJB.EAJBClosedAlertArcadeTimeBuyPPType
// NumValues: 0x0005
enum class EAJBClosedAlertArcadeTimeBuyPPType : uint8
{
	None                                     = 0,
	LimitPossessionNum                       = 1,
	LimitCredit                              = 2,
	CanNotBuy                                = 3,
	EAJBClosedAlertArcadeTimeBuyPPType_MAX   = 4,
};

// Enum AJB.EAJBDayOfWeek
// NumValues: 0x0009
enum class EAJBDayOfWeek : uint8
{
	Monday                                   = 0,
	Tuesday                                  = 1,
	Wednesday                                = 2,
	Thursday                                 = 3,
	Friday                                   = 4,
	Saturday                                 = 5,
	Sunday                                   = 6,
	Num                                      = 7,
	EAJBDayOfWeek_MAX                        = 8,
};

// Enum AJB.EAJBErrorID
// NumValues: 0x0024
enum class EAJBErrorID : uint8
{
	COIN_ERROR_1                             = 0,
	COIN_ERROR_2                             = 1,
	IO_PCB_ERROR_1                           = 2,
	IO_PCB_ERROR_2                           = 3,
	CONTENT_ROUTER_DISCONNECT                = 4,
	CONTENT_ROUTER_MISMATCH                  = 5,
	NETWORK_DISCONNECT                       = 6,
	ALLNET_LIB_UNINITIALIZED                 = 7,
	ALLNET_TIP_TIMEOUT                       = 8,
	ALLNET_DNS_TIMEOUT                       = 9,
	ALLNET_AUTH_ERROR                        = 10,
	ALLNET_AUTH_TIMEOUT                      = 11,
	GAME_SERVER_DNS_TIMEOUT                  = 12,
	GAME_SERVER_ERROR                        = 13,
	GAME_SERVER_TIMEOUT                      = 14,
	UPDATE_SERVER_DNS_TIMEOUT                = 15,
	UPDATE_SERVER_AUTH_ERROR                 = 16,
	UPDATE_SERVER_AUTH_TIMEOUT               = 17,
	FIRST_AUTH_ERROR                         = 18,
	OFFLINE_UPTIME_ERROR                     = 19,
	CARD_RW_DISCONNECT                       = 20,
	CARD_RW_VFD_ERROR                        = 21,
	CARD_RW_SYSTEM_ERROR                     = 22,
	SYSTEM_DONGLE_DISCONNECT                 = 23,
	SYSTEM_DONGLE_OTHER                      = 24,
	DONGLE_ERROR_19_11                       = 25,
	SYSTEM_ERROR_19_21                       = 26,
	SYSTEM_ERROR_19_22                       = 27,
	SYSTEM_ERROR_19_23                       = 28,
	SYSTEM_ERROR_19_24                       = 29,
	SYSTEM_ERROR_19_25                       = 30,
	VERSION_UP_ERROR_1                       = 31,
	FIRST_POWER_ON                           = 32,
	TOUCH_PANEL_DISCONNECT                   = 33,
	NO_ERROR                                 = 34,
	EAJBErrorID_MAX                          = 35,
};

// Enum AJB.EAJBModePassiveState
// NumValues: 0x0005
enum class EAJBModePassiveState : uint8
{
	None                                     = 0,
	Starting                                 = 1,
	Active                                   = 2,
	Finishing                                = 3,
	EAJBModePassiveState_MAX                 = 4,
};

// Enum AJB.EAJBKnockbackStrategy
// NumValues: 0x0003
enum class EAJBKnockbackStrategy : uint8
{
	LaunchCharacter                          = 0,
	AddImpulse                               = 1,
	EAJBKnockbackStrategy_MAX                = 2,
};

// Enum AJB.EAJBAISkillInputType
// NumValues: 0x0006
enum class EAJBAISkillInputType : uint8
{
	L1Trigger                                = 0,
	R1Trigger                                = 1,
	R2Trigger                                = 2,
	R2Hold                                   = 3,
	R2Release                                = 4,
	EAJBAISkillInputType_MAX                 = 5,
};

// Enum AJB.EAJBWindowAccessType
// NumValues: 0x0003
enum class EAJBWindowAccessType : uint8
{
	Break                                    = 0,
	Through                                  = 1,
	EAJBWindowAccessType_MAX                 = 2,
};

// Enum AJB.EAJBCharacterPropertyType
// NumValues: 0x0004
enum class EAJBCharacterPropertyType : uint8
{
	None                                     = 0,
	Auto                                     = 1,
	Transfer                                 = 2,
	EAJBCharacterPropertyType_MAX            = 3,
};

// Enum AJB.ESHABehavior
// NumValues: 0x0006
enum class ESHABehavior : uint8
{
	None                                     = 0,
	Loitering                                = 1,
	Triggering                               = 2,
	Bombing                                  = 3,
	Clearing                                 = 4,
	ESHABehavior_MAX                         = 5,
};

// Enum AJB.ESnakeBulletState
// NumValues: 0x0006
enum class ESnakeBulletState : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	HomingDetection                          = 2,
	AdditionalCheck                          = 3,
	Homing                                   = 4,
	ESnakeBulletState_MAX                    = 5,
};

// Enum AJB.EAutoHealingState
// NumValues: 0x0004
enum class EAutoHealingState : uint8
{
	None                                     = 0,
	Continuation                             = 1,
	Stopping                                 = 2,
	EAutoHealingState_MAX                    = 3,
};

// Enum AJB.EPlacementState
// NumValues: 0x0006
enum class EPlacementState : uint8
{
	None                                     = 0,
	Prepare                                  = 1,
	Standby                                  = 2,
	Triggering                               = 3,
	Clearing                                 = 4,
	EPlacementState_MAX                      = 5,
};

// Enum AJB.EECHState
// NumValues: 0x0004
enum class EECHState : uint8
{
	ACT1                                     = 0,
	ACT2                                     = 1,
	ACT3                                     = 2,
	EECHState_MAX                            = 3,
};

// Enum AJB.EMovableStandSXPState
// NumValues: 0x0005
enum class EMovableStandSXPState : uint8
{
	None                                     = 0,
	Loitering                                = 1,
	Kicking                                  = 2,
	Waiting                                  = 3,
	EMovableStandSXPState_MAX                = 4,
};

// Enum AJB.EInteractCloudBarrierErrorType
// NumValues: 0x0004
enum class EInteractCloudBarrierErrorType : uint8
{
	None                                     = 0,
	TorrentialRain                           = 1,
	IronsandCamouflage                       = 2,
	EInteractCloudBarrierErrorType_MAX       = 3,
};

// Enum AJB.EInteractRuthlessBloodsuckErrorType
// NumValues: 0x0003
enum class EInteractRuthlessBloodsuckErrorType : uint8
{
	None                                     = 0,
	AlreadyInteracted                        = 1,
	EInteractRuthlessBloodsuckErrorType_MAX  = 2,
};

// Enum AJB.EInteractMemoryLeakErrorType
// NumValues: 0x0004
enum class EInteractMemoryLeakErrorType : uint8
{
	None                                     = 0,
	AlreadyInteracted                        = 1,
	BuffLimit                                = 2,
	EInteractMemoryLeakErrorType_MAX         = 3,
};

// Enum AJB.ELongPressInteractType
// NumValues: 0x0007
enum class ELongPressInteractType : uint8
{
	None                                     = 0,
	HelpFriend                               = 1,
	MemoryLeak                               = 2,
	CrazyHeal                                = 3,
	PartsMaker                               = 4,
	RuthlessBloodsuck                        = 5,
	ELongPressInteractType_MAX               = 6,
};

// Enum AJB.EInteractSkillState
// NumValues: 0x0006
enum class EInteractSkillState : uint8
{
	None                                     = 0,
	InteractWithZipper                       = 1,
	BlockingNextInteraction                  = 2,
	HidingInZipper                           = 3,
	WaitingLongPress                         = 4,
	EInteractSkillState_MAX                  = 5,
};

// Enum AJB.EVolareBombProjectileState
// NumValues: 0x0004
enum class EVolareBombProjectileState : uint8
{
	None                                     = 0,
	Falling                                  = 1,
	Clearing                                 = 2,
	EVolareBombProjectileState_MAX           = 3,
};

// Enum AJB.ECO2ScanAffecterState
// NumValues: 0x0005
enum class ECO2ScanAffecterState : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Active                                   = 2,
	Clearing                                 = 3,
	ECO2ScanAffecterState_MAX                = 4,
};

// Enum AJB.EDamageImpulseState
// NumValues: 0x0005
enum class EDamageImpulseState : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Active                                   = 2,
	Clearing                                 = 3,
	EDamageImpulseState_MAX                  = 4,
};

// Enum AJB.ETheWorldState
// NumValues: 0x0005
enum class ETheWorldState : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Active                                   = 2,
	Clearing                                 = 3,
	ETheWorldState_MAX                       = 4,
};

// Enum AJB.EBitesTheDustAffecterState
// NumValues: 0x0008
enum class EBitesTheDustAffecterState : uint8
{
	None                                     = 0,
	PreBomb                                  = 1,
	Bomb                                     = 2,
	PreFade                                  = 3,
	FadeOut                                  = 4,
	Fade                                     = 5,
	FadeIn                                   = 6,
	EBitesTheDustAffecterState_MAX           = 7,
};

// Enum AJB.ESkillAffecterState
// NumValues: 0x0005
enum class ESkillAffecterState : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Active                                   = 2,
	Clearing                                 = 3,
	ESkillAffecterState_MAX                  = 4,
};

// Enum AJB.EMovableStandTransferState
// NumValues: 0x0005
enum class EMovableStandTransferState : uint8
{
	None                                     = 0,
	Transfer                                 = 1,
	Action                                   = 2,
	Waiting                                  = 3,
	EMovableStandTransferState_MAX           = 4,
};

// Enum AJB.ESkillState_Transfer
// NumValues: 0x000A
enum class ESkillState_Transfer : uint8
{
	None                                     = 0,
	ReadyWaiting                             = 1,
	Preview                                  = 2,
	Ready                                    = 3,
	Transfer                                 = 4,
	ActionWaiting                            = 5,
	Action                                   = 6,
	Action2                                  = 7,
	Clearing                                 = 8,
	ESkillState_MAX                          = 9,
};

// Enum AJB.EWallClimbState
// NumValues: 0x0005
enum class EWallClimbState : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	Clearing                                 = 3,
	EWallClimbState_MAX                      = 4,
};

// Enum AJB.EMovableStandDDWState
// NumValues: 0x0005
enum class EMovableStandDDWState : uint8
{
	None                                     = 0,
	Loitering                                = 1,
	Rush                                     = 2,
	Waiting                                  = 3,
	EMovableStandDDWState_MAX                = 4,
};

// Enum AJB.ESkillState_Sprint
// NumValues: 0x0005
enum class ESkillState_Sprint : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	Clearing                                 = 3,
	ESkillState_MAX                          = 4,
};

// Enum AJB.ESkillState_ChargeAttack
// NumValues: 0x0007
enum class ESkillState_ChargeAttack : uint8
{
	None                                     = 0,
	Dash                                     = 1,
	HitWait                                  = 2,
	BackToPlayer                             = 3,
	AccompanyWait                            = 4,
	Charging                                 = 5,
	ESkillState_MAX                          = 6,
};

// Enum AJB.EAJBLockOnState
// NumValues: 0x0006
enum class EAJBLockOnState : uint8
{
	None                                     = 0,
	PreLockOn                                = 1,
	LockOn                                   = 2,
	Attack                                   = 3,
	Cancel                                   = 4,
	EAJBLockOnState_MAX                      = 5,
};

// Enum AJB.ESkillState_SoulBubble
// NumValues: 0x0006
enum class ESkillState_SoulBubble : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	LastHamon                                = 2,
	CreatingBubble                           = 3,
	Death                                    = 4,
	ESkillState_MAX                          = 5,
};

// Enum AJB.ESkillState_Laser
// NumValues: 0x0005
enum class ESkillState_Laser : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	Clearing                                 = 3,
	ESkillState_MAX                          = 4,
};

// Enum AJB.ESkillState_CrossfireHurricane
// NumValues: 0x0005
enum class ESkillState_CrossfireHurricane : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	Clearing                                 = 3,
	ESkillState_MAX                          = 4,
};

// Enum AJB.ESkillState_AssaultDive
// NumValues: 0x0008
enum class ESkillState_AssaultDive : uint8
{
	None                                     = 0,
	ReadyWaiting                             = 1,
	Ready                                    = 2,
	Diving                                   = 3,
	ActionWaiting                            = 4,
	Action                                   = 5,
	Clearing                                 = 6,
	ESkillState_MAX                          = 7,
};

// Enum AJB.ESkillState_DiverShoot
// NumValues: 0x0007
enum class ESkillState_DiverShoot : uint8
{
	None                                     = 0,
	Dash                                     = 1,
	HitWait                                  = 2,
	BackToPlayer                             = 3,
	AccompanyWait                            = 4,
	Charge                                   = 5,
	ESkillState_MAX                          = 6,
};

// Enum AJB.EPoisonDartFrogProjectileState
// NumValues: 0x0004
enum class EPoisonDartFrogProjectileState : uint8
{
	None                                     = 0,
	Falling                                  = 1,
	Clearing                                 = 2,
	EPoisonDartFrogProjectileState_MAX       = 3,
};

// Enum AJB.EPoisonDartFrogCloudState
// NumValues: 0x0005
enum class EPoisonDartFrogCloudState : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	Clearing                                 = 3,
	EPoisonDartFrogCloudState_MAX            = 4,
};

// Enum AJB.ESkillState_PoisonDartFrog
// NumValues: 0x0004
enum class ESkillState_PoisonDartFrog : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	ESkillState_MAX                          = 3,
};

// Enum AJB.ESkillState_StoneHook
// NumValues: 0x0006
enum class ESkillState_StoneHook : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Waiting                                  = 2,
	Action                                   = 3,
	Clearing                                 = 4,
	ESkillState_MAX                          = 5,
};

// Enum AJB.ESkillState_CrimsonDimension
// NumValues: 0x0003
enum class ESkillState_CrimsonDimension : uint8
{
	None                                     = 0,
	Action                                   = 1,
	ESkillState_MAX                          = 2,
};

// Enum AJB.ESkillState_VanishingOfTime
// NumValues: 0x0007
enum class ESkillState_VanishingOfTime : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	Blocking                                 = 2,
	PreAction                                = 3,
	Action                                   = 4,
	Clearing                                 = 5,
	ESkillState_MAX                          = 6,
};

// Enum AJB.ESkillState_IronsandCamouflage
// NumValues: 0x0005
enum class ESkillState_IronsandCamouflage : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	Clearing                                 = 3,
	ESkillState_MAX                          = 4,
};

// Enum AJB.ESkillState_VolareBomb
// NumValues: 0x0003
enum class ESkillState_VolareBomb : uint8
{
	None                                     = 0,
	Action                                   = 1,
	ESkillState_MAX                          = 2,
};

// Enum AJB.ESkillState_CO2Scan
// NumValues: 0x0003
enum class ESkillState_CO2Scan : uint8
{
	None                                     = 0,
	Action                                   = 1,
	ESkillState_MAX                          = 2,
};

// Enum AJB.ESkillState_Buff
// NumValues: 0x0003
enum class ESkillState_Buff : uint8
{
	None                                     = 0,
	Action                                   = 1,
	ESkillState_MAX                          = 2,
};

// Enum AJB.ESkillState_EmperorTyphoon
// NumValues: 0x0005
enum class ESkillState_EmperorTyphoon : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	Clearing                                 = 3,
	ESkillState_MAX                          = 4,
};

// Enum AJB.ESkillState_GEXRequiem
// NumValues: 0x0003
enum class ESkillState_GEXRequiem : uint8
{
	None                                     = 0,
	Action                                   = 1,
	ESkillState_MAX                          = 2,
};

// Enum AJB.ESkillState_StickyDive
// NumValues: 0x0006
enum class ESkillState_StickyDive : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	Ready                                    = 2,
	Diving                                   = 3,
	Clearing                                 = 4,
	ESkillState_MAX                          = 5,
};

// Enum AJB.ESkillState_EmeraldSplashRange
// NumValues: 0x0004
enum class ESkillState_EmeraldSplashRange : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	ESkillState_MAX                          = 3,
};

// Enum AJB.ESkillState_RoadRoller
// NumValues: 0x000B
enum class ESkillState_RoadRoller : uint8
{
	None                                     = 0,
	Action                                   = 1,
	Jumping                                  = 2,
	Preview                                  = 3,
	PreFalling                               = 4,
	Falling                                  = 5,
	FullAttack                               = 6,
	Finish                                   = 7,
	ForceFinish                              = 8,
	Clearing                                 = 9,
	ESkillState_MAX                          = 10,
};

// Enum AJB.ESkillState_TheWorld
// NumValues: 0x0003
enum class ESkillState_TheWorld : uint8
{
	None                                     = 0,
	Action                                   = 1,
	ESkillState_MAX                          = 2,
};

// Enum AJB.ESkillState_Teleportation
// NumValues: 0x0006
enum class ESkillState_Teleportation : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Waiting                                  = 2,
	Action                                   = 3,
	Clearing                                 = 4,
	ESkillState_MAX                          = 5,
};

// Enum AJB.EOverGrowProprietyType
// NumValues: 0x0006
enum class EOverGrowProprietyType : uint8
{
	Success                                  = 0,
	Error_CountLimit                         = 1,
	Error_Indoor                             = 2,
	Error_OnGrowTree                         = 3,
	Error_DoNotGrowUp                        = 4,
	EOverGrowProprietyType_MAX               = 5,
};

// Enum AJB.EGrowTreeState
// NumValues: 0x0005
enum class EGrowTreeState : uint8
{
	None                                     = 0,
	Growing                                  = 1,
	Grown                                    = 2,
	Clearing                                 = 3,
	EGrowTreeState_MAX                       = 4,
};

// Enum AJB.ESkillState_OverGrow
// NumValues: 0x0004
enum class ESkillState_OverGrow : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	Action                                   = 2,
	ESkillState_MAX                          = 3,
};

// Enum AJB.ESkillState_Placement
// NumValues: 0x0004
enum class ESkillState_Placement : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	ESkillState_MAX                          = 3,
};

// Enum AJB.ESkillState_Zipper
// NumValues: 0x0004
enum class ESkillState_Zipper : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Action                                   = 2,
	ESkillState_MAX                          = 3,
};

// Enum AJB.ESkillState_BlockingRush
// NumValues: 0x0004
enum class ESkillState_BlockingRush : uint8
{
	None                                     = 0,
	Waiting                                  = 1,
	Blocking                                 = 2,
	ESkillState_MAX                          = 3,
};

// Enum AJB.ESkillState_Separate
// NumValues: 0x0005
enum class ESkillState_Separate : uint8
{
	None                                     = 0,
	Appear                                   = 1,
	Separate                                 = 2,
	Disappear                                = 3,
	ESkillState_MAX                          = 4,
};

// Enum AJB.ESkillState_BurstShot
// NumValues: 0x0006
enum class ESkillState_BurstShot : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	ChargeUp                                 = 2,
	Action                                   = 3,
	Cooldown                                 = 4,
	ESkillState_MAX                          = 5,
};

// Enum AJB.ESkillState_Snipe
// NumValues: 0x0005
enum class ESkillState_Snipe : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	ChargeUp                                 = 2,
	Action                                   = 3,
	ESkillState_MAX                          = 4,
};

// Enum AJB.ESkillState_Projectile
// NumValues: 0x0004
enum class ESkillState_Projectile : uint8
{
	None                                     = 0,
	Ready                                    = 1,
	Shot                                     = 2,
	ESkillState_MAX                          = 3,
};

// Enum AJB.ESkillState_CloseRange
// NumValues: 0x0006
enum class ESkillState_CloseRange : uint8
{
	None                                     = 0,
	Dash                                     = 1,
	HitWait                                  = 2,
	BackToPlayer                             = 3,
	AccompanyWait                            = 4,
	ESkillState_MAX                          = 5,
};

// Enum AJB.ESkillAttackType
// NumValues: 0x0006
enum class ESkillAttackType : uint8
{
	None                                     = 0,
	Knuckle                                  = 1,
	Stab                                     = 2,
	Whip                                     = 3,
	Bullet                                   = 4,
	ESkillAttackType_MAX                     = 5,
};

// Enum AJB.EAJBSkillType
// NumValues: 0x0007
enum class EAJBSkillType : uint8
{
	None                                     = 0,
	Ultimate                                 = 1,
	Basic                                    = 2,
	Special                                  = 3,
	Base                                     = 4,
	Support                                  = 5,
	EAJBSkillType_MAX                        = 6,
};

// Enum AJB.ESkillFlowState
// NumValues: 0x0004
enum class ESkillFlowState : uint8
{
	Inactive                                 = 0,
	Ready                                    = 1,
	Active                                   = 2,
	ESkillFlowState_MAX                      = 3,
};

// Enum AJB.ESeparateStandInputType
// NumValues: 0x0003
enum class ESeparateStandInputType : uint8
{
	Actor                                    = 0,
	World                                    = 1,
	ESeparateStandInputType_MAX              = 2,
};

// Enum AJB.ESeparateStandFlyingState
// NumValues: 0x0005
enum class ESeparateStandFlyingState : uint8
{
	Default                                  = 0,
	Accel                                    = 1,
	Deaccel                                  = 2,
	Stop                                     = 3,
	ESeparateStandFlyingState_MAX            = 4,
};

// Enum AJB.ESeparateStandMovementType
// NumValues: 0x0003
enum class ESeparateStandMovementType : uint8
{
	Manual                                   = 0,
	Automatic                                = 1,
	ESeparateStandMovementType_MAX           = 2,
};

// Enum AJB.EMovableSXPFlyingState
// NumValues: 0x0005
enum class EMovableSXPFlyingState : uint8
{
	Default                                  = 0,
	Accel                                    = 1,
	Deaccel                                  = 2,
	Stop                                     = 3,
	EMovableSXPFlyingState_MAX               = 4,
};

// Enum AJB.EStandBehavior
// NumValues: 0x0003
enum class EStandBehavior : uint8
{
	AccompanyToPlayer                        = 0,
	SeparateFromPlayer                       = 1,
	EStandBehavior_MAX                       = 2,
};

// Enum AJB.EImaginaryCharacterType
// NumValues: 0x0004
enum class EImaginaryCharacterType : uint8
{
	MainCharacter                            = 0,
	MovableStand                             = 1,
	PropertyStand                            = 2,
	EImaginaryCharacterType_MAX              = 3,
};

// Enum AJB.ECharacterActiveBehavior
// NumValues: 0x0008
enum class ECharacterActiveBehavior : uint8
{
	Default                                  = 0,
	EmoteUp                                  = 1,
	EmoteDown                                = 2,
	EmoteLeft                                = 3,
	EmoteRight                               = 4,
	LandingStop                              = 5,
	BreakDown                                = 6,
	ECharacterActiveBehavior_MAX             = 7,
};

// Enum AJB.ECharacterBehavior
// NumValues: 0x0006
enum class ECharacterBehavior : uint8
{
	Active                                   = 0,
	Critical                                 = 1,
	Death                                    = 2,
	ActiveToCritical                         = 3,
	CriticalToActive                         = 4,
	ECharacterBehavior_MAX                   = 5,
};

// Enum AJB.EWalkingState
// NumValues: 0x0006
enum class EWalkingState : uint8
{
	Idle                                     = 0,
	Walk                                     = 1,
	Run                                      = 2,
	Dash                                     = 3,
	Flying                                   = 4,
	EWalkingState_MAX                        = 5,
};

// Enum AJB.ECharacterBattleType
// NumValues: 0x0006
enum class ECharacterBattleType : uint8
{
	None                                     = 0,
	Fighter                                  = 1,
	Gunner                                   = 2,
	Disturb                                  = 3,
	Hamon                                    = 4,
	ECharacterBattleType_MAX                 = 5,
};

// Enum AJB.ECharacterSizeType
// NumValues: 0x0004
enum class ECharacterSizeType : uint8
{
	Large                                    = 0,
	Medium                                   = 1,
	Small                                    = 2,
	ECharacterSizeType_MAX                   = 3,
};

// Enum AJB.EDamagePriority
// NumValues: 0x0004
enum class EDamagePriority : uint8
{
	SideToGive                               = 0,
	SideToReceive                            = 1,
	ServerSide                               = 2,
	EDamagePriority_MAX                      = 3,
};

// Enum AJB.EPositioningSafeLocationResult
// NumValues: 0x0004
enum class EPositioningSafeLocationResult : uint8
{
	Succeed_DoNothing                        = 0,
	Succeed_Adjust                           = 1,
	Fail                                     = 2,
	EPositioningSafeLocationResult_MAX       = 3,
};

// Enum AJB.EGeneralTiming
// NumValues: 0x0003
enum class EGeneralTiming : uint8
{
	Begin                                    = 0,
	End                                      = 1,
	EGeneralTiming_MAX                       = 2,
};

// Enum AJB.EDashInputMode
// NumValues: 0x0004
enum class EDashInputMode : uint8
{
	TiltTwice                                = 0,
	PushDown                                 = 1,
	TiltOnce                                 = 2,
	EDashInputMode_MAX                       = 3,
};

// Enum AJB.ECameraInputMode
// NumValues: 0x0004
enum class ECameraInputMode : uint8
{
	LinearRamp                               = 0,
	ExponentialRamp                          = 1,
	DualZone                                 = 2,
	ECameraInputMode_MAX                     = 3,
};

// Enum AJB.EInGameServerStatus
// NumValues: 0x0008
enum class EInGameServerStatus : uint8
{
	Idle                                     = 0,
	Standby                                  = 1,
	InGame                                   = 2,
	ExitGame                                 = 3,
	Maintenance                              = 4,
	Failure                                  = 5,
	WaitReboot                               = 6,
	EInGameServerStatus_MAX                  = 7,
};

// Enum AJB.EAJBMatchSchedulePlayMode
// NumValues: 0x0004
enum class EAJBMatchSchedulePlayMode : uint8
{
	PairOnly                                 = 0,
	Both                                     = 1,
	SoloOnly                                 = 2,
	EAJBMatchSchedulePlayMode_MAX            = 3,
};

// Enum AJB.EAllNetReAuthStateID
// NumValues: 0x0008
enum class EAllNetReAuthStateID : uint8
{
	Idle                                     = 0,
	WaitFinalizedAMAuth                      = 1,
	WaitInitializedAMAuth                    = 2,
	StandbyGameServerConnect                 = 3,
	GameServerConnecting                     = 4,
	WaitInitializedMucha                     = 5,
	WaitUpdateLocalNetworkInfo               = 6,
	EAllNetReAuthStateID_MAX                 = 7,
};

// Enum AJB.EAMSoftwearUpdateStatus
// NumValues: 0x0007
enum class EAMSoftwearUpdateStatus : uint8
{
	UNKNOWN                                  = 0,
	NOT_NECESSARY                            = 1,
	NOTYET_PERMISSION_AND_UPDATA             = 2,
	NOTYET_PERMISSION                        = 3,
	NOTYET_UPDATA                            = 4,
	UPDATABLE                                = 5,
	EAMSoftwearUpdateStatus_MAX              = 6,
};

// Enum AJB.EAJBTestModeUpdateServerError
// NumValues: 0x0007
enum class EAJBTestModeUpdateServerError : uint8
{
	NONE                                     = 0,
	DEVICE                                   = 1,
	AUTH_NG                                  = 2,
	US_HOST_NOTFOUND                         = 3,
	US_TIMEOUT                               = 4,
	US_NG                                    = 5,
	EAJBTestModeUpdateServerError_MAX        = 6,
};

// Enum AJB.EAJBTestModeGameServerError
// NumValues: 0x0007
enum class EAJBTestModeGameServerError : uint8
{
	NONE                                     = 0,
	DEVICE                                   = 1,
	AUTH_NG                                  = 2,
	GS_HOST_NOTFOUND                         = 3,
	GS_TIMEOUT                               = 4,
	GS_NG                                    = 5,
	EAJBTestModeGameServerError_MAX          = 6,
};

// Enum AJB.EAJBTestModeAllNetError
// NumValues: 0x0009
enum class EAJBTestModeAllNetError : uint8
{
	NONE                                     = 0,
	LIBRARY_NOINT                            = 1,
	DEVICE                                   = 2,
	TIP_HOST_NOTFOUND                        = 3,
	DNS_HOST_NOTFOUND                        = 4,
	AUTH_NG                                  = 5,
	AUTH_TIMEOUT                             = 6,
	BUSY                                     = 7,
	EAJBTestModeAllNetError_MAX              = 8,
};

// Enum AJB.EAJBLocalNetCheckState
// NumValues: 0x0005
enum class EAJBLocalNetCheckState : uint8
{
	UNKNOWN                                  = 0,
	OK                                       = 1,
	NG                                       = 2,
	CHECK                                    = 3,
	EAJBLocalNetCheckState_MAX               = 4,
};

// Enum AJB.EAJBAllNetGameError
// NumValues: 0x0005
enum class EAJBAllNetGameError : uint8
{
	NONE                                     = 0,
	REQUEST                                  = 1,
	DISCONNECT                               = 2,
	TRANSCEIVER                              = 3,
	EAJBAllNetGameError_MAX                  = 4,
};

// Enum AJB.EAJBAllNetError
// NumValues: 0x000C
enum class EAJBAllNetError : uint8
{
	NONE                                     = 0,
	INIT                                     = 1,
	SYSTEM                                   = 2,
	TIMEOUT                                  = 3,
	COMMUNICATION                            = 4,
	REGIST                                   = 5,
	BOARD                                    = 6,
	PLACE                                    = 7,
	RESPONSE                                 = 8,
	OTHER                                    = 9,
	BUSY                                     = 10,
	EAJBAllNetError_MAX                      = 11,
};

// Enum AJB.EAJBAllNetTenpoError
// NumValues: 0x0004
enum class EAJBAllNetTenpoError : uint8
{
	NONE                                     = 0,
	DISCONNECT                               = 1,
	ADDRESS                                  = 2,
	EAJBAllNetTenpoError_MAX                 = 3,
};

// Enum AJB.EReconnectRetryProtocol
// NumValues: 0x0006
enum class EReconnectRetryProtocol : uint8
{
	None                                     = 0,
	Retry_Matching_Finish                    = 1,
	Retry_Matching_Breakup                   = 2,
	Retry_StartLocation_GetNPCInfo           = 3,
	Retry_StartLocation_GetPlayerInfo        = 4,
	EReconnectRetryProtocol_MAX              = 5,
};

// Enum AJB.ETenpoMatchingResult
// NumValues: 0x0004
enum class ETenpoMatchingResult : uint8
{
	Wait                                     = 0,
	Success                                  = 1,
	DeleteRoom                               = 2,
	ETenpoMatchingResult_MAX                 = 3,
};

// Enum AJB.ETenpoRoomEnterResult
// NumValues: 0x0005
enum class ETenpoRoomEnterResult : uint8
{
	Success                                  = 0,
	StartedMatchError                        = 1,
	SomeUeserIDError                         = 2,
	OtherError                               = 3,
	ETenpoRoomEnterResult_MAX                = 4,
};

// Enum AJB.EResultStartLocation
// NumValues: 0x0005
enum class EResultStartLocation : uint8
{
	Failed                                   = 0,
	Success                                  = 1,
	AutoSelect                               = 2,
	Selected                                 = 3,
	EResultStartLocation_MAX                 = 4,
};

// Enum AJB.EOutGameProxyState
// NumValues: 0x0007
enum class EOutGameProxyState : uint8
{
	SelectRoom                               = 0,
	WaitPairMatching                         = 1,
	WaitRandomPairMatching                   = 2,
	ChracterSelect                           = 3,
	GameMatching                             = 4,
	WaitPairIDMatching                       = 5,
	EOutGameProxyState_MAX                   = 6,
};

// Enum AJB.ERetryScokcetConnectType
// NumValues: 0x0005
enum class ERetryScokcetConnectType : uint8
{
	None                                     = 0,
	RequestGetRoomInfo                       = 1,
	RequestGetTenpoRoomInfo                  = 2,
	RequestStartMatching                     = 3,
	ERetryScokcetConnectType_MAX             = 4,
};

// Enum AJB.EAJBKeyConfigType
// NumValues: 0x0004
enum class EAJBKeyConfigType : uint8
{
	TypeA                                    = 0,
	TypeB                                    = 1,
	TypeC                                    = 2,
	EAJBKeyConfigType_MAX                    = 3,
};

// Enum AJB.EInGameProgressID
// NumValues: 0x0004
enum class EInGameProgressID : uint8
{
	Matching                                 = 0,
	SelectedStartLocation                    = 1,
	InGame                                   = 2,
	EInGameProgressID_MAX                    = 3,
};

// Enum AJB.EAJBLoadingScreenCacheIndex
// NumValues: 0x000C
enum class EAJBLoadingScreenCacheIndex : uint8
{
	CreaditNumIndex                          = 0,
	PPNumIndex                               = 1,
	AllNetIconFlagIndex                      = 2,
	ServiceCreditFlag                        = 3,
	ShowClosedAlertFlag                      = 4,
	ClosedTimeScheduleIndex                  = 5,
	TimeByClose                              = 6,
	ClosedCanNotBuyPPTimeMinute              = 7,
	ClosedMaxBuyPPLimit                      = 8,
	ForcedTerminateTimeMinute                = 9,
	IsFreePlayFlag                           = 10,
	EAJBLoadingScreenCacheIndex_MAX          = 11,
};

// Enum AJB.EAJBPadIconType
// NumValues: 0x000E
enum class EAJBPadIconType : uint8
{
	StickR                                   = 0,
	StickL                                   = 1,
	ButtonUp                                 = 2,
	ButtonDown                               = 3,
	ButtonLeft                               = 4,
	ButtonRight                              = 5,
	ButtonL1                                 = 6,
	ButtonL2                                 = 7,
	ButtonL3                                 = 8,
	ButtonR1                                 = 9,
	ButtonR2                                 = 10,
	ButtonR3                                 = 11,
	Touch                                    = 12,
	EAJBPadIconType_MAX                      = 13,
};

// Enum AJB.EAJBUIWindowState
// NumValues: 0x0006
enum class EAJBUIWindowState : uint8
{
	None                                     = 0,
	Opening                                  = 1,
	Opened                                   = 2,
	Closing                                  = 3,
	Closed                                   = 4,
	EAJBUIWindowState_MAX                    = 5,
};

// Enum AJB.EAJBUIViewPortPriority
// NumValues: 0x000B
enum class EAJBUIViewPortPriority : uint8
{
	Back                                     = 0,
	Non                                      = 10,
	InGame                                   = 20,
	Menu                                     = 30,
	Dialog                                   = 40,
	EMoney                                   = 50,
	Loading                                  = 60,
	GameOver                                 = 70,
	Fade                                     = 80,
	Top                                      = 250,
	EAJBUIViewPortPriority_MAX               = 251,
};

// Enum AJB.EAJBConfirmResult
// NumValues: 0x0004
enum class EAJBConfirmResult : uint8
{
	None                                     = 0,
	Yes                                      = 1,
	No                                       = 2,
	EAJBConfirmResult_MAX                    = 3,
};

// Enum AJB.EAJBCreditDisplayType
// NumValues: 0x0007
enum class EAJBCreditDisplayType : uint8
{
	None                                     = 0,
	CreditOnly                               = 1,
	PPNumOnly                                = 2,
	GameEndOnly                              = 3,
	PPBuyAndPPNum                            = 4,
	GameEndAndPPNum                          = 5,
	EAJBCreditDisplayType_MAX                = 6,
};

// Enum AJB.EAJBFontSizeType
// NumValues: 0x0009
enum class EAJBFontSizeType : uint8
{
	None                                     = 0,
	Tiny                                     = 1,
	VerySmall                                = 2,
	Small                                    = 3,
	Medium                                   = 4,
	Large                                    = 5,
	VeryLarge                                = 6,
	Huge                                     = 7,
	EAJBFontSizeType_MAX                     = 8,
};

// Enum AJB.EAJBSwitchPlayerKindOutPin
// NumValues: 0x0005
enum class EAJBSwitchPlayerKindOutPin : uint8
{
	Playing                                  = 0,
	Spectating                               = 1,
	IsPair                                   = 2,
	Others                                   = 3,
	EAJBSwitchPlayerKindOutPin_MAX           = 4,
};

// Enum AJB.EAJBImageFormatType
// NumValues: 0x0007
enum class EAJBImageFormatType : uint8
{
	Png                                      = 0,
	Jpg                                      = 1,
	Bmp                                      = 2,
	Ico                                      = 3,
	Exr                                      = 4,
	Icns                                     = 5,
	EAJBImageFormatType_MAX                  = 6,
};

// ScriptStruct AJB.AJBDamageDisplayParams
// 0x0030 (0x0030 - 0x0000)
struct FAJBDamageDisplayParams final
{
public:
	class AActor*                                 DamagedActor;                                      // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class AActor*                                 DamageCauser;                                      // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Damage;                                            // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           DamageType;                                        // 0x0018(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                HitLocation;                                       // 0x0020(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         AnimRate;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBDamageDisplayParams) == 0x000008, "Wrong alignment on FAJBDamageDisplayParams");
static_assert(sizeof(FAJBDamageDisplayParams) == 0x000030, "Wrong size on FAJBDamageDisplayParams");
static_assert(offsetof(FAJBDamageDisplayParams, DamagedActor) == 0x000000, "Member 'FAJBDamageDisplayParams::DamagedActor' has a wrong offset!");
static_assert(offsetof(FAJBDamageDisplayParams, DamageCauser) == 0x000008, "Member 'FAJBDamageDisplayParams::DamageCauser' has a wrong offset!");
static_assert(offsetof(FAJBDamageDisplayParams, Damage) == 0x000010, "Member 'FAJBDamageDisplayParams::Damage' has a wrong offset!");
static_assert(offsetof(FAJBDamageDisplayParams, DamageType) == 0x000018, "Member 'FAJBDamageDisplayParams::DamageType' has a wrong offset!");
static_assert(offsetof(FAJBDamageDisplayParams, HitLocation) == 0x000020, "Member 'FAJBDamageDisplayParams::HitLocation' has a wrong offset!");
static_assert(offsetof(FAJBDamageDisplayParams, AnimRate) == 0x00002C, "Member 'FAJBDamageDisplayParams::AnimRate' has a wrong offset!");

// ScriptStruct AJB.AJBLimitedBounus
// 0x0018 (0x0018 - 0x0000)
struct FAJBLimitedBounus final
{
public:
	class FString                                 BonusName;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBLimitedBounusSign                         Sign;                                              // 0x0010(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_11[0x3];                                       // 0x0011(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         Value;                                             // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBLimitedBounus) == 0x000008, "Wrong alignment on FAJBLimitedBounus");
static_assert(sizeof(FAJBLimitedBounus) == 0x000018, "Wrong size on FAJBLimitedBounus");
static_assert(offsetof(FAJBLimitedBounus, BonusName) == 0x000000, "Member 'FAJBLimitedBounus::BonusName' has a wrong offset!");
static_assert(offsetof(FAJBLimitedBounus, Sign) == 0x000010, "Member 'FAJBLimitedBounus::Sign' has a wrong offset!");
static_assert(offsetof(FAJBLimitedBounus, Value) == 0x000014, "Member 'FAJBLimitedBounus::Value' has a wrong offset!");

// ScriptStruct AJB.AJBExpInfo
// 0x0050 (0x0050 - 0x0000)
struct FAJBExpInfo final
{
public:
	int32                                         BeforeExp;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterExp;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeRank;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterRank;                                         // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<int32>                                 NextExpList;                                       // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         LiveTime;                                          // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WatchingTime;                                      // 0x0024(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KnockDownNum;                                      // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDamage;                                       // 0x002C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SkillNum;                                          // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FirstBlood;                                        // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ContinueMatch;                                     // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAJBLimitedBounus>              LimitedBounus;                                     // 0x0040(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBExpInfo) == 0x000008, "Wrong alignment on FAJBExpInfo");
static_assert(sizeof(FAJBExpInfo) == 0x000050, "Wrong size on FAJBExpInfo");
static_assert(offsetof(FAJBExpInfo, BeforeExp) == 0x000000, "Member 'FAJBExpInfo::BeforeExp' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, AfterExp) == 0x000004, "Member 'FAJBExpInfo::AfterExp' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, BeforeRank) == 0x000008, "Member 'FAJBExpInfo::BeforeRank' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, AfterRank) == 0x00000C, "Member 'FAJBExpInfo::AfterRank' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, NextExpList) == 0x000010, "Member 'FAJBExpInfo::NextExpList' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, LiveTime) == 0x000020, "Member 'FAJBExpInfo::LiveTime' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, WatchingTime) == 0x000024, "Member 'FAJBExpInfo::WatchingTime' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, KnockDownNum) == 0x000028, "Member 'FAJBExpInfo::KnockDownNum' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, TotalDamage) == 0x00002C, "Member 'FAJBExpInfo::TotalDamage' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, Rank) == 0x000030, "Member 'FAJBExpInfo::Rank' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, SkillNum) == 0x000034, "Member 'FAJBExpInfo::SkillNum' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, FirstBlood) == 0x000038, "Member 'FAJBExpInfo::FirstBlood' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, ContinueMatch) == 0x00003C, "Member 'FAJBExpInfo::ContinueMatch' has a wrong offset!");
static_assert(offsetof(FAJBExpInfo, LimitedBounus) == 0x000040, "Member 'FAJBExpInfo::LimitedBounus' has a wrong offset!");

// ScriptStruct AJB.ChallengeEventClassContext
// 0x0030 (0x0030 - 0x0000)
struct FChallengeEventClassContext final
{
public:
	int32                                         StartingEventExp;                                  // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredEventExp;                                  // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERewardCategory                               Category;                                          // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERewardItemType                               ItemType;                                          // 0x0009(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_A[0x2];                                        // 0x000A(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterID;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardNo;                                          // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardNum;                                         // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FChallengeEventClassContext) == 0x000008, "Wrong alignment on FChallengeEventClassContext");
static_assert(sizeof(FChallengeEventClassContext) == 0x000030, "Wrong size on FChallengeEventClassContext");
static_assert(offsetof(FChallengeEventClassContext, StartingEventExp) == 0x000000, "Member 'FChallengeEventClassContext::StartingEventExp' has a wrong offset!");
static_assert(offsetof(FChallengeEventClassContext, RequiredEventExp) == 0x000004, "Member 'FChallengeEventClassContext::RequiredEventExp' has a wrong offset!");
static_assert(offsetof(FChallengeEventClassContext, Category) == 0x000008, "Member 'FChallengeEventClassContext::Category' has a wrong offset!");
static_assert(offsetof(FChallengeEventClassContext, ItemType) == 0x000009, "Member 'FChallengeEventClassContext::ItemType' has a wrong offset!");
static_assert(offsetof(FChallengeEventClassContext, CharacterID) == 0x00000C, "Member 'FChallengeEventClassContext::CharacterID' has a wrong offset!");
static_assert(offsetof(FChallengeEventClassContext, RewardNo) == 0x000010, "Member 'FChallengeEventClassContext::RewardNo' has a wrong offset!");
static_assert(offsetof(FChallengeEventClassContext, Name) == 0x000018, "Member 'FChallengeEventClassContext::Name' has a wrong offset!");
static_assert(offsetof(FChallengeEventClassContext, RewardNum) == 0x000028, "Member 'FChallengeEventClassContext::RewardNum' has a wrong offset!");

// ScriptStruct AJB.AJBGameRewardInfo
// 0x0040 (0x0040 - 0x0000)
struct FAJBGameRewardInfo final
{
public:
	ERewardItemType                               ItemType;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterID;                                       // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardNo;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0020(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EGameRewardType                               Type;                                              // 0x0024(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Description;                                       // 0x0028(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardItemNum;                                     // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_3C[0x4];                                       // 0x003C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBGameRewardInfo) == 0x000008, "Wrong alignment on FAJBGameRewardInfo");
static_assert(sizeof(FAJBGameRewardInfo) == 0x000040, "Wrong size on FAJBGameRewardInfo");
static_assert(offsetof(FAJBGameRewardInfo, ItemType) == 0x000000, "Member 'FAJBGameRewardInfo::ItemType' has a wrong offset!");
static_assert(offsetof(FAJBGameRewardInfo, CharacterID) == 0x000004, "Member 'FAJBGameRewardInfo::CharacterID' has a wrong offset!");
static_assert(offsetof(FAJBGameRewardInfo, RewardNo) == 0x000008, "Member 'FAJBGameRewardInfo::RewardNo' has a wrong offset!");
static_assert(offsetof(FAJBGameRewardInfo, Name) == 0x000010, "Member 'FAJBGameRewardInfo::Name' has a wrong offset!");
static_assert(offsetof(FAJBGameRewardInfo, Rarity) == 0x000020, "Member 'FAJBGameRewardInfo::Rarity' has a wrong offset!");
static_assert(offsetof(FAJBGameRewardInfo, Type) == 0x000024, "Member 'FAJBGameRewardInfo::Type' has a wrong offset!");
static_assert(offsetof(FAJBGameRewardInfo, Description) == 0x000028, "Member 'FAJBGameRewardInfo::Description' has a wrong offset!");
static_assert(offsetof(FAJBGameRewardInfo, RewardItemNum) == 0x000038, "Member 'FAJBGameRewardInfo::RewardItemNum' has a wrong offset!");

// ScriptStruct AJB.ChallengeEventProgressContext
// 0x0058 (0x0058 - 0x0000)
struct FChallengeEventProgressContext final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StartAt;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndAt;                                             // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeEventExp;                                    // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterEventExp;                                     // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FChallengeEventClassContext>    ClassContexts;                                     // 0x0038(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAJBGameRewardInfo>             RewardInfos;                                       // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FChallengeEventProgressContext) == 0x000008, "Wrong alignment on FChallengeEventProgressContext");
static_assert(sizeof(FChallengeEventProgressContext) == 0x000058, "Wrong size on FChallengeEventProgressContext");
static_assert(offsetof(FChallengeEventProgressContext, Name) == 0x000000, "Member 'FChallengeEventProgressContext::Name' has a wrong offset!");
static_assert(offsetof(FChallengeEventProgressContext, StartAt) == 0x000010, "Member 'FChallengeEventProgressContext::StartAt' has a wrong offset!");
static_assert(offsetof(FChallengeEventProgressContext, EndAt) == 0x000020, "Member 'FChallengeEventProgressContext::EndAt' has a wrong offset!");
static_assert(offsetof(FChallengeEventProgressContext, BeforeEventExp) == 0x000030, "Member 'FChallengeEventProgressContext::BeforeEventExp' has a wrong offset!");
static_assert(offsetof(FChallengeEventProgressContext, AfterEventExp) == 0x000034, "Member 'FChallengeEventProgressContext::AfterEventExp' has a wrong offset!");
static_assert(offsetof(FChallengeEventProgressContext, ClassContexts) == 0x000038, "Member 'FChallengeEventProgressContext::ClassContexts' has a wrong offset!");
static_assert(offsetof(FChallengeEventProgressContext, RewardInfos) == 0x000048, "Member 'FChallengeEventProgressContext::RewardInfos' has a wrong offset!");

// ScriptStruct AJB.AJBResultTicketInfo
// 0x0018 (0x0018 - 0x0000)
struct FAJBResultTicketInfo final
{
public:
	int32                                         LiveTime;                                          // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAJBLimitedBounus>              LimitedBounus;                                     // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBResultTicketInfo) == 0x000008, "Wrong alignment on FAJBResultTicketInfo");
static_assert(sizeof(FAJBResultTicketInfo) == 0x000018, "Wrong size on FAJBResultTicketInfo");
static_assert(offsetof(FAJBResultTicketInfo, LiveTime) == 0x000000, "Member 'FAJBResultTicketInfo::LiveTime' has a wrong offset!");
static_assert(offsetof(FAJBResultTicketInfo, Rank) == 0x000004, "Member 'FAJBResultTicketInfo::Rank' has a wrong offset!");
static_assert(offsetof(FAJBResultTicketInfo, LimitedBounus) == 0x000008, "Member 'FAJBResultTicketInfo::LimitedBounus' has a wrong offset!");

// ScriptStruct AJB.AJBAchievementInfo
// 0x0038 (0x0038 - 0x0000)
struct FAJBAchievementInfo final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeValue;                                       // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterValue;                                        // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TargetValue;                                       // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 RewardName;                                        // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERewardItemType                               ItemType;                                          // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBAchievementInfo) == 0x000008, "Wrong alignment on FAJBAchievementInfo");
static_assert(sizeof(FAJBAchievementInfo) == 0x000038, "Wrong size on FAJBAchievementInfo");
static_assert(offsetof(FAJBAchievementInfo, Name) == 0x000000, "Member 'FAJBAchievementInfo::Name' has a wrong offset!");
static_assert(offsetof(FAJBAchievementInfo, BeforeValue) == 0x000010, "Member 'FAJBAchievementInfo::BeforeValue' has a wrong offset!");
static_assert(offsetof(FAJBAchievementInfo, AfterValue) == 0x000014, "Member 'FAJBAchievementInfo::AfterValue' has a wrong offset!");
static_assert(offsetof(FAJBAchievementInfo, TargetValue) == 0x000018, "Member 'FAJBAchievementInfo::TargetValue' has a wrong offset!");
static_assert(offsetof(FAJBAchievementInfo, RewardName) == 0x000020, "Member 'FAJBAchievementInfo::RewardName' has a wrong offset!");
static_assert(offsetof(FAJBAchievementInfo, ItemType) == 0x000030, "Member 'FAJBAchievementInfo::ItemType' has a wrong offset!");

// ScriptStruct AJB.AJBLimitedAchievements
// 0x0030 (0x0030 - 0x0000)
struct FAJBLimitedAchievements final
{
public:
	class FString                                 StartDate;                                         // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndDate;                                           // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FAJBAchievementInfo>            AchievementsData;                                  // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBLimitedAchievements) == 0x000008, "Wrong alignment on FAJBLimitedAchievements");
static_assert(sizeof(FAJBLimitedAchievements) == 0x000030, "Wrong size on FAJBLimitedAchievements");
static_assert(offsetof(FAJBLimitedAchievements, StartDate) == 0x000000, "Member 'FAJBLimitedAchievements::StartDate' has a wrong offset!");
static_assert(offsetof(FAJBLimitedAchievements, EndDate) == 0x000010, "Member 'FAJBLimitedAchievements::EndDate' has a wrong offset!");
static_assert(offsetof(FAJBLimitedAchievements, AchievementsData) == 0x000020, "Member 'FAJBLimitedAchievements::AchievementsData' has a wrong offset!");

// ScriptStruct AJB.AJBProfileCardDetail
// 0x0030 (0x0030 - 0x0000)
struct FAJBProfileCardDetail final
{
public:
	int32                                         TotalVictoryCount;                                 // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardID;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<int32>                                 MilestoneList;                                     // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBProfileCardDetail) == 0x000008, "Wrong alignment on FAJBProfileCardDetail");
static_assert(sizeof(FAJBProfileCardDetail) == 0x000030, "Wrong size on FAJBProfileCardDetail");
static_assert(offsetof(FAJBProfileCardDetail, TotalVictoryCount) == 0x000000, "Member 'FAJBProfileCardDetail::TotalVictoryCount' has a wrong offset!");
static_assert(offsetof(FAJBProfileCardDetail, CardID) == 0x000004, "Member 'FAJBProfileCardDetail::CardID' has a wrong offset!");
static_assert(offsetof(FAJBProfileCardDetail, Name) == 0x000008, "Member 'FAJBProfileCardDetail::Name' has a wrong offset!");
static_assert(offsetof(FAJBProfileCardDetail, Rarity) == 0x000018, "Member 'FAJBProfileCardDetail::Rarity' has a wrong offset!");
static_assert(offsetof(FAJBProfileCardDetail, MilestoneList) == 0x000020, "Member 'FAJBProfileCardDetail::MilestoneList' has a wrong offset!");

// ScriptStruct AJB.AJBPairProfileCardDetail
// 0x0030 (0x0030 - 0x0000)
struct FAJBPairProfileCardDetail final
{
public:
	class FString                                 PairName;                                          // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CardID;                                            // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 Name;                                              // 0x0018(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0028(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2C[0x4];                                       // 0x002C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBPairProfileCardDetail) == 0x000008, "Wrong alignment on FAJBPairProfileCardDetail");
static_assert(sizeof(FAJBPairProfileCardDetail) == 0x000030, "Wrong size on FAJBPairProfileCardDetail");
static_assert(offsetof(FAJBPairProfileCardDetail, PairName) == 0x000000, "Member 'FAJBPairProfileCardDetail::PairName' has a wrong offset!");
static_assert(offsetof(FAJBPairProfileCardDetail, CardID) == 0x000010, "Member 'FAJBPairProfileCardDetail::CardID' has a wrong offset!");
static_assert(offsetof(FAJBPairProfileCardDetail, Name) == 0x000018, "Member 'FAJBPairProfileCardDetail::Name' has a wrong offset!");
static_assert(offsetof(FAJBPairProfileCardDetail, Rarity) == 0x000028, "Member 'FAJBPairProfileCardDetail::Rarity' has a wrong offset!");

// ScriptStruct AJB.AJBGameResult
// 0x0190 (0x0190 - 0x0000)
struct FAJBGameResult final
{
public:
	struct FAJBExpInfo                            ExpInfo;                                           // 0x0000(0x0050)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAJBResultTicketInfo                   TicketDatail;                                      // 0x0050(0x0018)(BlueprintVisible, NativeAccessSpecifierPublic)
	TArray<struct FAJBGameRewardInfo>             Rewards;                                           // 0x0068(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FAJBLimitedAchievements                LimitedAchievements;                               // 0x0078(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAJBProfileCardDetail                  ProfileCardDetail;                                 // 0x00A8(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FAJBPairProfileCardDetail              PairProfileCardDetail;                             // 0x00D8(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FChallengeEventClassContext            ChallengeEventClassContext;                        // 0x0108(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FChallengeEventProgressContext         ChallengeEventProgressContext;                     // 0x0138(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBGameResult) == 0x000008, "Wrong alignment on FAJBGameResult");
static_assert(sizeof(FAJBGameResult) == 0x000190, "Wrong size on FAJBGameResult");
static_assert(offsetof(FAJBGameResult, ExpInfo) == 0x000000, "Member 'FAJBGameResult::ExpInfo' has a wrong offset!");
static_assert(offsetof(FAJBGameResult, TicketDatail) == 0x000050, "Member 'FAJBGameResult::TicketDatail' has a wrong offset!");
static_assert(offsetof(FAJBGameResult, Rewards) == 0x000068, "Member 'FAJBGameResult::Rewards' has a wrong offset!");
static_assert(offsetof(FAJBGameResult, LimitedAchievements) == 0x000078, "Member 'FAJBGameResult::LimitedAchievements' has a wrong offset!");
static_assert(offsetof(FAJBGameResult, ProfileCardDetail) == 0x0000A8, "Member 'FAJBGameResult::ProfileCardDetail' has a wrong offset!");
static_assert(offsetof(FAJBGameResult, PairProfileCardDetail) == 0x0000D8, "Member 'FAJBGameResult::PairProfileCardDetail' has a wrong offset!");
static_assert(offsetof(FAJBGameResult, ChallengeEventClassContext) == 0x000108, "Member 'FAJBGameResult::ChallengeEventClassContext' has a wrong offset!");
static_assert(offsetof(FAJBGameResult, ChallengeEventProgressContext) == 0x000138, "Member 'FAJBGameResult::ChallengeEventProgressContext' has a wrong offset!");

// ScriptStruct AJB.FreePlayCount
// 0x0004 (0x0004 - 0x0000)
struct FFreePlayCount final
{
public:
	int32                                         PlayCount;                                         // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FFreePlayCount) == 0x000004, "Wrong alignment on FFreePlayCount");
static_assert(sizeof(FFreePlayCount) == 0x000004, "Wrong size on FFreePlayCount");
static_assert(offsetof(FFreePlayCount, PlayCount) == 0x000000, "Member 'FFreePlayCount::PlayCount' has a wrong offset!");

// ScriptStruct AJB.AJBLogoutReward
// 0x00A0 (0x00A0 - 0x0000)
struct FAJBLogoutReward final
{
public:
	int32                                         BeforeExp;                                         // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterExp;                                          // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         BeforeRank;                                        // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterRank;                                         // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TicketNum;                                         // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalTicketNum;                                    // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FChallengeEventClassContext            ChallengeEventClassContext;                        // 0x0018(0x0030)(BlueprintVisible, NativeAccessSpecifierPublic)
	struct FChallengeEventProgressContext         ChallengeEventProgressContext;                     // 0x0048(0x0058)(BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBLogoutReward) == 0x000008, "Wrong alignment on FAJBLogoutReward");
static_assert(sizeof(FAJBLogoutReward) == 0x0000A0, "Wrong size on FAJBLogoutReward");
static_assert(offsetof(FAJBLogoutReward, BeforeExp) == 0x000000, "Member 'FAJBLogoutReward::BeforeExp' has a wrong offset!");
static_assert(offsetof(FAJBLogoutReward, AfterExp) == 0x000004, "Member 'FAJBLogoutReward::AfterExp' has a wrong offset!");
static_assert(offsetof(FAJBLogoutReward, BeforeRank) == 0x000008, "Member 'FAJBLogoutReward::BeforeRank' has a wrong offset!");
static_assert(offsetof(FAJBLogoutReward, AfterRank) == 0x00000C, "Member 'FAJBLogoutReward::AfterRank' has a wrong offset!");
static_assert(offsetof(FAJBLogoutReward, TicketNum) == 0x000010, "Member 'FAJBLogoutReward::TicketNum' has a wrong offset!");
static_assert(offsetof(FAJBLogoutReward, TotalTicketNum) == 0x000014, "Member 'FAJBLogoutReward::TotalTicketNum' has a wrong offset!");
static_assert(offsetof(FAJBLogoutReward, ChallengeEventClassContext) == 0x000018, "Member 'FAJBLogoutReward::ChallengeEventClassContext' has a wrong offset!");
static_assert(offsetof(FAJBLogoutReward, ChallengeEventProgressContext) == 0x000048, "Member 'FAJBLogoutReward::ChallengeEventProgressContext' has a wrong offset!");

// ScriptStruct AJB.AJBSetGameRewardParam
// 0x0020 (0x0020 - 0x0000)
struct FAJBSetGameRewardParam final
{
public:
	ERewardItemType                               ItemType;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterID;                                       // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardNo;                                          // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Position;                                          // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 RewardString;                                      // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBSetGameRewardParam) == 0x000008, "Wrong alignment on FAJBSetGameRewardParam");
static_assert(sizeof(FAJBSetGameRewardParam) == 0x000020, "Wrong size on FAJBSetGameRewardParam");
static_assert(offsetof(FAJBSetGameRewardParam, ItemType) == 0x000000, "Member 'FAJBSetGameRewardParam::ItemType' has a wrong offset!");
static_assert(offsetof(FAJBSetGameRewardParam, CharacterID) == 0x000004, "Member 'FAJBSetGameRewardParam::CharacterID' has a wrong offset!");
static_assert(offsetof(FAJBSetGameRewardParam, RewardNo) == 0x000008, "Member 'FAJBSetGameRewardParam::RewardNo' has a wrong offset!");
static_assert(offsetof(FAJBSetGameRewardParam, Position) == 0x00000C, "Member 'FAJBSetGameRewardParam::Position' has a wrong offset!");
static_assert(offsetof(FAJBSetGameRewardParam, RewardString) == 0x000010, "Member 'FAJBSetGameRewardParam::RewardString' has a wrong offset!");

// ScriptStruct AJB.MatchScheduleTimeInfo
// 0x0008 (0x0008 - 0x0000)
struct FMatchScheduleTimeInfo final
{
public:
	int32                                         Houre;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minute;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchScheduleTimeInfo) == 0x000004, "Wrong alignment on FMatchScheduleTimeInfo");
static_assert(sizeof(FMatchScheduleTimeInfo) == 0x000008, "Wrong size on FMatchScheduleTimeInfo");
static_assert(offsetof(FMatchScheduleTimeInfo, Houre) == 0x000000, "Member 'FMatchScheduleTimeInfo::Houre' has a wrong offset!");
static_assert(offsetof(FMatchScheduleTimeInfo, Minute) == 0x000004, "Member 'FMatchScheduleTimeInfo::Minute' has a wrong offset!");

// ScriptStruct AJB.AJBMatchScheduleDateTime
// 0x0020 (0x0020 - 0x0000)
struct FAJBMatchScheduleDateTime final
{
public:
	struct FDateTime                              Date;                                              // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDate;                                           // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FMatchScheduleTimeInfo                 StartTime;                                         // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FMatchScheduleTimeInfo                 EndTime;                                           // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBMatchScheduleDateTime) == 0x000008, "Wrong alignment on FAJBMatchScheduleDateTime");
static_assert(sizeof(FAJBMatchScheduleDateTime) == 0x000020, "Wrong size on FAJBMatchScheduleDateTime");
static_assert(offsetof(FAJBMatchScheduleDateTime, Date) == 0x000000, "Member 'FAJBMatchScheduleDateTime::Date' has a wrong offset!");
static_assert(offsetof(FAJBMatchScheduleDateTime, EndDate) == 0x000008, "Member 'FAJBMatchScheduleDateTime::EndDate' has a wrong offset!");
static_assert(offsetof(FAJBMatchScheduleDateTime, StartTime) == 0x000010, "Member 'FAJBMatchScheduleDateTime::StartTime' has a wrong offset!");
static_assert(offsetof(FAJBMatchScheduleDateTime, EndTime) == 0x000018, "Member 'FAJBMatchScheduleDateTime::EndTime' has a wrong offset!");

// ScriptStruct AJB.AJBAnnouncement
// 0x0040 (0x0040 - 0x0000)
struct FAJBAnnouncement final
{
public:
	class FString                                 ImageURL;                                          // 0x0000(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 ImageMD5;                                          // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 TitleText;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 BodyText;                                          // 0x0030(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBAnnouncement) == 0x000008, "Wrong alignment on FAJBAnnouncement");
static_assert(sizeof(FAJBAnnouncement) == 0x000040, "Wrong size on FAJBAnnouncement");
static_assert(offsetof(FAJBAnnouncement, ImageURL) == 0x000000, "Member 'FAJBAnnouncement::ImageURL' has a wrong offset!");
static_assert(offsetof(FAJBAnnouncement, ImageMD5) == 0x000010, "Member 'FAJBAnnouncement::ImageMD5' has a wrong offset!");
static_assert(offsetof(FAJBAnnouncement, TitleText) == 0x000020, "Member 'FAJBAnnouncement::TitleText' has a wrong offset!");
static_assert(offsetof(FAJBAnnouncement, BodyText) == 0x000030, "Member 'FAJBAnnouncement::BodyText' has a wrong offset!");

// ScriptStruct AJB.AJBDamageDisplayProperty
// 0x0003 (0x0003 - 0x0000)
struct FAJBDamageDisplayProperty final
{
public:
	bool                                          bIsDisplayedByLocalProcess;                        // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsDisplayedByUniqueBehavior;                      // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShouldDisplayToSeparatedStand;                    // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBDamageDisplayProperty) == 0x000001, "Wrong alignment on FAJBDamageDisplayProperty");
static_assert(sizeof(FAJBDamageDisplayProperty) == 0x000003, "Wrong size on FAJBDamageDisplayProperty");
static_assert(offsetof(FAJBDamageDisplayProperty, bIsDisplayedByLocalProcess) == 0x000000, "Member 'FAJBDamageDisplayProperty::bIsDisplayedByLocalProcess' has a wrong offset!");
static_assert(offsetof(FAJBDamageDisplayProperty, bIsDisplayedByUniqueBehavior) == 0x000001, "Member 'FAJBDamageDisplayProperty::bIsDisplayedByUniqueBehavior' has a wrong offset!");
static_assert(offsetof(FAJBDamageDisplayProperty, bShouldDisplayToSeparatedStand) == 0x000002, "Member 'FAJBDamageDisplayProperty::bShouldDisplayToSeparatedStand' has a wrong offset!");

// ScriptStruct AJB.AMUpdateSettings
// 0x0001 (0x0001 - 0x0000)
struct FAMUpdateSettings final
{
public:
	bool                                          bIsServerMode;                                     // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAMUpdateSettings) == 0x000001, "Wrong alignment on FAMUpdateSettings");
static_assert(sizeof(FAMUpdateSettings) == 0x000001, "Wrong size on FAMUpdateSettings");
static_assert(offsetof(FAMUpdateSettings, bIsServerMode) == 0x000000, "Member 'FAMUpdateSettings::bIsServerMode' has a wrong offset!");

// ScriptStruct AJB.SaveCheckText
// 0x0018 (0x0018 - 0x0000)
struct FSaveCheckText final
{
public:
	class FString                                 Text;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_10[0x8];                                       // 0x0010(0x0008)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FSaveCheckText) == 0x000008, "Wrong alignment on FSaveCheckText");
static_assert(sizeof(FSaveCheckText) == 0x000018, "Wrong size on FSaveCheckText");
static_assert(offsetof(FSaveCheckText, Text) == 0x000000, "Member 'FSaveCheckText::Text' has a wrong offset!");

// ScriptStruct AJB.ErrorInfo
// 0x0040 (0x0040 - 0x0000)
struct FErrorInfo final
{
public:
	uint8                                         Pad_0[0x8];                                        // 0x0000(0x0008)(Fixing Size After Last Property [ Dumper-7 ])
	struct FSaveCheckText                         Log;                                               // 0x0008(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FDateTime                              Date;                                              // 0x0020(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FSaveCheckText                         DetailLog;                                         // 0x0028(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FErrorInfo) == 0x000008, "Wrong alignment on FErrorInfo");
static_assert(sizeof(FErrorInfo) == 0x000040, "Wrong size on FErrorInfo");
static_assert(offsetof(FErrorInfo, Log) == 0x000008, "Member 'FErrorInfo::Log' has a wrong offset!");
static_assert(offsetof(FErrorInfo, Date) == 0x000020, "Member 'FErrorInfo::Date' has a wrong offset!");
static_assert(offsetof(FErrorInfo, DetailLog) == 0x000028, "Member 'FErrorInfo::DetailLog' has a wrong offset!");

// ScriptStruct AJB.ErrorLogs
// 0x0010 (0x0010 - 0x0000)
struct FErrorLogs final
{
public:
	TArray<struct FErrorInfo>                     Logs;                                              // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FErrorLogs) == 0x000008, "Wrong alignment on FErrorLogs");
static_assert(sizeof(FErrorLogs) == 0x000010, "Wrong size on FErrorLogs");
static_assert(offsetof(FErrorLogs, Logs) == 0x000000, "Member 'FErrorLogs::Logs' has a wrong offset!");

// ScriptStruct AJB.AJBAMCompensationInfo
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAJBAMCompensationInfo final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBAMCompensationInfo) == 0x000008, "Wrong alignment on FAJBAMCompensationInfo");
static_assert(sizeof(FAJBAMCompensationInfo) == 0x000020, "Wrong size on FAJBAMCompensationInfo");

// ScriptStruct AJB.CoinOptions
// 0x0004 (0x0004 - 0x0000)
struct FCoinOptions final
{
public:
	bool                                          FreePlay;                                          // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          BuyAddPP;                                          // 0x0001(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EPurchaseLimitPP                              PurchaseLimitPP;                                   // 0x0002(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EExtraPPKind                                  ExtraPP;                                           // 0x0003(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCoinOptions) == 0x000001, "Wrong alignment on FCoinOptions");
static_assert(sizeof(FCoinOptions) == 0x000004, "Wrong size on FCoinOptions");
static_assert(offsetof(FCoinOptions, FreePlay) == 0x000000, "Member 'FCoinOptions::FreePlay' has a wrong offset!");
static_assert(offsetof(FCoinOptions, BuyAddPP) == 0x000001, "Member 'FCoinOptions::BuyAddPP' has a wrong offset!");
static_assert(offsetof(FCoinOptions, PurchaseLimitPP) == 0x000002, "Member 'FCoinOptions::PurchaseLimitPP' has a wrong offset!");
static_assert(offsetof(FCoinOptions, ExtraPP) == 0x000003, "Member 'FCoinOptions::ExtraPP' has a wrong offset!");

// ScriptStruct AJB.AJBGetRewardsResponse
// 0x0010 (0x0010 - 0x0000)
struct FAJBGetRewardsResponse final
{
public:
	TArray<struct FAJBGameRewardInfo>             Rewards;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBGetRewardsResponse) == 0x000008, "Wrong alignment on FAJBGetRewardsResponse");
static_assert(sizeof(FAJBGetRewardsResponse) == 0x000010, "Wrong size on FAJBGetRewardsResponse");
static_assert(offsetof(FAJBGetRewardsResponse, Rewards) == 0x000000, "Member 'FAJBGetRewardsResponse::Rewards' has a wrong offset!");

// ScriptStruct AJB.AJBHistoryInfo
// 0x0060 (0x0060 - 0x0000)
struct FAJBHistoryInfo final
{
public:
	bool                                          bCanInvalidation;                                  // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  ValidTags;                                         // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	int32                                         SerialNumber;                                      // 0x0028(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerID;                                          // 0x002C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              DateTime;                                          // 0x0030(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FVector                                CharacterLocation;                                 // 0x0038(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               CameraRotation;                                    // 0x0044(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FRotator                               NextRotation;                                      // 0x0050(0x000C)(Edit, BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_5C[0x4];                                       // 0x005C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBHistoryInfo) == 0x000008, "Wrong alignment on FAJBHistoryInfo");
static_assert(sizeof(FAJBHistoryInfo) == 0x000060, "Wrong size on FAJBHistoryInfo");
static_assert(offsetof(FAJBHistoryInfo, bCanInvalidation) == 0x000000, "Member 'FAJBHistoryInfo::bCanInvalidation' has a wrong offset!");
static_assert(offsetof(FAJBHistoryInfo, ValidTags) == 0x000008, "Member 'FAJBHistoryInfo::ValidTags' has a wrong offset!");
static_assert(offsetof(FAJBHistoryInfo, SerialNumber) == 0x000028, "Member 'FAJBHistoryInfo::SerialNumber' has a wrong offset!");
static_assert(offsetof(FAJBHistoryInfo, PlayerID) == 0x00002C, "Member 'FAJBHistoryInfo::PlayerID' has a wrong offset!");
static_assert(offsetof(FAJBHistoryInfo, DateTime) == 0x000030, "Member 'FAJBHistoryInfo::DateTime' has a wrong offset!");
static_assert(offsetof(FAJBHistoryInfo, CharacterLocation) == 0x000038, "Member 'FAJBHistoryInfo::CharacterLocation' has a wrong offset!");
static_assert(offsetof(FAJBHistoryInfo, CameraRotation) == 0x000044, "Member 'FAJBHistoryInfo::CameraRotation' has a wrong offset!");
static_assert(offsetof(FAJBHistoryInfo, NextRotation) == 0x000050, "Member 'FAJBHistoryInfo::NextRotation' has a wrong offset!");

// ScriptStruct AJB.AJBGameRecord
// 0x0040 (0x0040 - 0x0000)
struct FAJBGameRecord final
{
public:
	EPlayMode                                     PlayMode;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         SurvivalTimeMinutes;                               // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         KillCount;                                         // 0x0008(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TotalDamage;                                       // 0x000C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rank;                                              // 0x0010(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltimateSkillCount;                                // 0x0014(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UltimateSkillMax;                                  // 0x0018(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          FirstBlood;                                        // 0x001C(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ConutsForAchievementsJSONString;                   // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         WatchingTime;                                      // 0x0030(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RankWithoutNPC;                                    // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EnableEasyOperation;                               // 0x0038(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PvEScore;                                          // 0x003C(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBGameRecord) == 0x000008, "Wrong alignment on FAJBGameRecord");
static_assert(sizeof(FAJBGameRecord) == 0x000040, "Wrong size on FAJBGameRecord");
static_assert(offsetof(FAJBGameRecord, PlayMode) == 0x000000, "Member 'FAJBGameRecord::PlayMode' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, SurvivalTimeMinutes) == 0x000004, "Member 'FAJBGameRecord::SurvivalTimeMinutes' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, KillCount) == 0x000008, "Member 'FAJBGameRecord::KillCount' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, TotalDamage) == 0x00000C, "Member 'FAJBGameRecord::TotalDamage' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, Rank) == 0x000010, "Member 'FAJBGameRecord::Rank' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, UltimateSkillCount) == 0x000014, "Member 'FAJBGameRecord::UltimateSkillCount' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, UltimateSkillMax) == 0x000018, "Member 'FAJBGameRecord::UltimateSkillMax' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, FirstBlood) == 0x00001C, "Member 'FAJBGameRecord::FirstBlood' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, ConutsForAchievementsJSONString) == 0x000020, "Member 'FAJBGameRecord::ConutsForAchievementsJSONString' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, WatchingTime) == 0x000030, "Member 'FAJBGameRecord::WatchingTime' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, RankWithoutNPC) == 0x000034, "Member 'FAJBGameRecord::RankWithoutNPC' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, EnableEasyOperation) == 0x000038, "Member 'FAJBGameRecord::EnableEasyOperation' has a wrong offset!");
static_assert(offsetof(FAJBGameRecord, PvEScore) == 0x00003C, "Member 'FAJBGameRecord::PvEScore' has a wrong offset!");

// ScriptStruct AJB.ShopInfoSaveData
// 0x0018 (0x0018 - 0x0000)
struct FShopInfoSaveData final
{
public:
	struct FSaveCheckText                         ShopId;                                            // 0x0000(0x0018)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopInfoSaveData) == 0x000008, "Wrong alignment on FShopInfoSaveData");
static_assert(sizeof(FShopInfoSaveData) == 0x000018, "Wrong size on FShopInfoSaveData");
static_assert(offsetof(FShopInfoSaveData, ShopId) == 0x000000, "Member 'FShopInfoSaveData::ShopId' has a wrong offset!");

// ScriptStruct AJB.AJBPickupGachaDetail
// 0x0038 (0x0038 - 0x0000)
struct FAJBPickupGachaDetail final
{
public:
	class FString                                 Name;                                              // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rarity;                                            // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Rate;                                              // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ERewardItemType                               ItemType;                                          // 0x0030(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x3];                                       // 0x0031(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         CharacterID;                                       // 0x0034(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBPickupGachaDetail) == 0x000008, "Wrong alignment on FAJBPickupGachaDetail");
static_assert(sizeof(FAJBPickupGachaDetail) == 0x000038, "Wrong size on FAJBPickupGachaDetail");
static_assert(offsetof(FAJBPickupGachaDetail, Name) == 0x000000, "Member 'FAJBPickupGachaDetail::Name' has a wrong offset!");
static_assert(offsetof(FAJBPickupGachaDetail, Rarity) == 0x000010, "Member 'FAJBPickupGachaDetail::Rarity' has a wrong offset!");
static_assert(offsetof(FAJBPickupGachaDetail, Rate) == 0x000020, "Member 'FAJBPickupGachaDetail::Rate' has a wrong offset!");
static_assert(offsetof(FAJBPickupGachaDetail, ItemType) == 0x000030, "Member 'FAJBPickupGachaDetail::ItemType' has a wrong offset!");
static_assert(offsetof(FAJBPickupGachaDetail, CharacterID) == 0x000034, "Member 'FAJBPickupGachaDetail::CharacterID' has a wrong offset!");

// ScriptStruct AJB.AJBGachaID
// 0x0020 (0x0020 - 0x0000)
struct FAJBGachaID final
{
public:
	struct FSaveCheckText                         UserID;                                            // 0x0000(0x0018)(NativeAccessSpecifierPublic)
	uint64                                        GachaID;                                           // 0x0018(0x0008)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBGachaID) == 0x000008, "Wrong alignment on FAJBGachaID");
static_assert(sizeof(FAJBGachaID) == 0x000020, "Wrong size on FAJBGachaID");
static_assert(offsetof(FAJBGachaID, UserID) == 0x000000, "Member 'FAJBGachaID::UserID' has a wrong offset!");
static_assert(offsetof(FAJBGachaID, GachaID) == 0x000018, "Member 'FAJBGachaID::GachaID' has a wrong offset!");

// ScriptStruct AJB.ShopEventSettings
// 0x0008 (0x0008 - 0x0000)
struct FShopEventSettings final
{
public:
	bool                                          bIsShopCompetition;                                // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EShopEventPlayerType                          PlayerType;                                        // 0x0001(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x2];                                        // 0x0002(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         MatchingKey;                                       // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FShopEventSettings) == 0x000004, "Wrong alignment on FShopEventSettings");
static_assert(sizeof(FShopEventSettings) == 0x000008, "Wrong size on FShopEventSettings");
static_assert(offsetof(FShopEventSettings, bIsShopCompetition) == 0x000000, "Member 'FShopEventSettings::bIsShopCompetition' has a wrong offset!");
static_assert(offsetof(FShopEventSettings, PlayerType) == 0x000001, "Member 'FShopEventSettings::PlayerType' has a wrong offset!");
static_assert(offsetof(FShopEventSettings, MatchingKey) == 0x000004, "Member 'FShopEventSettings::MatchingKey' has a wrong offset!");

// ScriptStruct AJB.AJBGachaDetail
// 0x0040 (0x0040 - 0x0000)
struct FAJBGachaDetail final
{
public:
	class FString                                 StartAt;                                           // 0x0000(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 EndAt;                                             // 0x0010(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<class FString>                         Raritiles;                                         // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FAJBPickupGachaDetail>          Pickups;                                           // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBGachaDetail) == 0x000008, "Wrong alignment on FAJBGachaDetail");
static_assert(sizeof(FAJBGachaDetail) == 0x000040, "Wrong size on FAJBGachaDetail");
static_assert(offsetof(FAJBGachaDetail, StartAt) == 0x000000, "Member 'FAJBGachaDetail::StartAt' has a wrong offset!");
static_assert(offsetof(FAJBGachaDetail, EndAt) == 0x000010, "Member 'FAJBGachaDetail::EndAt' has a wrong offset!");
static_assert(offsetof(FAJBGachaDetail, Raritiles) == 0x000020, "Member 'FAJBGachaDetail::Raritiles' has a wrong offset!");
static_assert(offsetof(FAJBGachaDetail, Pickups) == 0x000030, "Member 'FAJBGachaDetail::Pickups' has a wrong offset!");

// ScriptStruct AJB.AMHeadClerkInfo
// 0x0018 (0x0018 - 0x0000)
struct alignas(0x08) FAMHeadClerkInfo final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAMHeadClerkInfo) == 0x000008, "Wrong alignment on FAMHeadClerkInfo");
static_assert(sizeof(FAMHeadClerkInfo) == 0x000018, "Wrong size on FAMHeadClerkInfo");

// ScriptStruct AJB.AJBWordInfo
// 0x0040 (0x0048 - 0x0008)
struct FAJBWordInfo final : public FTableRowBase
{
public:
	int32                                         chara_id;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         reward_no;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 create_at;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 update_at;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBWordInfo) == 0x000008, "Wrong alignment on FAJBWordInfo");
static_assert(sizeof(FAJBWordInfo) == 0x000048, "Wrong size on FAJBWordInfo");
static_assert(offsetof(FAJBWordInfo, chara_id) == 0x000008, "Member 'FAJBWordInfo::chara_id' has a wrong offset!");
static_assert(offsetof(FAJBWordInfo, reward_no) == 0x00000C, "Member 'FAJBWordInfo::reward_no' has a wrong offset!");
static_assert(offsetof(FAJBWordInfo, Name) == 0x000010, "Member 'FAJBWordInfo::Name' has a wrong offset!");
static_assert(offsetof(FAJBWordInfo, Rarity) == 0x000020, "Member 'FAJBWordInfo::Rarity' has a wrong offset!");
static_assert(offsetof(FAJBWordInfo, create_at) == 0x000028, "Member 'FAJBWordInfo::create_at' has a wrong offset!");
static_assert(offsetof(FAJBWordInfo, update_at) == 0x000038, "Member 'FAJBWordInfo::update_at' has a wrong offset!");

// ScriptStruct AJB.AJBInformation
// 0x0018 (0x0018 - 0x0000)
struct FAJBInformation final
{
public:
	int32                                         InformationVersion;                                // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FSaveCheckText>                 Contents;                                          // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBInformation) == 0x000008, "Wrong alignment on FAJBInformation");
static_assert(sizeof(FAJBInformation) == 0x000018, "Wrong size on FAJBInformation");
static_assert(offsetof(FAJBInformation, InformationVersion) == 0x000000, "Member 'FAJBInformation::InformationVersion' has a wrong offset!");
static_assert(offsetof(FAJBInformation, Contents) == 0x000008, "Member 'FAJBInformation::Contents' has a wrong offset!");

// ScriptStruct AJB.BookKeepingData
// 0x0030 (0x0030 - 0x0000)
struct FBookKeepingData final
{
public:
	struct FTimespan                              PowerOnTime;                                       // 0x0000(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              TotalPlayTime;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FTimespan                              AveragePlayTime;                                   // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         PlayOnRatio;                                       // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayCount;                                         // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CoinCount;                                         // 0x0020(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         EmoneyCount;                                       // 0x0024(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ServiceCount;                                      // 0x0028(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         FreePlayCount;                                     // 0x002C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FBookKeepingData) == 0x000008, "Wrong alignment on FBookKeepingData");
static_assert(sizeof(FBookKeepingData) == 0x000030, "Wrong size on FBookKeepingData");
static_assert(offsetof(FBookKeepingData, PowerOnTime) == 0x000000, "Member 'FBookKeepingData::PowerOnTime' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, TotalPlayTime) == 0x000008, "Member 'FBookKeepingData::TotalPlayTime' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, AveragePlayTime) == 0x000010, "Member 'FBookKeepingData::AveragePlayTime' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, PlayOnRatio) == 0x000018, "Member 'FBookKeepingData::PlayOnRatio' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, PlayCount) == 0x00001C, "Member 'FBookKeepingData::PlayCount' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, CoinCount) == 0x000020, "Member 'FBookKeepingData::CoinCount' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, EmoneyCount) == 0x000024, "Member 'FBookKeepingData::EmoneyCount' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, ServiceCount) == 0x000028, "Member 'FBookKeepingData::ServiceCount' has a wrong offset!");
static_assert(offsetof(FBookKeepingData, FreePlayCount) == 0x00002C, "Member 'FBookKeepingData::FreePlayCount' has a wrong offset!");

// ScriptStruct AJB.AJBKeyMappingInfo
// 0x0020 (0x0028 - 0x0008)
struct FAJBKeyMappingInfo final : public FTableRowBase
{
public:
	struct FKey                                   Key;                                               // 0x0008(0x0018)(Edit, BlueprintVisible, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FName                                   ActionName;                                        // 0x0020(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBKeyMappingInfo) == 0x000008, "Wrong alignment on FAJBKeyMappingInfo");
static_assert(sizeof(FAJBKeyMappingInfo) == 0x000028, "Wrong size on FAJBKeyMappingInfo");
static_assert(offsetof(FAJBKeyMappingInfo, Key) == 0x000008, "Member 'FAJBKeyMappingInfo::Key' has a wrong offset!");
static_assert(offsetof(FAJBKeyMappingInfo, ActionName) == 0x000020, "Member 'FAJBKeyMappingInfo::ActionName' has a wrong offset!");

// ScriptStruct AJB.CloseTimeInfo
// 0x0008 (0x0008 - 0x0000)
struct FCloseTimeInfo final
{
public:
	int32                                         Houre;                                             // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minute;                                            // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloseTimeInfo) == 0x000004, "Wrong alignment on FCloseTimeInfo");
static_assert(sizeof(FCloseTimeInfo) == 0x000008, "Wrong size on FCloseTimeInfo");
static_assert(offsetof(FCloseTimeInfo, Houre) == 0x000000, "Member 'FCloseTimeInfo::Houre' has a wrong offset!");
static_assert(offsetof(FCloseTimeInfo, Minute) == 0x000004, "Member 'FCloseTimeInfo::Minute' has a wrong offset!");

// ScriptStruct AJB.CloseTimeSettings
// 0x0020 (0x0020 - 0x0000)
struct FCloseTimeSettings final
{
public:
	ECloseScheduleType                            CloseScheduleType;                                 // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FCloseTimeInfo>                 CloseTimes;                                        // 0x0008(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FCloseTimeInfo                         EveryDayCloseTime;                                 // 0x0018(0x0008)(BlueprintVisible, BlueprintReadOnly, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FCloseTimeSettings) == 0x000008, "Wrong alignment on FCloseTimeSettings");
static_assert(sizeof(FCloseTimeSettings) == 0x000020, "Wrong size on FCloseTimeSettings");
static_assert(offsetof(FCloseTimeSettings, CloseScheduleType) == 0x000000, "Member 'FCloseTimeSettings::CloseScheduleType' has a wrong offset!");
static_assert(offsetof(FCloseTimeSettings, CloseTimes) == 0x000008, "Member 'FCloseTimeSettings::CloseTimes' has a wrong offset!");
static_assert(offsetof(FCloseTimeSettings, EveryDayCloseTime) == 0x000018, "Member 'FCloseTimeSettings::EveryDayCloseTime' has a wrong offset!");

// ScriptStruct AJB.AJBSkillGuidePairInfo
// 0x0020 (0x0020 - 0x0000)
struct FAJBSkillGuidePairInfo final
{
public:
	EAJBPadIconType                               PadIcon;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   GuideText;                                         // 0x0008(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBSkillGuidePairInfo) == 0x000008, "Wrong alignment on FAJBSkillGuidePairInfo");
static_assert(sizeof(FAJBSkillGuidePairInfo) == 0x000020, "Wrong size on FAJBSkillGuidePairInfo");
static_assert(offsetof(FAJBSkillGuidePairInfo, PadIcon) == 0x000000, "Member 'FAJBSkillGuidePairInfo::PadIcon' has a wrong offset!");
static_assert(offsetof(FAJBSkillGuidePairInfo, GuideText) == 0x000008, "Member 'FAJBSkillGuidePairInfo::GuideText' has a wrong offset!");

// ScriptStruct AJB.StartLocationDetail
// 0x001C (0x001C - 0x0000)
struct FStartLocationDetail final
{
public:
	uint8                                         PlayerID;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FVector                                Location;                                          // 0x0004(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FRotator                               Rotation;                                          // 0x0010(0x000C)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartLocationDetail) == 0x000004, "Wrong alignment on FStartLocationDetail");
static_assert(sizeof(FStartLocationDetail) == 0x00001C, "Wrong size on FStartLocationDetail");
static_assert(offsetof(FStartLocationDetail, PlayerID) == 0x000000, "Member 'FStartLocationDetail::PlayerID' has a wrong offset!");
static_assert(offsetof(FStartLocationDetail, Location) == 0x000004, "Member 'FStartLocationDetail::Location' has a wrong offset!");
static_assert(offsetof(FStartLocationDetail, Rotation) == 0x000010, "Member 'FStartLocationDetail::Rotation' has a wrong offset!");

// ScriptStruct AJB.AMIOOptions
// 0x001A (0x001A - 0x0000)
struct alignas(0x02) FAMIOOptions final
{
public:
	uint8                                         Pad_0[0x18];                                       // 0x0000(0x0018)(Fixing Size After Last Property [ Dumper-7 ])
	uint8                                         LEDPowerNormal;                                    // 0x0018(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         LEDPowerAlive;                                     // 0x0019(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAMIOOptions) == 0x000002, "Wrong alignment on FAMIOOptions");
static_assert(sizeof(FAMIOOptions) == 0x00001A, "Wrong size on FAMIOOptions");
static_assert(offsetof(FAMIOOptions, LEDPowerNormal) == 0x000018, "Member 'FAMIOOptions::LEDPowerNormal' has a wrong offset!");
static_assert(offsetof(FAMIOOptions, LEDPowerAlive) == 0x000019, "Member 'FAMIOOptions::LEDPowerAlive' has a wrong offset!");

// ScriptStruct AJB.SoundOptions
// 0x000C (0x000C - 0x0000)
struct FSoundOptions final
{
public:
	int32                                         VolumeGame;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         VolumeAttract;                                     // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         OutputLevelIndexHeadphone;                         // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FSoundOptions) == 0x000004, "Wrong alignment on FSoundOptions");
static_assert(sizeof(FSoundOptions) == 0x00000C, "Wrong size on FSoundOptions");
static_assert(offsetof(FSoundOptions, VolumeGame) == 0x000000, "Member 'FSoundOptions::VolumeGame' has a wrong offset!");
static_assert(offsetof(FSoundOptions, VolumeAttract) == 0x000004, "Member 'FSoundOptions::VolumeAttract' has a wrong offset!");
static_assert(offsetof(FSoundOptions, OutputLevelIndexHeadphone) == 0x000008, "Member 'FSoundOptions::OutputLevelIndexHeadphone' has a wrong offset!");

// ScriptStruct AJB.AMVersion
// 0x0018 (0x0018 - 0x0000)
struct FAMVersion final
{
public:
	class FString                                 SoftwareVersion;                                   // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              OfflineDate;                                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAMVersion) == 0x000008, "Wrong alignment on FAMVersion");
static_assert(sizeof(FAMVersion) == 0x000018, "Wrong size on FAMVersion");
static_assert(offsetof(FAMVersion, SoftwareVersion) == 0x000000, "Member 'FAMVersion::SoftwareVersion' has a wrong offset!");
static_assert(offsetof(FAMVersion, OfflineDate) == 0x000010, "Member 'FAMVersion::OfflineDate' has a wrong offset!");

// ScriptStruct AJB.LastGameStatus
// 0x0038 (0x0038 - 0x0000)
struct FLastGameStatus final
{
public:
	int32                                         LeftCredit;                                        // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedCredit;                                        // 0x0004(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftEmoneyCredit;                                  // 0x0008(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedEmoneyCredit;                                  // 0x000C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftServiceCredit;                                 // 0x0010(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedServiceCredit;                                 // 0x0014(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         LeftPP;                                            // 0x0018(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         UsedPP;                                            // 0x001C(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 LastUserDataID;                                    // 0x0020(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bNeedHeadClerk;                                    // 0x0030(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_31[0x7];                                       // 0x0031(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FLastGameStatus) == 0x000008, "Wrong alignment on FLastGameStatus");
static_assert(sizeof(FLastGameStatus) == 0x000038, "Wrong size on FLastGameStatus");
static_assert(offsetof(FLastGameStatus, LeftCredit) == 0x000000, "Member 'FLastGameStatus::LeftCredit' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, UsedCredit) == 0x000004, "Member 'FLastGameStatus::UsedCredit' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, LeftEmoneyCredit) == 0x000008, "Member 'FLastGameStatus::LeftEmoneyCredit' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, UsedEmoneyCredit) == 0x00000C, "Member 'FLastGameStatus::UsedEmoneyCredit' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, LeftServiceCredit) == 0x000010, "Member 'FLastGameStatus::LeftServiceCredit' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, UsedServiceCredit) == 0x000014, "Member 'FLastGameStatus::UsedServiceCredit' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, LeftPP) == 0x000018, "Member 'FLastGameStatus::LeftPP' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, UsedPP) == 0x00001C, "Member 'FLastGameStatus::UsedPP' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, LastUserDataID) == 0x000020, "Member 'FLastGameStatus::LastUserDataID' has a wrong offset!");
static_assert(offsetof(FLastGameStatus, bNeedHeadClerk) == 0x000030, "Member 'FLastGameStatus::bNeedHeadClerk' has a wrong offset!");

// ScriptStruct AJB.AJBServerAliveInfo
// 0x0014 (0x0014 - 0x0000)
struct FAJBServerAliveInfo final
{
public:
	int32                                         SpanSeconds;                                       // 0x0000(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FCloseTimeInfo                         OfflineStartTime;                                  // 0x0004(0x0008)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	struct FCloseTimeInfo                         OfflineEndTime;                                    // 0x000C(0x0008)(IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBServerAliveInfo) == 0x000004, "Wrong alignment on FAJBServerAliveInfo");
static_assert(sizeof(FAJBServerAliveInfo) == 0x000014, "Wrong size on FAJBServerAliveInfo");
static_assert(offsetof(FAJBServerAliveInfo, SpanSeconds) == 0x000000, "Member 'FAJBServerAliveInfo::SpanSeconds' has a wrong offset!");
static_assert(offsetof(FAJBServerAliveInfo, OfflineStartTime) == 0x000004, "Member 'FAJBServerAliveInfo::OfflineStartTime' has a wrong offset!");
static_assert(offsetof(FAJBServerAliveInfo, OfflineEndTime) == 0x00000C, "Member 'FAJBServerAliveInfo::OfflineEndTime' has a wrong offset!");

// ScriptStruct AJB.AJBClosedAlertArcadeTimeSchedule
// 0x0014 (0x0014 - 0x0000)
struct FAJBClosedAlertArcadeTimeSchedule final
{
public:
	int32                                         Start;                                             // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         End;                                               // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBClosedAlertArcadeTimeBuyPPType            BuyPPType;                                         // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         LimitNumPossessionPP;                              // 0x000C(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableCoinLock;                                   // 0x0010(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableLimitGamePlay;                              // 0x0011(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableForcedToLeave;                              // 0x0012(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bLimitGacha;                                       // 0x0013(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBClosedAlertArcadeTimeSchedule) == 0x000004, "Wrong alignment on FAJBClosedAlertArcadeTimeSchedule");
static_assert(sizeof(FAJBClosedAlertArcadeTimeSchedule) == 0x000014, "Wrong size on FAJBClosedAlertArcadeTimeSchedule");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, Start) == 0x000000, "Member 'FAJBClosedAlertArcadeTimeSchedule::Start' has a wrong offset!");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, End) == 0x000004, "Member 'FAJBClosedAlertArcadeTimeSchedule::End' has a wrong offset!");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, BuyPPType) == 0x000008, "Member 'FAJBClosedAlertArcadeTimeSchedule::BuyPPType' has a wrong offset!");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, LimitNumPossessionPP) == 0x00000C, "Member 'FAJBClosedAlertArcadeTimeSchedule::LimitNumPossessionPP' has a wrong offset!");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, bEnableCoinLock) == 0x000010, "Member 'FAJBClosedAlertArcadeTimeSchedule::bEnableCoinLock' has a wrong offset!");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, bEnableLimitGamePlay) == 0x000011, "Member 'FAJBClosedAlertArcadeTimeSchedule::bEnableLimitGamePlay' has a wrong offset!");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, bEnableForcedToLeave) == 0x000012, "Member 'FAJBClosedAlertArcadeTimeSchedule::bEnableForcedToLeave' has a wrong offset!");
static_assert(offsetof(FAJBClosedAlertArcadeTimeSchedule, bLimitGacha) == 0x000013, "Member 'FAJBClosedAlertArcadeTimeSchedule::bLimitGacha' has a wrong offset!");

// ScriptStruct AJB.AJBCharacterActiveBehaviorInfo
// 0x0028 (0x0028 - 0x0000)
struct FAJBCharacterActiveBehaviorInfo final
{
public:
	ECharacterActiveBehavior                      CurrentBehavior;                                   // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	ECharacterActiveBehavior                      OldBehavior;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSpecialBreakDown;                                 // 0x0002(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bMainCharacter;                                    // 0x0003(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIgnoreCheckChanging;                              // 0x0004(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bBreakDownBoth;                                    // 0x0005(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_6[0x2];                                        // 0x0006(0x0002)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTagContainer                  FactorTags;                                        // 0x0008(0x0020)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBCharacterActiveBehaviorInfo) == 0x000008, "Wrong alignment on FAJBCharacterActiveBehaviorInfo");
static_assert(sizeof(FAJBCharacterActiveBehaviorInfo) == 0x000028, "Wrong size on FAJBCharacterActiveBehaviorInfo");
static_assert(offsetof(FAJBCharacterActiveBehaviorInfo, CurrentBehavior) == 0x000000, "Member 'FAJBCharacterActiveBehaviorInfo::CurrentBehavior' has a wrong offset!");
static_assert(offsetof(FAJBCharacterActiveBehaviorInfo, OldBehavior) == 0x000001, "Member 'FAJBCharacterActiveBehaviorInfo::OldBehavior' has a wrong offset!");
static_assert(offsetof(FAJBCharacterActiveBehaviorInfo, bSpecialBreakDown) == 0x000002, "Member 'FAJBCharacterActiveBehaviorInfo::bSpecialBreakDown' has a wrong offset!");
static_assert(offsetof(FAJBCharacterActiveBehaviorInfo, bMainCharacter) == 0x000003, "Member 'FAJBCharacterActiveBehaviorInfo::bMainCharacter' has a wrong offset!");
static_assert(offsetof(FAJBCharacterActiveBehaviorInfo, bIgnoreCheckChanging) == 0x000004, "Member 'FAJBCharacterActiveBehaviorInfo::bIgnoreCheckChanging' has a wrong offset!");
static_assert(offsetof(FAJBCharacterActiveBehaviorInfo, bBreakDownBoth) == 0x000005, "Member 'FAJBCharacterActiveBehaviorInfo::bBreakDownBoth' has a wrong offset!");
static_assert(offsetof(FAJBCharacterActiveBehaviorInfo, FactorTags) == 0x000008, "Member 'FAJBCharacterActiveBehaviorInfo::FactorTags' has a wrong offset!");

// ScriptStruct AJB.AJBStageAssetTableRow
// 0x00A0 (0x00A8 - 0x0008)
struct FAJBStageAssetTableRow final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture2D>              MapTexture;                                        // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         StageMaxSize;                                      // 0x0030(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_34[0x4];                                       // 0x0034(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TSubclassOf<class AActor>                     DamageAreaFXActorClass;                            // 0x0038(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           MainBGM;                                           // 0x0040(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           ClimaxBGM;                                         // 0x0048(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           OutsideDamageAreaSE;                               // 0x0050(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           InsideDamageAreaSE;                                // 0x0058(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FGameplayTag                           DamageAreaDamageSE;                                // 0x0060(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                PreLoadLevelPrimaryAssetIdList;                    // 0x0068(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	TArray<struct FPrimaryAssetId>                UnLoadLevelPrimaryAssetIdList;                     // 0x0078(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	float                                         DarkPlaceParameter;                                // 0x0088(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DistanceLimitParameter;                            // 0x008C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsExistsUnderwater;                                // 0x0090(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_91[0x3];                                       // 0x0091(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         MiniMapScale;                                      // 0x0094(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          IsNight;                                           // 0x0098(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_99[0x3];                                       // 0x0099(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	float                                         UnderwaterMaskingCylinderRadiusScale;              // 0x009C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderwaterMaskingCylinderHeightScale;              // 0x00A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         UnderwaterVisibleRadius;                           // 0x00A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBStageAssetTableRow) == 0x000008, "Wrong alignment on FAJBStageAssetTableRow");
static_assert(sizeof(FAJBStageAssetTableRow) == 0x0000A8, "Wrong size on FAJBStageAssetTableRow");
static_assert(offsetof(FAJBStageAssetTableRow, MapTexture) == 0x000008, "Member 'FAJBStageAssetTableRow::MapTexture' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, StageMaxSize) == 0x000030, "Member 'FAJBStageAssetTableRow::StageMaxSize' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, DamageAreaFXActorClass) == 0x000038, "Member 'FAJBStageAssetTableRow::DamageAreaFXActorClass' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, MainBGM) == 0x000040, "Member 'FAJBStageAssetTableRow::MainBGM' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, ClimaxBGM) == 0x000048, "Member 'FAJBStageAssetTableRow::ClimaxBGM' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, OutsideDamageAreaSE) == 0x000050, "Member 'FAJBStageAssetTableRow::OutsideDamageAreaSE' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, InsideDamageAreaSE) == 0x000058, "Member 'FAJBStageAssetTableRow::InsideDamageAreaSE' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, DamageAreaDamageSE) == 0x000060, "Member 'FAJBStageAssetTableRow::DamageAreaDamageSE' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, PreLoadLevelPrimaryAssetIdList) == 0x000068, "Member 'FAJBStageAssetTableRow::PreLoadLevelPrimaryAssetIdList' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, UnLoadLevelPrimaryAssetIdList) == 0x000078, "Member 'FAJBStageAssetTableRow::UnLoadLevelPrimaryAssetIdList' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, DarkPlaceParameter) == 0x000088, "Member 'FAJBStageAssetTableRow::DarkPlaceParameter' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, DistanceLimitParameter) == 0x00008C, "Member 'FAJBStageAssetTableRow::DistanceLimitParameter' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, IsExistsUnderwater) == 0x000090, "Member 'FAJBStageAssetTableRow::IsExistsUnderwater' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, MiniMapScale) == 0x000094, "Member 'FAJBStageAssetTableRow::MiniMapScale' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, IsNight) == 0x000098, "Member 'FAJBStageAssetTableRow::IsNight' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, UnderwaterMaskingCylinderRadiusScale) == 0x00009C, "Member 'FAJBStageAssetTableRow::UnderwaterMaskingCylinderRadiusScale' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, UnderwaterMaskingCylinderHeightScale) == 0x0000A0, "Member 'FAJBStageAssetTableRow::UnderwaterMaskingCylinderHeightScale' has a wrong offset!");
static_assert(offsetof(FAJBStageAssetTableRow, UnderwaterVisibleRadius) == 0x0000A4, "Member 'FAJBStageAssetTableRow::UnderwaterVisibleRadius' has a wrong offset!");

// ScriptStruct AJB.AJBDamageAreaTableRow
// 0x0020 (0x0028 - 0x0008)
struct FAJBDamageAreaTableRow final : public FTableRowBase
{
public:
	class FString                                 FileNameBase;                                      // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         StageNo;                                           // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShipping;                                         // 0x001C(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1D[0x3];                                       // 0x001D(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Rate;                                              // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsEnterLottery;                                   // 0x0024(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_25[0x3];                                       // 0x0025(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBDamageAreaTableRow) == 0x000008, "Wrong alignment on FAJBDamageAreaTableRow");
static_assert(sizeof(FAJBDamageAreaTableRow) == 0x000028, "Wrong size on FAJBDamageAreaTableRow");
static_assert(offsetof(FAJBDamageAreaTableRow, FileNameBase) == 0x000008, "Member 'FAJBDamageAreaTableRow::FileNameBase' has a wrong offset!");
static_assert(offsetof(FAJBDamageAreaTableRow, StageNo) == 0x000018, "Member 'FAJBDamageAreaTableRow::StageNo' has a wrong offset!");
static_assert(offsetof(FAJBDamageAreaTableRow, bShipping) == 0x00001C, "Member 'FAJBDamageAreaTableRow::bShipping' has a wrong offset!");
static_assert(offsetof(FAJBDamageAreaTableRow, Rate) == 0x000020, "Member 'FAJBDamageAreaTableRow::Rate' has a wrong offset!");
static_assert(offsetof(FAJBDamageAreaTableRow, bIsEnterLottery) == 0x000024, "Member 'FAJBDamageAreaTableRow::bIsEnterLottery' has a wrong offset!");

// ScriptStruct AJB.AJBBattleSettings
// 0x0008 (0x0008 - 0x0000)
struct FAJBBattleSettings final
{
public:
	uint8                                         AILevel;                                           // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x3];                                        // 0x0001(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         DamageAreaType;                                    // 0x0004(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBBattleSettings) == 0x000004, "Wrong alignment on FAJBBattleSettings");
static_assert(sizeof(FAJBBattleSettings) == 0x000008, "Wrong size on FAJBBattleSettings");
static_assert(offsetof(FAJBBattleSettings, AILevel) == 0x000000, "Member 'FAJBBattleSettings::AILevel' has a wrong offset!");
static_assert(offsetof(FAJBBattleSettings, DamageAreaType) == 0x000004, "Member 'FAJBBattleSettings::DamageAreaType' has a wrong offset!");

// ScriptStruct AJB.WwiseVoiceEventInfo
// 0x0018 (0x0020 - 0x0008)
struct FWwiseVoiceEventInfo final : public FTableRowBase
{
public:
	class FString                                 EventName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Priority;                                          // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FWwiseVoiceEventInfo) == 0x000008, "Wrong alignment on FWwiseVoiceEventInfo");
static_assert(sizeof(FWwiseVoiceEventInfo) == 0x000020, "Wrong size on FWwiseVoiceEventInfo");
static_assert(offsetof(FWwiseVoiceEventInfo, EventName) == 0x000008, "Member 'FWwiseVoiceEventInfo::EventName' has a wrong offset!");
static_assert(offsetof(FWwiseVoiceEventInfo, Priority) == 0x000018, "Member 'FWwiseVoiceEventInfo::Priority' has a wrong offset!");

// ScriptStruct AJB.AJBLockOnTargetInfo
// 0x0018 (0x0018 - 0x0000)
struct FAJBLockOnTargetInfo final
{
public:
	class AActor*                                 Target;                                            // 0x0000(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         FocusedTimer;                                      // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OccludedTimer;                                     // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         OutOfScreenTimer;                                  // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBLockOnTargetInfo) == 0x000008, "Wrong alignment on FAJBLockOnTargetInfo");
static_assert(sizeof(FAJBLockOnTargetInfo) == 0x000018, "Wrong size on FAJBLockOnTargetInfo");
static_assert(offsetof(FAJBLockOnTargetInfo, Target) == 0x000000, "Member 'FAJBLockOnTargetInfo::Target' has a wrong offset!");
static_assert(offsetof(FAJBLockOnTargetInfo, FocusedTimer) == 0x000008, "Member 'FAJBLockOnTargetInfo::FocusedTimer' has a wrong offset!");
static_assert(offsetof(FAJBLockOnTargetInfo, OccludedTimer) == 0x00000C, "Member 'FAJBLockOnTargetInfo::OccludedTimer' has a wrong offset!");
static_assert(offsetof(FAJBLockOnTargetInfo, OutOfScreenTimer) == 0x000010, "Member 'FAJBLockOnTargetInfo::OutOfScreenTimer' has a wrong offset!");

// ScriptStruct AJB.AJBBitesTheDustRewindInfo
// 0x0010 (0x0010 - 0x0000)
struct FAJBBitesTheDustRewindInfo final
{
public:
	struct FDateTime                              BeforeDateTime;                                    // 0x0000(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AfterSerialNumber;                                 // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_C[0x4];                                        // 0x000C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBBitesTheDustRewindInfo) == 0x000008, "Wrong alignment on FAJBBitesTheDustRewindInfo");
static_assert(sizeof(FAJBBitesTheDustRewindInfo) == 0x000010, "Wrong size on FAJBBitesTheDustRewindInfo");
static_assert(offsetof(FAJBBitesTheDustRewindInfo, BeforeDateTime) == 0x000000, "Member 'FAJBBitesTheDustRewindInfo::BeforeDateTime' has a wrong offset!");
static_assert(offsetof(FAJBBitesTheDustRewindInfo, AfterSerialNumber) == 0x000008, "Member 'FAJBBitesTheDustRewindInfo::AfterSerialNumber' has a wrong offset!");

// ScriptStruct AJB.AJBPoseInfo
// 0x0040 (0x0048 - 0x0008)
struct FAJBPoseInfo final : public FTableRowBase
{
public:
	int32                                         chara_id;                                          // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         reward_no;                                         // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 Name;                                              // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rarity;                                            // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 create_at;                                         // 0x0028(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 update_at;                                         // 0x0038(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBPoseInfo) == 0x000008, "Wrong alignment on FAJBPoseInfo");
static_assert(sizeof(FAJBPoseInfo) == 0x000048, "Wrong size on FAJBPoseInfo");
static_assert(offsetof(FAJBPoseInfo, chara_id) == 0x000008, "Member 'FAJBPoseInfo::chara_id' has a wrong offset!");
static_assert(offsetof(FAJBPoseInfo, reward_no) == 0x00000C, "Member 'FAJBPoseInfo::reward_no' has a wrong offset!");
static_assert(offsetof(FAJBPoseInfo, Name) == 0x000010, "Member 'FAJBPoseInfo::Name' has a wrong offset!");
static_assert(offsetof(FAJBPoseInfo, Rarity) == 0x000020, "Member 'FAJBPoseInfo::Rarity' has a wrong offset!");
static_assert(offsetof(FAJBPoseInfo, create_at) == 0x000028, "Member 'FAJBPoseInfo::create_at' has a wrong offset!");
static_assert(offsetof(FAJBPoseInfo, update_at) == 0x000038, "Member 'FAJBPoseInfo::update_at' has a wrong offset!");

// ScriptStruct AJB.AJBActionInfo
// 0x0002 (0x0002 - 0x0000)
struct FAJBActionInfo final
{
public:
	bool                                          bActive;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bTriggeredByStand;                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBActionInfo) == 0x000001, "Wrong alignment on FAJBActionInfo");
static_assert(sizeof(FAJBActionInfo) == 0x000002, "Wrong size on FAJBActionInfo");
static_assert(offsetof(FAJBActionInfo, bActive) == 0x000000, "Member 'FAJBActionInfo::bActive' has a wrong offset!");
static_assert(offsetof(FAJBActionInfo, bTriggeredByStand) == 0x000001, "Member 'FAJBActionInfo::bTriggeredByStand' has a wrong offset!");

// ScriptStruct AJB.AJBCharacterActiveBehaviorFactorInfo
// 0x0008 (0x0010 - 0x0008)
struct FAJBCharacterActiveBehaviorFactorInfo final : public FTableRowBase
{
public:
	bool                                          bSpecialBreakDown;                                 // 0x0008(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x7];                                        // 0x0009(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBCharacterActiveBehaviorFactorInfo) == 0x000008, "Wrong alignment on FAJBCharacterActiveBehaviorFactorInfo");
static_assert(sizeof(FAJBCharacterActiveBehaviorFactorInfo) == 0x000010, "Wrong size on FAJBCharacterActiveBehaviorFactorInfo");
static_assert(offsetof(FAJBCharacterActiveBehaviorFactorInfo, bSpecialBreakDown) == 0x000008, "Member 'FAJBCharacterActiveBehaviorFactorInfo::bSpecialBreakDown' has a wrong offset!");

// ScriptStruct AJB.AJBSkillGuideInfo
// 0x0020 (0x0028 - 0x0008)
struct FAJBSkillGuideInfo final : public FTableRowBase
{
public:
	class FName                                   GuideId;                                           // 0x0008(0x0008)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	float                                         DisplayTimer;                                      // 0x0010(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_14[0x4];                                       // 0x0014(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FAJBSkillGuidePairInfo>         GuidePairList;                                     // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBSkillGuideInfo) == 0x000008, "Wrong alignment on FAJBSkillGuideInfo");
static_assert(sizeof(FAJBSkillGuideInfo) == 0x000028, "Wrong size on FAJBSkillGuideInfo");
static_assert(offsetof(FAJBSkillGuideInfo, GuideId) == 0x000008, "Member 'FAJBSkillGuideInfo::GuideId' has a wrong offset!");
static_assert(offsetof(FAJBSkillGuideInfo, DisplayTimer) == 0x000010, "Member 'FAJBSkillGuideInfo::DisplayTimer' has a wrong offset!");
static_assert(offsetof(FAJBSkillGuideInfo, GuidePairList) == 0x000018, "Member 'FAJBSkillGuideInfo::GuidePairList' has a wrong offset!");

// ScriptStruct AJB.StartLocationInfo
// 0x0018 (0x0018 - 0x0000)
struct FStartLocationInfo final
{
public:
	int32                                         CurrentIndex;                                      // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_4[0x4];                                        // 0x0004(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FStartLocationDetail>           Dtails;                                            // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartLocationInfo) == 0x000008, "Wrong alignment on FStartLocationInfo");
static_assert(sizeof(FStartLocationInfo) == 0x000018, "Wrong size on FStartLocationInfo");
static_assert(offsetof(FStartLocationInfo, CurrentIndex) == 0x000000, "Member 'FStartLocationInfo::CurrentIndex' has a wrong offset!");
static_assert(offsetof(FStartLocationInfo, Dtails) == 0x000008, "Member 'FStartLocationInfo::Dtails' has a wrong offset!");

// ScriptStruct AJB.AJBMatchSchedule
// 0x0018 (0x0018 - 0x0000)
struct FAJBMatchSchedule final
{
public:
	bool                                          bIsOpenMatch;                                      // 0x0000(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              StartDateTime;                                     // 0x0008(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              EndDateTime;                                       // 0x0010(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBMatchSchedule) == 0x000008, "Wrong alignment on FAJBMatchSchedule");
static_assert(sizeof(FAJBMatchSchedule) == 0x000018, "Wrong size on FAJBMatchSchedule");
static_assert(offsetof(FAJBMatchSchedule, bIsOpenMatch) == 0x000000, "Member 'FAJBMatchSchedule::bIsOpenMatch' has a wrong offset!");
static_assert(offsetof(FAJBMatchSchedule, StartDateTime) == 0x000008, "Member 'FAJBMatchSchedule::StartDateTime' has a wrong offset!");
static_assert(offsetof(FAJBMatchSchedule, EndDateTime) == 0x000010, "Member 'FAJBMatchSchedule::EndDateTime' has a wrong offset!");

// ScriptStruct AJB.AJBOperationParameterInformation
// 0x0020 (0x0020 - 0x0000)
struct alignas(0x08) FAJBOperationParameterInformation final
{
public:
	uint8                                         Pad_0[0x20];                                       // 0x0000(0x0020)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBOperationParameterInformation) == 0x000008, "Wrong alignment on FAJBOperationParameterInformation");
static_assert(sizeof(FAJBOperationParameterInformation) == 0x000020, "Wrong size on FAJBOperationParameterInformation");

// ScriptStruct AJB.AJBDefaultEmoteInfo
// 0x0028 (0x0030 - 0x0008)
struct FAJBDefaultEmoteInfo final : public FTableRowBase
{
public:
	int32                                         default_pose_id;                                   // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         default_word_id;                                   // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 create_at;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 update_at;                                         // 0x0020(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBDefaultEmoteInfo) == 0x000008, "Wrong alignment on FAJBDefaultEmoteInfo");
static_assert(sizeof(FAJBDefaultEmoteInfo) == 0x000030, "Wrong size on FAJBDefaultEmoteInfo");
static_assert(offsetof(FAJBDefaultEmoteInfo, default_pose_id) == 0x000008, "Member 'FAJBDefaultEmoteInfo::default_pose_id' has a wrong offset!");
static_assert(offsetof(FAJBDefaultEmoteInfo, default_word_id) == 0x00000C, "Member 'FAJBDefaultEmoteInfo::default_word_id' has a wrong offset!");
static_assert(offsetof(FAJBDefaultEmoteInfo, create_at) == 0x000010, "Member 'FAJBDefaultEmoteInfo::create_at' has a wrong offset!");
static_assert(offsetof(FAJBDefaultEmoteInfo, update_at) == 0x000020, "Member 'FAJBDefaultEmoteInfo::update_at' has a wrong offset!");

// ScriptStruct AJB.AJBStageAreaTitleInfo
// 0x0040 (0x0048 - 0x0008)
struct FAJBStageAreaTitleInfo final : public FTableRowBase
{
public:
	int32                                         StageId;                                           // 0x0008(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         AreaId;                                            // 0x000C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FText                                   Title;                                             // 0x0010(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   SubTitle;                                          // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	bool                                          bSelectable;                                       // 0x0040(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_41[0x7];                                       // 0x0041(0x0007)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBStageAreaTitleInfo) == 0x000008, "Wrong alignment on FAJBStageAreaTitleInfo");
static_assert(sizeof(FAJBStageAreaTitleInfo) == 0x000048, "Wrong size on FAJBStageAreaTitleInfo");
static_assert(offsetof(FAJBStageAreaTitleInfo, StageId) == 0x000008, "Member 'FAJBStageAreaTitleInfo::StageId' has a wrong offset!");
static_assert(offsetof(FAJBStageAreaTitleInfo, AreaId) == 0x00000C, "Member 'FAJBStageAreaTitleInfo::AreaId' has a wrong offset!");
static_assert(offsetof(FAJBStageAreaTitleInfo, Title) == 0x000010, "Member 'FAJBStageAreaTitleInfo::Title' has a wrong offset!");
static_assert(offsetof(FAJBStageAreaTitleInfo, SubTitle) == 0x000028, "Member 'FAJBStageAreaTitleInfo::SubTitle' has a wrong offset!");
static_assert(offsetof(FAJBStageAreaTitleInfo, bSelectable) == 0x000040, "Member 'FAJBStageAreaTitleInfo::bSelectable' has a wrong offset!");

// ScriptStruct AJB.AJBSkillIconInfo
// 0x0030 (0x0038 - 0x0008)
struct FAJBSkillIconInfo final : public FTableRowBase
{
public:
	TSoftObjectPtr<class UTexture>                SkillIconTexturePtr;                               // 0x0008(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInVisibleIconCount;                               // 0x0030(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bInVisibleIconPad;                                 // 0x0031(0x0001)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_32[0x6];                                       // 0x0032(0x0006)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBSkillIconInfo) == 0x000008, "Wrong alignment on FAJBSkillIconInfo");
static_assert(sizeof(FAJBSkillIconInfo) == 0x000038, "Wrong size on FAJBSkillIconInfo");
static_assert(offsetof(FAJBSkillIconInfo, SkillIconTexturePtr) == 0x000008, "Member 'FAJBSkillIconInfo::SkillIconTexturePtr' has a wrong offset!");
static_assert(offsetof(FAJBSkillIconInfo, bInVisibleIconCount) == 0x000030, "Member 'FAJBSkillIconInfo::bInVisibleIconCount' has a wrong offset!");
static_assert(offsetof(FAJBSkillIconInfo, bInVisibleIconPad) == 0x000031, "Member 'FAJBSkillIconInfo::bInVisibleIconPad' has a wrong offset!");

// ScriptStruct AJB.AJBCharacterInfo
// 0x00E0 (0x00E8 - 0x0008)
struct FAJBCharacterInfo final : public FTableRowBase
{
public:
	struct FGameplayTag                           CharaTag;                                          // 0x0008(0x0008)(Edit, BlueprintVisible, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 StandName;                                         // 0x0010(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaIndex;                                        // 0x0020(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_24[0x4];                                       // 0x0024(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FText                                   DisplayCharaName;                                  // 0x0028(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	class FText                                   DisplayStandName;                                  // 0x0040(0x0018)(Edit, BlueprintVisible, NativeAccessSpecifierPublic)
	ECharacterBattleType                          CharacterType;                                     // 0x0058(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x3];                                       // 0x0059(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         Difficulty;                                        // 0x005C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                CharaIconTexturePtr;                               // 0x0060(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftClassPtr<class UClass>                   MannequinPtr;                                      // 0x0088(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture>                CharaCardTexturePtr;                               // 0x00B0(0x0028)(Edit, BlueprintVisible, BlueprintReadOnly, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bAvailableNegotiationsCharacter;                   // 0x00D8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bSelectable;                                       // 0x00D9(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bUseNPC;                                           // 0x00DA(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bShipping;                                         // 0x00DB(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         CharaSelectIndex;                                  // 0x00DC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         ScoreBorderGroup;                                  // 0x00E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_E4[0x4];                                       // 0x00E4(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBCharacterInfo) == 0x000008, "Wrong alignment on FAJBCharacterInfo");
static_assert(sizeof(FAJBCharacterInfo) == 0x0000E8, "Wrong size on FAJBCharacterInfo");
static_assert(offsetof(FAJBCharacterInfo, CharaTag) == 0x000008, "Member 'FAJBCharacterInfo::CharaTag' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, StandName) == 0x000010, "Member 'FAJBCharacterInfo::StandName' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, CharaIndex) == 0x000020, "Member 'FAJBCharacterInfo::CharaIndex' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, DisplayCharaName) == 0x000028, "Member 'FAJBCharacterInfo::DisplayCharaName' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, DisplayStandName) == 0x000040, "Member 'FAJBCharacterInfo::DisplayStandName' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, CharacterType) == 0x000058, "Member 'FAJBCharacterInfo::CharacterType' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, Difficulty) == 0x00005C, "Member 'FAJBCharacterInfo::Difficulty' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, CharaIconTexturePtr) == 0x000060, "Member 'FAJBCharacterInfo::CharaIconTexturePtr' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, MannequinPtr) == 0x000088, "Member 'FAJBCharacterInfo::MannequinPtr' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, CharaCardTexturePtr) == 0x0000B0, "Member 'FAJBCharacterInfo::CharaCardTexturePtr' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, bAvailableNegotiationsCharacter) == 0x0000D8, "Member 'FAJBCharacterInfo::bAvailableNegotiationsCharacter' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, bSelectable) == 0x0000D9, "Member 'FAJBCharacterInfo::bSelectable' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, bUseNPC) == 0x0000DA, "Member 'FAJBCharacterInfo::bUseNPC' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, bShipping) == 0x0000DB, "Member 'FAJBCharacterInfo::bShipping' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, CharaSelectIndex) == 0x0000DC, "Member 'FAJBCharacterInfo::CharaSelectIndex' has a wrong offset!");
static_assert(offsetof(FAJBCharacterInfo, ScoreBorderGroup) == 0x0000E0, "Member 'FAJBCharacterInfo::ScoreBorderGroup' has a wrong offset!");

// ScriptStruct AJB.EmoteData
// 0x0028 (0x0028 - 0x0000)
struct FEmoteData final
{
public:
	uint8                                         emoteId;                                           // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         voiceId;                                           // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 EmoteName;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 VoiceName;                                         // 0x0018(0x0010)(Edit, BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FEmoteData) == 0x000008, "Wrong alignment on FEmoteData");
static_assert(sizeof(FEmoteData) == 0x000028, "Wrong size on FEmoteData");
static_assert(offsetof(FEmoteData, emoteId) == 0x000000, "Member 'FEmoteData::emoteId' has a wrong offset!");
static_assert(offsetof(FEmoteData, voiceId) == 0x000001, "Member 'FEmoteData::voiceId' has a wrong offset!");
static_assert(offsetof(FEmoteData, EmoteName) == 0x000008, "Member 'FEmoteData::EmoteName' has a wrong offset!");
static_assert(offsetof(FEmoteData, VoiceName) == 0x000018, "Member 'FEmoteData::VoiceName' has a wrong offset!");

// ScriptStruct AJB.CustomData
// 0x0020 (0x0020 - 0x0000)
struct FCustomData final
{
public:
	uint8                                         charaSkinId;                                       // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         standSkinId;                                       // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_2[0x6];                                        // 0x0002(0x0006)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FEmoteData>                     EmoteData;                                         // 0x0008(0x0010)(Edit, BlueprintVisible, ZeroConstructor, NativeAccessSpecifierPublic)
	int32                                         KillCount;                                         // 0x0018(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1C[0x4];                                       // 0x001C(0x0004)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FCustomData) == 0x000008, "Wrong alignment on FCustomData");
static_assert(sizeof(FCustomData) == 0x000020, "Wrong size on FCustomData");
static_assert(offsetof(FCustomData, charaSkinId) == 0x000000, "Member 'FCustomData::charaSkinId' has a wrong offset!");
static_assert(offsetof(FCustomData, standSkinId) == 0x000001, "Member 'FCustomData::standSkinId' has a wrong offset!");
static_assert(offsetof(FCustomData, EmoteData) == 0x000008, "Member 'FCustomData::EmoteData' has a wrong offset!");
static_assert(offsetof(FCustomData, KillCount) == 0x000018, "Member 'FCustomData::KillCount' has a wrong offset!");

// ScriptStruct AJB.StartLocation
// 0x0002 (0x0002 - 0x0000)
struct FStartLocation final
{
public:
	uint8                                         X;                                                 // 0x0000(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Y;                                                 // 0x0001(0x0001)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FStartLocation) == 0x000001, "Wrong alignment on FStartLocation");
static_assert(sizeof(FStartLocation) == 0x000002, "Wrong size on FStartLocation");
static_assert(offsetof(FStartLocation, X) == 0x000000, "Member 'FStartLocation::X' has a wrong offset!");
static_assert(offsetof(FStartLocation, Y) == 0x000001, "Member 'FStartLocation::Y' has a wrong offset!");

// ScriptStruct AJB.MatchingPlayerInfo
// 0x0088 (0x0088 - 0x0000)
struct FMatchingPlayerInfo final
{
public:
	uint8                                         PlayerID;                                          // 0x0000(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_1[0x7];                                        // 0x0001(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 GameServerUserID;                                  // 0x0008(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         TeamID;                                            // 0x0018(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_19[0x7];                                       // 0x0019(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 TeamHostUserID;                                    // 0x0020(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerName;                                        // 0x0030(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerIconID;                                      // 0x0040(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         PlayerLevel;                                       // 0x0044(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 PlayerTitle;                                       // 0x0048(0x0010)(BlueprintVisible, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         CharactorID;                                       // 0x0058(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_59[0x7];                                       // 0x0059(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FCustomData                            CustomData;                                        // 0x0060(0x0020)(BlueprintVisible, NativeAccessSpecifierPublic)
	EInGameProgressID                             InGameProgressID;                                  // 0x0080(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FStartLocation                         StartLocation;                                     // 0x0081(0x0002)(BlueprintVisible, IsPlainOldData, NoDestructor, NativeAccessSpecifierPublic)
	bool                                          bIsCameraMode;                                     // 0x0083(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Rate;                                              // 0x0084(0x0004)(ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FMatchingPlayerInfo) == 0x000008, "Wrong alignment on FMatchingPlayerInfo");
static_assert(sizeof(FMatchingPlayerInfo) == 0x000088, "Wrong size on FMatchingPlayerInfo");
static_assert(offsetof(FMatchingPlayerInfo, PlayerID) == 0x000000, "Member 'FMatchingPlayerInfo::PlayerID' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, GameServerUserID) == 0x000008, "Member 'FMatchingPlayerInfo::GameServerUserID' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, TeamID) == 0x000018, "Member 'FMatchingPlayerInfo::TeamID' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, TeamHostUserID) == 0x000020, "Member 'FMatchingPlayerInfo::TeamHostUserID' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, PlayerName) == 0x000030, "Member 'FMatchingPlayerInfo::PlayerName' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, PlayerIconID) == 0x000040, "Member 'FMatchingPlayerInfo::PlayerIconID' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, PlayerLevel) == 0x000044, "Member 'FMatchingPlayerInfo::PlayerLevel' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, PlayerTitle) == 0x000048, "Member 'FMatchingPlayerInfo::PlayerTitle' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, CharactorID) == 0x000058, "Member 'FMatchingPlayerInfo::CharactorID' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, CustomData) == 0x000060, "Member 'FMatchingPlayerInfo::CustomData' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, InGameProgressID) == 0x000080, "Member 'FMatchingPlayerInfo::InGameProgressID' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, StartLocation) == 0x000081, "Member 'FMatchingPlayerInfo::StartLocation' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, bIsCameraMode) == 0x000083, "Member 'FMatchingPlayerInfo::bIsCameraMode' has a wrong offset!");
static_assert(offsetof(FMatchingPlayerInfo, Rate) == 0x000084, "Member 'FMatchingPlayerInfo::Rate' has a wrong offset!");

// ScriptStruct AJB.RoomPlayerInfo
// 0x0110 (0x0110 - 0x0000)
struct FRoomPlayerInfo final
{
public:
	struct FMatchingPlayerInfo                    HostPlayerInfo;                                    // 0x0000(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FMatchingPlayerInfo                    GuestPlayerInfo;                                   // 0x0088(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
};
static_assert(alignof(FRoomPlayerInfo) == 0x000008, "Wrong alignment on FRoomPlayerInfo");
static_assert(sizeof(FRoomPlayerInfo) == 0x000110, "Wrong size on FRoomPlayerInfo");
static_assert(offsetof(FRoomPlayerInfo, HostPlayerInfo) == 0x000000, "Member 'FRoomPlayerInfo::HostPlayerInfo' has a wrong offset!");
static_assert(offsetof(FRoomPlayerInfo, GuestPlayerInfo) == 0x000088, "Member 'FRoomPlayerInfo::GuestPlayerInfo' has a wrong offset!");

// ScriptStruct AJB.ControllerSettings
// 0x000C (0x000C - 0x0000)
struct FControllerSettings final
{
public:
	int32                                         CameraSensitivity;                                 // 0x0000(0x0004)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCameraUpDownReverse;                            // 0x0004(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsCameraLeftRightReverse;                         // 0x0005(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	EAJBKeyConfigType                             KeyConfigType;                                     // 0x0006(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableAutoDash;                                   // 0x0007(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bEnableEasyOperation;                              // 0x0008(0x0001)(BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_9[0x3];                                        // 0x0009(0x0003)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FControllerSettings) == 0x000004, "Wrong alignment on FControllerSettings");
static_assert(sizeof(FControllerSettings) == 0x00000C, "Wrong size on FControllerSettings");
static_assert(offsetof(FControllerSettings, CameraSensitivity) == 0x000000, "Member 'FControllerSettings::CameraSensitivity' has a wrong offset!");
static_assert(offsetof(FControllerSettings, bIsCameraUpDownReverse) == 0x000004, "Member 'FControllerSettings::bIsCameraUpDownReverse' has a wrong offset!");
static_assert(offsetof(FControllerSettings, bIsCameraLeftRightReverse) == 0x000005, "Member 'FControllerSettings::bIsCameraLeftRightReverse' has a wrong offset!");
static_assert(offsetof(FControllerSettings, KeyConfigType) == 0x000006, "Member 'FControllerSettings::KeyConfigType' has a wrong offset!");
static_assert(offsetof(FControllerSettings, bEnableAutoDash) == 0x000007, "Member 'FControllerSettings::bEnableAutoDash' has a wrong offset!");
static_assert(offsetof(FControllerSettings, bEnableEasyOperation) == 0x000008, "Member 'FControllerSettings::bEnableEasyOperation' has a wrong offset!");

// ScriptStruct AJB.PlayerLoginInfo
// 0x0150 (0x0150 - 0x0000)
struct FPlayerLoginInfo final
{
public:
	class FString                                 SessionID;                                         // 0x0000(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 UserDataID;                                        // 0x0010(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsGuest;                                          // 0x0020(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_21[0x7];                                       // 0x0021(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 AccessCode;                                        // 0x0028(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	bool                                          bIsBNCard;                                         // 0x0038(0x0001)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_39[0x7];                                       // 0x0039(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LoginTime;                                         // 0x0040(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              ExtendBPUnlockTime;                                // 0x0048(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Exp;                                               // 0x0050(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         TicketNum;                                         // 0x0054(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	class FString                                 MatchingID;                                        // 0x0058(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FCustomData>                    CustomData;                                        // 0x0068(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
	struct FMatchingPlayerInfo                    MatchingPlayerInfo;                                // 0x0078(0x0088)(BlueprintVisible, BlueprintReadOnly, NativeAccessSpecifierPublic)
	struct FControllerSettings                    ControllerSettings;                                // 0x0100(0x000C)(BlueprintVisible, BlueprintReadOnly, NoDestructor, NativeAccessSpecifierPublic)
	uint8                                         Pad_10C[0x4];                                      // 0x010C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 SyncServerHostName;                                // 0x0110(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         SyncServerPort;                                    // 0x0120(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_124[0x4];                                      // 0x0124(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class FString                                 ResultAt;                                          // 0x0128(0x0010)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	struct FDateTime                              LastMovieUploadedTime;                             // 0x0138(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RequiredTicketNumForReward;                        // 0x0140(0x0004)(BlueprintVisible, BlueprintReadOnly, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	uint8                                         Pad_144[0x4];                                      // 0x0144(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              LogoutTime;                                        // 0x0148(0x0008)(BlueprintVisible, BlueprintReadOnly, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FPlayerLoginInfo) == 0x000008, "Wrong alignment on FPlayerLoginInfo");
static_assert(sizeof(FPlayerLoginInfo) == 0x000150, "Wrong size on FPlayerLoginInfo");
static_assert(offsetof(FPlayerLoginInfo, SessionID) == 0x000000, "Member 'FPlayerLoginInfo::SessionID' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, UserDataID) == 0x000010, "Member 'FPlayerLoginInfo::UserDataID' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, bIsGuest) == 0x000020, "Member 'FPlayerLoginInfo::bIsGuest' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, AccessCode) == 0x000028, "Member 'FPlayerLoginInfo::AccessCode' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, bIsBNCard) == 0x000038, "Member 'FPlayerLoginInfo::bIsBNCard' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, LoginTime) == 0x000040, "Member 'FPlayerLoginInfo::LoginTime' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, ExtendBPUnlockTime) == 0x000048, "Member 'FPlayerLoginInfo::ExtendBPUnlockTime' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, Exp) == 0x000050, "Member 'FPlayerLoginInfo::Exp' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, TicketNum) == 0x000054, "Member 'FPlayerLoginInfo::TicketNum' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, MatchingID) == 0x000058, "Member 'FPlayerLoginInfo::MatchingID' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, CustomData) == 0x000068, "Member 'FPlayerLoginInfo::CustomData' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, MatchingPlayerInfo) == 0x000078, "Member 'FPlayerLoginInfo::MatchingPlayerInfo' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, ControllerSettings) == 0x000100, "Member 'FPlayerLoginInfo::ControllerSettings' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, SyncServerHostName) == 0x000110, "Member 'FPlayerLoginInfo::SyncServerHostName' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, SyncServerPort) == 0x000120, "Member 'FPlayerLoginInfo::SyncServerPort' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, ResultAt) == 0x000128, "Member 'FPlayerLoginInfo::ResultAt' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, LastMovieUploadedTime) == 0x000138, "Member 'FPlayerLoginInfo::LastMovieUploadedTime' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, RequiredTicketNumForReward) == 0x000140, "Member 'FPlayerLoginInfo::RequiredTicketNumForReward' has a wrong offset!");
static_assert(offsetof(FPlayerLoginInfo, LogoutTime) == 0x000148, "Member 'FPlayerLoginInfo::LogoutTime' has a wrong offset!");

// ScriptStruct AJB.AJBRewardIconInfo
// 0x0030 (0x0030 - 0x0000)
struct FAJBRewardIconInfo final
{
public:
	int32                                         UniqueId;                                          // 0x0000(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         RewardNo;                                          // 0x0004(0x0004)(Edit, BlueprintVisible, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TSoftObjectPtr<class UTexture2D>              RewardTexture;                                     // 0x0008(0x0028)(Edit, BlueprintVisible, UObjectWrapper, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBRewardIconInfo) == 0x000008, "Wrong alignment on FAJBRewardIconInfo");
static_assert(sizeof(FAJBRewardIconInfo) == 0x000030, "Wrong size on FAJBRewardIconInfo");
static_assert(offsetof(FAJBRewardIconInfo, UniqueId) == 0x000000, "Member 'FAJBRewardIconInfo::UniqueId' has a wrong offset!");
static_assert(offsetof(FAJBRewardIconInfo, RewardNo) == 0x000004, "Member 'FAJBRewardIconInfo::RewardNo' has a wrong offset!");
static_assert(offsetof(FAJBRewardIconInfo, RewardTexture) == 0x000008, "Member 'FAJBRewardIconInfo::RewardTexture' has a wrong offset!");

// ScriptStruct AJB.AJBRewardIconInfoList
// 0x0010 (0x0010 - 0x0000)
struct FAJBRewardIconInfoList final
{
public:
	TArray<struct FAJBRewardIconInfo>             IconInfoList;                                      // 0x0000(0x0010)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBRewardIconInfoList) == 0x000008, "Wrong alignment on FAJBRewardIconInfoList");
static_assert(sizeof(FAJBRewardIconInfoList) == 0x000010, "Wrong size on FAJBRewardIconInfoList");
static_assert(offsetof(FAJBRewardIconInfoList, IconInfoList) == 0x000000, "Member 'FAJBRewardIconInfoList::IconInfoList' has a wrong offset!");

// ScriptStruct AJB.AJBDevCloseTimeInfo
// 0x0008 (0x0008 - 0x0000)
struct FAJBDevCloseTimeInfo final
{
public:
	int32                                         Houre;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Minute;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBDevCloseTimeInfo) == 0x000004, "Wrong alignment on FAJBDevCloseTimeInfo");
static_assert(sizeof(FAJBDevCloseTimeInfo) == 0x000008, "Wrong size on FAJBDevCloseTimeInfo");
static_assert(offsetof(FAJBDevCloseTimeInfo, Houre) == 0x000000, "Member 'FAJBDevCloseTimeInfo::Houre' has a wrong offset!");
static_assert(offsetof(FAJBDevCloseTimeInfo, Minute) == 0x000004, "Member 'FAJBDevCloseTimeInfo::Minute' has a wrong offset!");

// ScriptStruct AJB.AJBUICurveAnimation
// 0x0058 (0x0058 - 0x0000)
struct alignas(0x08) FAJBUICurveAnimation final
{
public:
	uint8                                         Pad_0[0x58];                                       // 0x0000(0x0058)(Fixing Struct Size After Last Property [ Dumper-7 ])
};
static_assert(alignof(FAJBUICurveAnimation) == 0x000008, "Wrong alignment on FAJBUICurveAnimation");
static_assert(sizeof(FAJBUICurveAnimation) == 0x000058, "Wrong size on FAJBUICurveAnimation");

// ScriptStruct AJB.AJBImageData
// 0x0018 (0x0018 - 0x0000)
struct FAJBImageData final
{
public:
	int32                                         Width;                                             // 0x0000(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	int32                                         Height;                                            // 0x0004(0x0004)(Edit, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash, NativeAccessSpecifierPublic)
	TArray<struct FColor>                         ColorData;                                         // 0x0008(0x0010)(Edit, ZeroConstructor, NativeAccessSpecifierPublic)
};
static_assert(alignof(FAJBImageData) == 0x000008, "Wrong alignment on FAJBImageData");
static_assert(sizeof(FAJBImageData) == 0x000018, "Wrong size on FAJBImageData");
static_assert(offsetof(FAJBImageData, Width) == 0x000000, "Member 'FAJBImageData::Width' has a wrong offset!");
static_assert(offsetof(FAJBImageData, Height) == 0x000004, "Member 'FAJBImageData::Height' has a wrong offset!");
static_assert(offsetof(FAJBImageData, ColorData) == 0x000008, "Member 'FAJBImageData::ColorData' has a wrong offset!");

}

