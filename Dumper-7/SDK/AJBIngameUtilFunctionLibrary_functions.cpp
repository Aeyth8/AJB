#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: AJBIngameUtilFunctionLibrary

#include "Basic.hpp"

#include "AJBIngameUtilFunctionLibrary_classes.hpp"
#include "AJBIngameUtilFunctionLibrary_parameters.hpp"


namespace SDK
{

// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CuttingDamage
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   BaseDamage                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDamagePriority                         DamagePriority                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AttackDistance                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPenetrateAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    WithSeparatedStandAttack                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bNotUseCollision                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FAJBDamageDisplayParams&   DamageDisplayParams                                    (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// const struct FAJBDamageDisplayProperty& DamageDisplayProperty                                  (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bIgnoreCalcAttackRate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bWithoutStand                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIgnoreCalcDefense                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrateAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CuttingDamage(class AActor* DamagedActor, int32 BaseDamage, const struct FGameplayTag& DamageType, int32 SerialNumber, EDamagePriority DamagePriority, float AttackDistance, float CuttingRate, class AActor* DamageCauser, bool bPenetrateAP, bool WithSeparatedStandAttack, bool bNotUseCollision, const struct FAJBDamageDisplayParams& DamageDisplayParams, const struct FAJBDamageDisplayProperty& DamageDisplayProperty, bool bIgnoreCalcAttackRate, bool bWithoutStand, bool bIgnoreCalcDefense, bool bPenetrateAAP, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CuttingDamage");

	Params::AJBIngameUtilFunctionLibrary_C_CuttingDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.BaseDamage = BaseDamage;
	Parms.DamageType = std::move(DamageType);
	Parms.SerialNumber = SerialNumber;
	Parms.DamagePriority = DamagePriority;
	Parms.AttackDistance = AttackDistance;
	Parms.CuttingRate = CuttingRate;
	Parms.DamageCauser = DamageCauser;
	Parms.bPenetrateAP = bPenetrateAP;
	Parms.WithSeparatedStandAttack = WithSeparatedStandAttack;
	Parms.bNotUseCollision = bNotUseCollision;
	Parms.DamageDisplayParams = std::move(DamageDisplayParams);
	Parms.DamageDisplayProperty = std::move(DamageDisplayProperty);
	Parms.bIgnoreCalcAttackRate = bIgnoreCalcAttackRate;
	Parms.bWithoutStand = bWithoutStand;
	Parms.bIgnoreCalcDefense = bIgnoreCalcDefense;
	Parms.bPenetrateAAP = bPenetrateAAP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RandomPointInCircle
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UAJBIngameUtilFunctionLibrary_C::RandomPointInCircle(const struct FVector& Origin, float Radius, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RandomPointInCircle");

	Params::AJBIngameUtilFunctionLibrary_C_RandomPointInCircle Parms{};

	Parms.Origin = std::move(Origin);
	Parms.Radius = Radius;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetResolutionScale
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           WorldActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D*                       Scale                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetResolutionScale(class AActor* WorldActor, class UObject* __WorldContext, struct FVector2D* Scale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetResolutionScale");

	Params::AJBIngameUtilFunctionLibrary_C_GetResolutionScale Parms{};

	Parms.WorldActor = WorldActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Scale != nullptr)
		*Scale = std::move(Parms.Scale);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetViewRotation
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator*                        Rotation                                               (Parm, OutParm, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::GetViewRotation(class AActor* Actor, class UObject* __WorldContext, struct FRotator* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetViewRotation");

	Params::AJBIngameUtilFunctionLibrary_C_GetViewRotation Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Rotation != nullptr)
		*Rotation = std::move(Parms.Rotation);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetScreenCenterPosition
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           WorldActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  PosX                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  PosY                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetScreenCenterPosition(class AActor* WorldActor, class UObject* __WorldContext, float* PosX, float* PosY)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetScreenCenterPosition");

	Params::AJBIngameUtilFunctionLibrary_C_GetScreenCenterPosition Parms{};

	Parms.WorldActor = WorldActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PosX != nullptr)
		*PosX = Parms.PosX;

	if (PosY != nullptr)
		*PosY = Parms.PosY;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GenerateHitEffect_Local
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FRotator&                  HitRotation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bCharacter                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bLeftAP                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              ParticleTagBlockedByAAP                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              ParticleTagBlocked                                     (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bGenerateSurfaceParticle                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bUseSurfaceParticleLighter                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GenerateHitEffect_Local(const struct FVector& HitLocation, const struct FVector& HitNormal, const struct FRotator& HitRotation, const struct FGameplayTag& DamageType, bool bCharacter, bool bLeftAP, bool bHeadShot, EPhysicalSurface SurfaceType, bool bBlockedByAAP, const struct FGameplayTag& ParticleTagBlockedByAAP, const struct FGameplayTag& ParticleTagBlocked, bool bGenerateSurfaceParticle, bool bUseSurfaceParticleLighter, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GenerateHitEffect_Local");

	Params::AJBIngameUtilFunctionLibrary_C_GenerateHitEffect_Local Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.HitRotation = std::move(HitRotation);
	Parms.DamageType = std::move(DamageType);
	Parms.bCharacter = bCharacter;
	Parms.bLeftAP = bLeftAP;
	Parms.bHeadShot = bHeadShot;
	Parms.SurfaceType = SurfaceType;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.ParticleTagBlockedByAAP = std::move(ParticleTagBlockedByAAP);
	Parms.ParticleTagBlocked = std::move(ParticleTagBlocked);
	Parms.bGenerateSurfaceParticle = bGenerateSurfaceParticle;
	Parms.bUseSurfaceParticleLighter = bUseSurfaceParticleLighter;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ParcentageToRatio
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Parcentage                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Ratio                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ParcentageToRatio(int32 Parcentage, class UObject* __WorldContext, float* Ratio)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ParcentageToRatio");

	Params::AJBIngameUtilFunctionLibrary_C_ParcentageToRatio Parms{};

	Parms.Parcentage = Parcentage;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Ratio != nullptr)
		*Ratio = Parms.Ratio;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcHitLocation(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OwnActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bSweep                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FHitResult&                HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    bSafety                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         HitLocation                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         HitNormal                                              (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CalcHitLocation_Deprecated_(class AActor* OwnActor, bool bSweep, const struct FHitResult& HitResult, bool bSafety, class UObject* __WorldContext, struct FVector* HitLocation, struct FVector* HitNormal)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcHitLocation(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_CalcHitLocation_Deprecated_ Parms{};

	Parms.OwnActor = OwnActor;
	Parms.bSweep = bSweep;
	Parms.HitResult = std::move(HitResult);
	Parms.bSafety = bSafety;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (HitLocation != nullptr)
		*HitLocation = std::move(Parms.HitLocation);

	if (HitNormal != nullptr)
		*HitNormal = std::move(Parms.HitNormal);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetHitObjectTypesByPrevTrace(Deprecated)
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<EObjectTypeQuery>*               NewParam                                               (Parm, OutParm, ZeroConstructor)

void UAJBIngameUtilFunctionLibrary_C::GetHitObjectTypesByPrevTrace_Deprecated_(class UObject* __WorldContext, TArray<EObjectTypeQuery>* NewParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetHitObjectTypesByPrevTrace(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_GetHitObjectTypesByPrevTrace_Deprecated_ Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (NewParam != nullptr)
		*NewParam = std::move(Parms.NewParam);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBMultiLineTrace(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bTargetHit                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor**                          TargetActor                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UActorComponent**                 TargetComponent                                        (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         TargetLocation                                         (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::AJBMultiLineTrace_Deprecated_(class AActor* DamageCauser, const struct FVector& Start, const struct FVector& End, class UObject* __WorldContext, bool* bTargetHit, class AActor** TargetActor, class UActorComponent** TargetComponent, struct FVector* TargetLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBMultiLineTrace(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBMultiLineTrace_Deprecated_ Parms{};

	Parms.DamageCauser = DamageCauser;
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bTargetHit != nullptr)
		*bTargetHit = Parms.bTargetHit;

	if (TargetActor != nullptr)
		*TargetActor = Parms.TargetActor;

	if (TargetComponent != nullptr)
		*TargetComponent = Parms.TargetComponent;

	if (TargetLocation != nullptr)
		*TargetLocation = std::move(Parms.TargetLocation);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeViewTarget
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           NewViewTarget                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BlendTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeViewTarget(class AActor* NewViewTarget, float BlendTime, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeViewTarget");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeViewTarget Parms{};

	Parms.NewViewTarget = NewViewTarget;
	Parms.BlendTime = BlendTime;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GenerateDamageEffect
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bRemainHP                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bDamageIsCut                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GenerateDamageEffect(class AActor* DamagedActor, const struct FGameplayTag& DamageType, bool bRemainHP, bool bDamageIsCut, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GenerateDamageEffect");

	Params::AJBIngameUtilFunctionLibrary_C_GenerateDamageEffect Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.DamageType = std::move(DamageType);
	Parms.bRemainHP = bRemainHP;
	Parms.bDamageIsCut = bDamageIsCut;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ExtractFloatValuesFromTagValueMap
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTagContainer&     TargetTagContainer                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// const struct FGameplayTag&              ExtractedTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const TMap<struct FGameplayTag, float>& TagValueMapRef                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<float>*                          ReturnValues                                           (Parm, OutParm, ZeroConstructor)

void UAJBIngameUtilFunctionLibrary_C::ExtractFloatValuesFromTagValueMap(const struct FGameplayTagContainer& TargetTagContainer, const struct FGameplayTag& ExtractedTag, const TMap<struct FGameplayTag, float>& TagValueMapRef, class UObject* __WorldContext, TArray<float>* ReturnValues)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ExtractFloatValuesFromTagValueMap");

	Params::AJBIngameUtilFunctionLibrary_C_ExtractFloatValuesFromTagValueMap Parms{};

	Parms.TargetTagContainer = std::move(TargetTagContainer);
	Parms.ExtractedTag = std::move(ExtractedTag);
	Parms.TagValueMapRef = std::move(TagValueMapRef);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ReturnValues != nullptr)
		*ReturnValues = std::move(Parms.ReturnValues);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.MultiplyFloatValues
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>&                          Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  ResultParam                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::MultiplyFloatValues(TArray<float>& Array, class UObject* __WorldContext, float* ResultParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "MultiplyFloatValues");

	Params::AJBIngameUtilFunctionLibrary_C_MultiplyFloatValues Parms{};

	Parms.Array = std::move(Array);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (ResultParam != nullptr)
		*ResultParam = Parms.ResultParam;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AddFloatValues
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>&                          Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  ResultParam                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::AddFloatValues(TArray<float>& Array, class UObject* __WorldContext, float* ResultParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AddFloatValues");

	Params::AJBIngameUtilFunctionLibrary_C_AddFloatValues Parms{};

	Parms.Array = std::move(Array);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (ResultParam != nullptr)
		*ResultParam = Parms.ResultParam;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetPlayerMatchingIndexIdByActor
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  PlayerMatchingIndex                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetPlayerMatchingIndexIdByActor(class AActor* TargetActor, class UObject* __WorldContext, int32* PlayerMatchingIndex)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetPlayerMatchingIndexIdByActor");

	Params::AJBIngameUtilFunctionLibrary_C_GetPlayerMatchingIndexIdByActor Parms{};

	Parms.TargetActor = TargetActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PlayerMatchingIndex != nullptr)
		*PlayerMatchingIndex = Parms.PlayerMatchingIndex;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.TryGetTraceInfo(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EDrawDebugTrace*                        DrawDebugTrace                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  DrawTime                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::TryGetTraceInfo_Deprecated_(const struct FGameplayTag& TraceInfoTag, class UObject* __WorldContext, EDrawDebugTrace* DrawDebugTrace, float* DrawTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "TryGetTraceInfo(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_TryGetTraceInfo_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DrawDebugTrace != nullptr)
		*DrawDebugTrace = Parms.DrawDebugTrace;

	if (DrawTime != nullptr)
		*DrawTime = Parms.DrawTime;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBMultiSphereTraceForObjects(Deprecated)
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBMultiSphereTraceForObjects_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, TArray<struct FHitResult>* OutHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBMultiSphereTraceForObjects(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBMultiSphereTraceForObjects_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBLineTraceForObjects(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBLineTraceForObjects_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBLineTraceForObjects(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBLineTraceForObjects_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBSphereTraceForObjects(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBSphereTraceForObjects_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, float Radius, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBSphereTraceForObjects(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBSphereTraceForObjects_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBLineTraceByChannel(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETraceTypeQuery                         TraceChannel                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBLineTraceByChannel_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBLineTraceByChannel(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBLineTraceByChannel_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBCapsuleTraceByChannel(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   HalfHeight                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ETraceTypeQuery                         TraceChannel                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBCapsuleTraceByChannel_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, ETraceTypeQuery TraceChannel, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBCapsuleTraceByChannel(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBCapsuleTraceByChannel_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.TraceChannel = TraceChannel;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetDamageInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              DamageTypeTag                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FST_DamageInfo*                  DamageInfo                                             (Parm, OutParm, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetDamageInfo(const struct FGameplayTag& DamageTypeTag, class UObject* __WorldContext, bool* bResult, struct FST_DamageInfo* DamageInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetDamageInfo");

	Params::AJBIngameUtilFunctionLibrary_C_GetDamageInfo Parms{};

	Parms.DamageTypeTag = std::move(DamageTypeTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (DamageInfo != nullptr)
		*DamageInfo = std::move(Parms.DamageInfo);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GenerateHitSECharacter
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bHeadShot                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class USceneComponent*                  AttachTarget                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockedByAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              SETagBlockedByAAP                                      (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GenerateHitSECharacter(bool bHeadShot, class USceneComponent* AttachTarget, bool bBlockedByAAP, const struct FGameplayTag& SETagBlockedByAAP, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GenerateHitSECharacter");

	Params::AJBIngameUtilFunctionLibrary_C_GenerateHitSECharacter Parms{};

	Parms.bHeadShot = bHeadShot;
	Parms.AttachTarget = AttachTarget;
	Parms.bBlockedByAAP = bBlockedByAAP;
	Parms.SETagBlockedByAAP = std::move(SETagBlockedByAAP);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GenerateHitSENonCharacter
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              OverrideSETag                                          (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GenerateHitSENonCharacter(const struct FVector& HitLocation, const struct FGameplayTag& DamageType, const struct FGameplayTag& OverrideSETag, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GenerateHitSENonCharacter");

	Params::AJBIngameUtilFunctionLibrary_C_GenerateHitSENonCharacter Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.DamageType = std::move(DamageType);
	Parms.OverrideSETag = std::move(OverrideSETag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GenerateDamageSENonCharacter
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GenerateDamageSENonCharacter(const struct FVector& HitLocation, EPhysicalSurface SurfaceType, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GenerateDamageSENonCharacter");

	Params::AJBIngameUtilFunctionLibrary_C_GenerateDamageSENonCharacter Parms{};

	Parms.HitLocation = std::move(HitLocation);
	Parms.SurfaceType = SurfaceType;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcHeadShot(Deprecated)
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceLength                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bHeadShot                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CalcHeadShot_Deprecated_(class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& Direction, float Radius, float TraceLength, class UObject* __WorldContext, bool* bHeadShot)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcHeadShot(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_CalcHeadShot_Deprecated_ Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation = std::move(HitLocation);
	Parms.Direction = std::move(Direction);
	Parms.Radius = Radius;
	Parms.TraceLength = TraceLength;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bHeadShot != nullptr)
		*bHeadShot = Parms.bHeadShot;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBMultiLineTraceForObjects(Deprecated)
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBMultiLineTraceForObjects_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, TArray<struct FHitResult>* OutHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBMultiLineTraceForObjects(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBMultiLineTraceForObjects_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RInterpToQuaternion
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FRotator&                  Current                                                (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// const struct FRotator&                  Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// float                                   DeltaTime                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   InterpSpeed                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FRotator                         ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor)

struct FRotator UAJBIngameUtilFunctionLibrary_C::RInterpToQuaternion(const struct FRotator& Current, const struct FRotator& Target, float DeltaTime, float InterpSpeed, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RInterpToQuaternion");

	Params::AJBIngameUtilFunctionLibrary_C_RInterpToQuaternion Parms{};

	Parms.Current = std::move(Current);
	Parms.Target = std::move(Target);
	Parms.DeltaTime = DeltaTime;
	Parms.InterpSpeed = InterpSpeed;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetAJBCharacter
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AController*                      Controller                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_AJBInGameCharacter_C**        CharacterBP                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::GetAJBCharacter(class AController* Controller, class UObject* __WorldContext, class ABP_AJBInGameCharacter_C** CharacterBP, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetAJBCharacter");

	Params::AJBIngameUtilFunctionLibrary_C_GetAJBCharacter Parms{};

	Parms.Controller = Controller;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterBP != nullptr)
		*CharacterBP = Parms.CharacterBP;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcShotTransform
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   TraceLength                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   IrregularAngleThresould_Deg_                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreTarget                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              SkillTag                                               (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreCharacterSpread                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bNotOwnerEnv                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// TArray<struct FTransform>*              Transforms                                             (Parm, OutParm, ZeroConstructor)

void UAJBIngameUtilFunctionLibrary_C::CalcShotTransform(class ABP_AJBInGameCharacter_C* CharacterBP, float TraceLength, float IrregularAngleThresould_Deg_, bool bIgnoreTarget, const struct FGameplayTag& SkillTag, bool bIgnoreCharacterSpread, bool bNotOwnerEnv, class UObject* __WorldContext, bool* bSuccess, TArray<struct FTransform>* Transforms)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcShotTransform");

	Params::AJBIngameUtilFunctionLibrary_C_CalcShotTransform Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.TraceLength = TraceLength;
	Parms.IrregularAngleThresould_Deg_ = IrregularAngleThresould_Deg_;
	Parms.bIgnoreTarget = bIgnoreTarget;
	Parms.SkillTag = std::move(SkillTag);
	Parms.bIgnoreCharacterSpread = bIgnoreCharacterSpread;
	Parms.bNotOwnerEnv = bNotOwnerEnv;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	if (Transforms != nullptr)
		*Transforms = std::move(Parms.Transforms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.TraceCharacterFootingInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Character                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   CharacterWorldLocation                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>&                  ActorsToIgnore                                         (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bAccurate                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::TraceCharacterFootingInfo(class ABP_AJBInGameCharacter_C* Character, const struct FVector& CharacterWorldLocation, TArray<class AActor*>& ActorsToIgnore, bool bAccurate, class UObject* __WorldContext, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "TraceCharacterFootingInfo");

	Params::AJBIngameUtilFunctionLibrary_C_TraceCharacterFootingInfo Parms{};

	Parms.Character = Character;
	Parms.CharacterWorldLocation = std::move(CharacterWorldLocation);
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bAccurate = bAccurate;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	ActorsToIgnore = std::move(Parms.ActorsToIgnore);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetAJBCharacterFromActor
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_AJBInGameCharacter_C**        CharacterBP                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::GetAJBCharacterFromActor(class AActor* Actor, class UObject* __WorldContext, class ABP_AJBInGameCharacter_C** CharacterBP, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetAJBCharacterFromActor");

	Params::AJBIngameUtilFunctionLibrary_C_GetAJBCharacterFromActor Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterBP != nullptr)
		*CharacterBP = Parms.CharacterBP;

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBMultiCapsuleTraceForObjects(Deprecated)
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   HalfHeight                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const TArray<EObjectTypeQuery>&         ObjectTypes                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBMultiCapsuleTraceForObjects_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, float Radius, float HalfHeight, const TArray<EObjectTypeQuery>& ObjectTypes, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, TArray<struct FHitResult>* OutHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBMultiCapsuleTraceForObjects(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBMultiCapsuleTraceForObjects_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.HalfHeight = HalfHeight;
	Parms.ObjectTypes = std::move(ObjectTypes);
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBMultiSphereTraceByProfile(Deprecated)
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Start                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   End                                                    (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             ProfileName                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bTraceComplex                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const TArray<class AActor*>&            ActorsToIgnore                                         (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FLinearColor&              TraceColor                                             (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FLinearColor&              TraceHitColor                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FHitResult>*              OutHits                                                (Parm, OutParm, ZeroConstructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::AJBMultiSphereTraceByProfile_Deprecated_(const struct FGameplayTag& TraceInfoTag, const struct FVector& Start, const struct FVector& End, float Radius, class FName ProfileName, bool bTraceComplex, const TArray<class AActor*>& ActorsToIgnore, bool bIgnoreSelf, const struct FLinearColor& TraceColor, const struct FLinearColor& TraceHitColor, class UObject* __WorldContext, TArray<struct FHitResult>* OutHits)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBMultiSphereTraceByProfile(Deprecated)");

	Params::AJBIngameUtilFunctionLibrary_C_AJBMultiSphereTraceByProfile_Deprecated_ Parms{};

	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.Start = std::move(Start);
	Parms.End = std::move(End);
	Parms.Radius = Radius;
	Parms.ProfileName = ProfileName;
	Parms.bTraceComplex = bTraceComplex;
	Parms.ActorsToIgnore = std::move(ActorsToIgnore);
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.TraceColor = std::move(TraceColor);
	Parms.TraceHitColor = std::move(TraceHitColor);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHits != nullptr)
		*OutHits = std::move(Parms.OutHits);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckSkillSealing
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           SkillClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSkillSealing                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckSkillSealing(class ABP_AJBInGameCharacter_C* CharacterBP, class UClass* SkillClass, class UObject* __WorldContext, bool* bSkillSealing)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckSkillSealing");

	Params::AJBIngameUtilFunctionLibrary_C_CheckSkillSealing Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.SkillClass = SkillClass;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bSkillSealing != nullptr)
		*bSkillSealing = Parms.bSkillSealing;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckCharacterOnInstantObject
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   FootLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              TraceInfoTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bOnInstant                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckCharacterOnInstantObject(const struct FVector& FootLocation, class ABP_AJBInGameCharacter_C* CharacterBP, const struct FGameplayTag& TraceInfoTag, class UObject* __WorldContext, bool* bOnInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckCharacterOnInstantObject");

	Params::AJBIngameUtilFunctionLibrary_C_CheckCharacterOnInstantObject Parms{};

	Parms.FootLocation = std::move(FootLocation);
	Parms.CharacterBP = CharacterBP;
	Parms.TraceInfoTag = std::move(TraceInfoTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bOnInstant != nullptr)
		*bOnInstant = Parms.bOnInstant;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcDamage
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   BaseDamage                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CuttingRateByBlocking                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPenetrateAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIgnoreCalcAttackRate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bWithoutStand                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIgnoreCalcDefense                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPenetrateAAP                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  DamageForHPAP                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  DamageForAAP                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  CutDamage                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bRemainHP                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bDamageIsCutByAAP                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   IsEndured                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CalcDamage(class AActor* DamagedActor, class AActor* DamageCauser, int32 BaseDamage, float CuttingRateByBlocking, bool bPenetrateAP, bool bIgnoreCalcAttackRate, const struct FGameplayTag& DamageType, bool bWithoutStand, bool bIgnoreCalcDefense, bool bPenetrateAAP, class UObject* __WorldContext, int32* DamageForHPAP, int32* DamageForAAP, int32* CutDamage, bool* bRemainHP, bool* bDamageIsCutByAAP, bool* IsEndured)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcDamage");

	Params::AJBIngameUtilFunctionLibrary_C_CalcDamage Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.DamageCauser = DamageCauser;
	Parms.BaseDamage = BaseDamage;
	Parms.CuttingRateByBlocking = CuttingRateByBlocking;
	Parms.bPenetrateAP = bPenetrateAP;
	Parms.bIgnoreCalcAttackRate = bIgnoreCalcAttackRate;
	Parms.DamageType = std::move(DamageType);
	Parms.bWithoutStand = bWithoutStand;
	Parms.bIgnoreCalcDefense = bIgnoreCalcDefense;
	Parms.bPenetrateAAP = bPenetrateAAP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DamageForHPAP != nullptr)
		*DamageForHPAP = Parms.DamageForHPAP;

	if (DamageForAAP != nullptr)
		*DamageForAAP = Parms.DamageForAAP;

	if (CutDamage != nullptr)
		*CutDamage = Parms.CutDamage;

	if (bRemainHP != nullptr)
		*bRemainHP = Parms.bRemainHP;

	if (bDamageIsCutByAAP != nullptr)
		*bDamageIsCutByAAP = Parms.bDamageIsCutByAAP;

	if (IsEndured != nullptr)
		*IsEndured = Parms.IsEndured;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckCharacterByTag
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTag&              CharacterTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bReturnValue                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckCharacterByTag(class ABP_AJBInGameCharacter_C* CharacterBP, const struct FGameplayTag& CharacterTag, class UObject* __WorldContext, bool* bReturnValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckCharacterByTag");

	Params::AJBIngameUtilFunctionLibrary_C_CheckCharacterByTag Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.CharacterTag = std::move(CharacterTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bReturnValue != nullptr)
		*bReturnValue = Parms.bReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsPair
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           FirstActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           SecondActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnoreSelf                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bPairCharacter                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsPair(class AActor* FirstActor, class AActor* SecondActor, bool bIgnoreSelf, class UObject* __WorldContext, bool* bPairCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsPair");

	Params::AJBIngameUtilFunctionLibrary_C_IsPair Parms{};

	Parms.FirstActor = FirstActor;
	Parms.SecondActor = SecondActor;
	Parms.bIgnoreSelf = bIgnoreSelf;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bPairCharacter != nullptr)
		*bPairCharacter = Parms.bPairCharacter;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetPairCount(Svr)
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  Num                                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetPairCount_Svr_(class UObject* __WorldContext, int32* Num)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetPairCount(Svr)");

	Params::AJBIngameUtilFunctionLibrary_C_GetPairCount_Svr_ Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Num != nullptr)
		*Num = Parms.Num;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.LastSurvivorIsDetermined_OnServer
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::LastSurvivorIsDetermined_OnServer(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "LastSurvivorIsDetermined_OnServer");

	Params::AJBIngameUtilFunctionLibrary_C_LastSurvivorIsDetermined_OnServer Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetSkillInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              SkillTag                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FST_SkillInfo*                   SkillInfo                                              (Parm, OutParm, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetSkillInfo(const struct FGameplayTag& SkillTag, class UObject* __WorldContext, bool* bResult, struct FST_SkillInfo* SkillInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetSkillInfo");

	Params::AJBIngameUtilFunctionLibrary_C_GetSkillInfo Parms{};

	Parms.SkillTag = std::move(SkillTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (SkillInfo != nullptr)
		*SkillInfo = std::move(Parms.SkillInfo);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetCharacterShortNameFromSkillTag
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FGameplayTag&              SkillTag                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FString*                          ShortName                                              (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetCharacterShortNameFromSkillTag(const struct FGameplayTag& SkillTag, class UObject* __WorldContext, bool* bResult, class FString* ShortName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetCharacterShortNameFromSkillTag");

	Params::AJBIngameUtilFunctionLibrary_C_GetCharacterShortNameFromSkillTag Parms{};

	Parms.SkillTag = std::move(SkillTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;

	if (ShortName != nullptr)
		*ShortName = std::move(Parms.ShortName);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetCharacterTagFromCharacter
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag*                    CharacterTag                                           (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetCharacterTagFromCharacter(class ABP_AJBInGameCharacter_C* CharacterBP, class UObject* __WorldContext, struct FGameplayTag* CharacterTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetCharacterTagFromCharacter");

	Params::AJBIngameUtilFunctionLibrary_C_GetCharacterTagFromCharacter Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterTag != nullptr)
		*CharacterTag = std::move(Parms.CharacterTag);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetCharacterIdFromActor
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// uint8*                                  CharacterID                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetCharacterIdFromActor(class AActor* Actor, class UObject* __WorldContext, uint8* CharacterID)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetCharacterIdFromActor");

	Params::AJBIngameUtilFunctionLibrary_C_GetCharacterIdFromActor Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterID != nullptr)
		*CharacterID = Parms.CharacterID;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetSkillBitmaskFromSkillTag
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              SkillTag                                               (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  SkillBitmask                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetSkillBitmaskFromSkillTag(const struct FGameplayTag& SkillTag, class UObject* __WorldContext, int32* SkillBitmask)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetSkillBitmaskFromSkillTag");

	Params::AJBIngameUtilFunctionLibrary_C_GetSkillBitmaskFromSkillTag Parms{};

	Parms.SkillTag = std::move(SkillTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SkillBitmask != nullptr)
		*SkillBitmask = Parms.SkillBitmask;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.SetPostProcessMaterial
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               MaterialInterface                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32&                                  Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::SetPostProcessMaterial(class UCameraComponent* CameraComponent, class UMaterialInterface* MaterialInterface, int32& Index_0, bool bEnable, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "SetPostProcessMaterial");

	Params::AJBIngameUtilFunctionLibrary_C_SetPostProcessMaterial Parms{};

	Parms.CameraComponent = CameraComponent;
	Parms.MaterialInterface = MaterialInterface;
	Parms.Index_0 = Index_0;
	Parms.bEnable = bEnable;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Index_0 = Parms.Index_0;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.SetPostProcessMaterialBlendWeight
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UCameraComponent*                 CameraComponent                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Index_0                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Weight                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::SetPostProcessMaterialBlendWeight(class UCameraComponent* CameraComponent, int32 Index_0, float Weight, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "SetPostProcessMaterialBlendWeight");

	Params::AJBIngameUtilFunctionLibrary_C_SetPostProcessMaterialBlendWeight Parms{};

	Parms.CameraComponent = CameraComponent;
	Parms.Index_0 = Index_0;
	Parms.Weight = Weight;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetCharacterFloatParameterFromDefaultContent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Filename                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             ValueName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// float*                                  Value                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetCharacterFloatParameterFromDefaultContent(class FName Filename, class FName ValueName, class UObject* __WorldContext, bool* bSuccess, float* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetCharacterFloatParameterFromDefaultContent");

	Params::AJBIngameUtilFunctionLibrary_C_GetCharacterFloatParameterFromDefaultContent Parms{};

	Parms.Filename = Filename;
	Parms.ValueName = ValueName;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	if (Value != nullptr)
		*Value = Parms.Value;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetCharacterVectorParameterFromDefaultContent
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             Filename                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FName                             ValueName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector*                         Value                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetCharacterVectorParameterFromDefaultContent(class FName Filename, class FName ValueName, class UObject* __WorldContext, bool* bSuccess, struct FVector* Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetCharacterVectorParameterFromDefaultContent");

	Params::AJBIngameUtilFunctionLibrary_C_GetCharacterVectorParameterFromDefaultContent Parms{};

	Parms.Filename = Filename;
	Parms.ValueName = ValueName;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;

	if (Value != nullptr)
		*Value = std::move(Parms.Value);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RandomPointInRing
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FVector&                   Origin                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   RadiusMin                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   RadiusMax                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          ReturnValue                                            (Parm, OutParm, ReturnParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

struct FVector UAJBIngameUtilFunctionLibrary_C::RandomPointInRing(const struct FVector& Origin, float RadiusMin, float RadiusMax, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RandomPointInRing");

	Params::AJBIngameUtilFunctionLibrary_C_RandomPointInRing Parms{};

	Parms.Origin = std::move(Origin);
	Parms.RadiusMin = RadiusMin;
	Parms.RadiusMax = RadiusMax;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcDualZoneCameraRotate
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   CameraInputRate                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CameraInputDeadRate                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CameraInputSecondRate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   RotationMinPerSecond                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   RotationMaxPerSecond                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UCurveFloat*                      CVCameraInputDualZoneFirst                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UCurveFloat*                      CVCameraInputDualZoneSecond                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CurrentInputSpeedRate                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  Rotation                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CalcDualZoneCameraRotate(float CameraInputRate, float CameraInputDeadRate, float CameraInputSecondRate, float RotationMinPerSecond, float RotationMaxPerSecond, class UCurveFloat* CVCameraInputDualZoneFirst, class UCurveFloat* CVCameraInputDualZoneSecond, float CurrentInputSpeedRate, class UObject* __WorldContext, float* Rotation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcDualZoneCameraRotate");

	Params::AJBIngameUtilFunctionLibrary_C_CalcDualZoneCameraRotate Parms{};

	Parms.CameraInputRate = CameraInputRate;
	Parms.CameraInputDeadRate = CameraInputDeadRate;
	Parms.CameraInputSecondRate = CameraInputSecondRate;
	Parms.RotationMinPerSecond = RotationMinPerSecond;
	Parms.RotationMaxPerSecond = RotationMaxPerSecond;
	Parms.CVCameraInputDualZoneFirst = CVCameraInputDualZoneFirst;
	Parms.CVCameraInputDualZoneSecond = CVCameraInputDualZoneSecond;
	Parms.CurrentInputSpeedRate = CurrentInputSpeedRate;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Rotation != nullptr)
		*Rotation = Parms.Rotation;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsRelatedCharacterAndMovableStand
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor1                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           Actor2                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bResult                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsRelatedCharacterAndMovableStand(class AActor* Actor1, class AActor* Actor2, class UObject* __WorldContext, bool* bResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsRelatedCharacterAndMovableStand");

	Params::AJBIngameUtilFunctionLibrary_C_IsRelatedCharacterAndMovableStand Parms{};

	Parms.Actor1 = Actor1;
	Parms.Actor2 = Actor2;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bResult != nullptr)
		*bResult = Parms.bResult;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeStencilValueByDigit
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              PrimitiveComponent                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// E_StencilDigit                          DigitToChange                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFlag                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeStencilValueByDigit(class UPrimitiveComponent* PrimitiveComponent, E_StencilDigit DigitToChange, bool bFlag, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeStencilValueByDigit");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeStencilValueByDigit Parms{};

	Parms.PrimitiveComponent = PrimitiveComponent;
	Parms.DigitToChange = DigitToChange;
	Parms.bFlag = bFlag;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.StencilDigitToBitmask
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// E_StencilDigit                          StencilDigit                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  BitmaskInt                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::StencilDigitToBitmask(E_StencilDigit StencilDigit, class UObject* __WorldContext, int32* BitmaskInt)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "StencilDigitToBitmask");

	Params::AJBIngameUtilFunctionLibrary_C_StencilDigitToBitmask Parms{};

	Parms.StencilDigit = StencilDigit;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (BitmaskInt != nullptr)
		*BitmaskInt = Parms.BitmaskInt;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcAdditionalGravityPower
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Speed                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   AdditionalGravityPower                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   GravityPowerScale                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  AddtionalGravityScale                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CalcAdditionalGravityPower(float Speed, float AdditionalGravityPower, float GravityPowerScale, class UObject* __WorldContext, float* AddtionalGravityScale)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcAdditionalGravityPower");

	Params::AJBIngameUtilFunctionLibrary_C_CalcAdditionalGravityPower Parms{};

	Parms.Speed = Speed;
	Parms.AdditionalGravityPower = AdditionalGravityPower;
	Parms.GravityPowerScale = GravityPowerScale;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (AddtionalGravityScale != nullptr)
		*AddtionalGravityScale = Parms.AddtionalGravityScale;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcRightVectorByForward
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   ForwardVector                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         RightVector                                            (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CalcRightVectorByForward(const struct FVector& ForwardVector, class UObject* __WorldContext, struct FVector* RightVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcRightVectorByForward");

	Params::AJBIngameUtilFunctionLibrary_C_CalcRightVectorByForward Parms{};

	Parms.ForwardVector = std::move(ForwardVector);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (RightVector != nullptr)
		*RightVector = std::move(Parms.RightVector);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcUpVectorByForwardRight
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   ForwardVector                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   RightVector                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         UpVector                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CalcUpVectorByForwardRight(const struct FVector& ForwardVector, const struct FVector& RightVector, class UObject* __WorldContext, struct FVector* UpVector)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcUpVectorByForwardRight");

	Params::AJBIngameUtilFunctionLibrary_C_CalcUpVectorByForwardRight Parms{};

	Parms.ForwardVector = std::move(ForwardVector);
	Parms.RightVector = std::move(RightVector);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (UpVector != nullptr)
		*UpVector = std::move(Parms.UpVector);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcStartAndEndLocation
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   SmallAmount                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         Start                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         End                                                    (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CalcStartAndEndLocation(const struct FVector& Location, const struct FVector& Direction, float SmallAmount, class UObject* __WorldContext, struct FVector* Start, struct FVector* End)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcStartAndEndLocation");

	Params::AJBIngameUtilFunctionLibrary_C_CalcStartAndEndLocation Parms{};

	Parms.Location = std::move(Location);
	Parms.Direction = std::move(Direction);
	Parms.SmallAmount = SmallAmount;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Start != nullptr)
		*Start = std::move(Parms.Start);

	if (End != nullptr)
		*End = std::move(Parms.End);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetViewTargetActor
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          ViewTargetActor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetViewTargetActor(class UObject* __WorldContext, class AActor** ViewTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetViewTargetActor");

	Params::AJBIngameUtilFunctionLibrary_C_GetViewTargetActor Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ViewTargetActor != nullptr)
		*ViewTargetActor = Parms.ViewTargetActor;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsTimeUp
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::IsTimeUp(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsTimeUp");

	Params::AJBIngameUtilFunctionLibrary_C_IsTimeUp Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CompareParentMaterial
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          Object1                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          Object2                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bMatch                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CompareParentMaterial(class UObject* Object1, class UObject* Object2, class UObject* __WorldContext, bool* bMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CompareParentMaterial");

	Params::AJBIngameUtilFunctionLibrary_C_CompareParentMaterial Parms{};

	Parms.Object1 = Object1;
	Parms.Object2 = Object2;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bMatch != nullptr)
		*bMatch = Parms.bMatch;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcPositionsBetweenTwoPoints
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Point1                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Point2                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Interval                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIncludePoint1                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIncludePoint2                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIncludeLastLessInterval                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<struct FVector>*                 PathPositions                                          (Parm, OutParm, ZeroConstructor)

void UAJBIngameUtilFunctionLibrary_C::CalcPositionsBetweenTwoPoints(const struct FVector& Point1, const struct FVector& Point2, float Interval, bool bIncludePoint1, bool bIncludePoint2, bool bIncludeLastLessInterval, class UObject* __WorldContext, TArray<struct FVector>* PathPositions)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcPositionsBetweenTwoPoints");

	Params::AJBIngameUtilFunctionLibrary_C_CalcPositionsBetweenTwoPoints Parms{};

	Parms.Point1 = std::move(Point1);
	Parms.Point2 = std::move(Point2);
	Parms.Interval = Interval;
	Parms.bIncludePoint1 = bIncludePoint1;
	Parms.bIncludePoint2 = bIncludePoint2;
	Parms.bIncludeLastLessInterval = bIncludeLastLessInterval;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PathPositions != nullptr)
		*PathPositions = std::move(Parms.PathPositions);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckDistanceLimit
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckDistanceLimit(const struct FVector& Location, class UObject* __WorldContext, bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckDistanceLimit");

	Params::AJBIngameUtilFunctionLibrary_C_CheckDistanceLimit Parms{};

	Parms.Location = std::move(Location);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeEnableSkillLock
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           SkillClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeEnableSkillLock(bool bEnable, class AActor* Actor, class UClass* SkillClass, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeEnableSkillLock");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeEnableSkillLock Parms{};

	Parms.bEnable = bEnable;
	Parms.Actor = Actor;
	Parms.SkillClass = SkillClass;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetViewTargetActorConsiderVSCamera
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor**                          ViewTargetActor                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetViewTargetActorConsiderVSCamera(class UObject* __WorldContext, class AActor** ViewTargetActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetViewTargetActorConsiderVSCamera");

	Params::AJBIngameUtilFunctionLibrary_C_GetViewTargetActorConsiderVSCamera Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (ViewTargetActor != nullptr)
		*ViewTargetActor = Parms.ViewTargetActor;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcCameraBaseTraceInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   MaxDistanceTraceStartToBase                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   DistanceBaseToTraceEnd                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MinForwardZForMaxTraceDistanceRate                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxForawrdZForMinTraceDistanceRate                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MaxTraceDistanceRate                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MinTraceDistanceRateUp                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   MinTraceDistanceRateDown                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSucceed                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FVector*                         TraceStart                                             (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector*                         TraceEnd                                               (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::CalcCameraBaseTraceInfo(float MaxDistanceTraceStartToBase, float DistanceBaseToTraceEnd, float MinForwardZForMaxTraceDistanceRate, float MaxForawrdZForMinTraceDistanceRate, float MaxTraceDistanceRate, float MinTraceDistanceRateUp, float MinTraceDistanceRateDown, class UObject* __WorldContext, bool* bSucceed, struct FVector* TraceStart, struct FVector* TraceEnd)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcCameraBaseTraceInfo");

	Params::AJBIngameUtilFunctionLibrary_C_CalcCameraBaseTraceInfo Parms{};

	Parms.MaxDistanceTraceStartToBase = MaxDistanceTraceStartToBase;
	Parms.DistanceBaseToTraceEnd = DistanceBaseToTraceEnd;
	Parms.MinForwardZForMaxTraceDistanceRate = MinForwardZForMaxTraceDistanceRate;
	Parms.MaxForawrdZForMinTraceDistanceRate = MaxForawrdZForMinTraceDistanceRate;
	Parms.MaxTraceDistanceRate = MaxTraceDistanceRate;
	Parms.MinTraceDistanceRateUp = MinTraceDistanceRateUp;
	Parms.MinTraceDistanceRateDown = MinTraceDistanceRateDown;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bSucceed != nullptr)
		*bSucceed = Parms.bSucceed;

	if (TraceStart != nullptr)
		*TraceStart = std::move(Parms.TraceStart);

	if (TraceEnd != nullptr)
		*TraceEnd = std::move(Parms.TraceEnd);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetPlayerControllerConsiderHighlight
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class APlayerController**               PlayerController                                       (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetPlayerControllerConsiderHighlight(class UObject* __WorldContext, class APlayerController** PlayerController)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetPlayerControllerConsiderHighlight");

	Params::AJBIngameUtilFunctionLibrary_C_GetPlayerControllerConsiderHighlight Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (PlayerController != nullptr)
		*PlayerController = Parms.PlayerController;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.PossibleUseStand
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UClass*                           SkillClass                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bPossible                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::PossibleUseStand(class ABP_AJBInGameCharacter_C* CharacterBP, class UClass* SkillClass, class UObject* __WorldContext, bool* bPossible)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "PossibleUseStand");

	Params::AJBIngameUtilFunctionLibrary_C_PossibleUseStand Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.SkillClass = SkillClass;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bPossible != nullptr)
		*bPossible = Parms.bPossible;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeEnablePPMaterials
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UMaterialInterface*               MaterialInterface                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32&                                  MaterialIndexRefCharacter                              (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bChangeForMovableStand                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// int32&                                  MaterialIndexRefMovableStand                           (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeEnablePPMaterials(class ABP_AJBInGameCharacter_C* CharacterBP, class UMaterialInterface* MaterialInterface, bool bEnable, int32& MaterialIndexRefCharacter, bool bChangeForMovableStand, int32& MaterialIndexRefMovableStand, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeEnablePPMaterials");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeEnablePPMaterials Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.MaterialInterface = MaterialInterface;
	Parms.bEnable = bEnable;
	Parms.MaterialIndexRefCharacter = MaterialIndexRefCharacter;
	Parms.bChangeForMovableStand = bChangeForMovableStand;
	Parms.MaterialIndexRefMovableStand = MaterialIndexRefMovableStand;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	MaterialIndexRefCharacter = Parms.MaterialIndexRefCharacter;
	MaterialIndexRefMovableStand = Parms.MaterialIndexRefMovableStand;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckBreakDownMovableStandOnly
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FGameplayTagContainer&     PassiveTags                                            (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bFlinchMovableStandOnly                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckBreakDownMovableStandOnly(class ABP_AJBInGameCharacter_C* CharacterBP, const struct FGameplayTagContainer& PassiveTags, class UObject* __WorldContext, bool* bFlinchMovableStandOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckBreakDownMovableStandOnly");

	Params::AJBIngameUtilFunctionLibrary_C_CheckBreakDownMovableStandOnly Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.PassiveTags = std::move(PassiveTags);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bFlinchMovableStandOnly != nullptr)
		*bFlinchMovableStandOnly = Parms.bFlinchMovableStandOnly;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.TryGetCloudPointTarget
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           TargetOwner                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UBP_AJBCloudPointTarget_C**       CloudPointTarget                                       (Parm, OutParm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::TryGetCloudPointTarget(class AActor* TargetOwner, class UObject* __WorldContext, class UBP_AJBCloudPointTarget_C** CloudPointTarget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "TryGetCloudPointTarget");

	Params::AJBIngameUtilFunctionLibrary_C_TryGetCloudPointTarget Parms{};

	Parms.TargetOwner = TargetOwner;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CloudPointTarget != nullptr)
		*CloudPointTarget = Parms.CloudPointTarget;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CalcAAPInfo
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bDamageCutByAAP                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool*                                   bDamageBlockByAAP                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CalcAAPInfo(class AActor* HitActor, int32 Damage, class UObject* __WorldContext, bool* bDamageCutByAAP, bool* bDamageBlockByAAP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CalcAAPInfo");

	Params::AJBIngameUtilFunctionLibrary_C_CalcAAPInfo Parms{};

	Parms.HitActor = HitActor;
	Parms.Damage = Damage;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bDamageCutByAAP != nullptr)
		*bDamageCutByAAP = Parms.bDamageCutByAAP;

	if (bDamageBlockByAAP != nullptr)
		*bDamageBlockByAAP = Parms.bDamageBlockByAAP;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.DestroyAkComponent
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAkComponent*&                    AkComponent                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, InstancedReference, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::DestroyAkComponent(class UAkComponent*& AkComponent, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "DestroyAkComponent");

	Params::AJBIngameUtilFunctionLibrary_C_DestroyAkComponent Parms{};

	Parms.AkComponent = AkComponent;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	AkComponent = Parms.AkComponent;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeEnableAkComponent
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UAkComponent*                     AkComponent                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeEnableAkComponent(class UAkComponent* AkComponent, bool bEnable, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeEnableAkComponent");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeEnableAkComponent Parms{};

	Parms.AkComponent = AkComponent;
	Parms.bEnable = bEnable;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeEnableTimerHandle
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTimerHandle&              TimerHandle                                            (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeEnableTimerHandle(const struct FTimerHandle& TimerHandle, bool bEnable, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeEnableTimerHandle");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeEnableTimerHandle Parms{};

	Parms.TimerHandle = std::move(TimerHandle);
	Parms.bEnable = bEnable;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeEnableCustomTimeDilation
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeEnableCustomTimeDilation(class AActor* Actor, bool bEnable, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeEnableCustomTimeDilation");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeEnableCustomTimeDilation Parms{};

	Parms.Actor = Actor;
	Parms.bEnable = bEnable;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RecalcDamageForZipperHide
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   TotalDamage                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPenetrateAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  DamageForHPAP                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32*                                  DamageForAAP                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::RecalcDamageForZipperHide(class AActor* DamageActor, class AActor* DamageCauser, int32 TotalDamage, bool bPenetrateAP, class UObject* __WorldContext, int32* DamageForHPAP, int32* DamageForAAP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RecalcDamageForZipperHide");

	Params::AJBIngameUtilFunctionLibrary_C_RecalcDamageForZipperHide Parms{};

	Parms.DamageActor = DamageActor;
	Parms.DamageCauser = DamageCauser;
	Parms.TotalDamage = TotalDamage;
	Parms.bPenetrateAP = bPenetrateAP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (DamageForHPAP != nullptr)
		*DamageForHPAP = Parms.DamageForHPAP;

	if (DamageForAAP != nullptr)
		*DamageForAAP = Parms.DamageForAAP;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.TraceActorFootingInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Radius                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Length                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FHitResult*                      OutHit                                                 (Parm, OutParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::TraceActorFootingInfo(class AActor* Actor, float Radius, float Length, class UObject* __WorldContext, struct FHitResult* OutHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "TraceActorFootingInfo");

	Params::AJBIngameUtilFunctionLibrary_C_TraceActorFootingInfo Parms{};

	Parms.Actor = Actor;
	Parms.Radius = Radius;
	Parms.Length = Length;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutHit != nullptr)
		*OutHit = std::move(Parms.OutHit);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.TryGetPropertyOwnerCharacterFromActor
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InActor                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bSucceed                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor**                          OutActor                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::TryGetPropertyOwnerCharacterFromActor(class AActor* InActor, class UObject* __WorldContext, bool* bSucceed, class AActor** OutActor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "TryGetPropertyOwnerCharacterFromActor");

	Params::AJBIngameUtilFunctionLibrary_C_TryGetPropertyOwnerCharacterFromActor Parms{};

	Parms.InActor = InActor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bSucceed != nullptr)
		*bSucceed = Parms.bSucceed;

	if (OutActor != nullptr)
		*OutActor = Parms.OutActor;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ChangeEnableSliceCut
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<class UMaterialInstanceDynamic*>&DMIList                                                (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FVector&                   Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FVector&                   Offset                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ChangeEnableSliceCut(TArray<class UMaterialInstanceDynamic*>& DMIList, bool bEnable, const struct FVector& Direction, const struct FVector& Offset, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ChangeEnableSliceCut");

	Params::AJBIngameUtilFunctionLibrary_C_ChangeEnableSliceCut Parms{};

	Parms.DMIList = std::move(DMIList);
	Parms.bEnable = bEnable;
	Parms.Direction = std::move(Direction);
	Parms.Offset = std::move(Offset);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	DMIList = std::move(Parms.DMIList);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.TryChangeParticleVisibility
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameParticleEffect_C*    Particle                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bNewVisibility                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bPropagateToChildren                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::TryChangeParticleVisibility(class ABP_AJBInGameParticleEffect_C* Particle, bool bNewVisibility, bool bPropagateToChildren, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "TryChangeParticleVisibility");

	Params::AJBIngameUtilFunctionLibrary_C_TryChangeParticleVisibility Parms{};

	Parms.Particle = Particle;
	Parms.bNewVisibility = bNewVisibility;
	Parms.bPropagateToChildren = bPropagateToChildren;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckCharacterInInstantObject
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bInInstant                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckCharacterInInstantObject(class ABP_AJBInGameCharacter_C* CharacterBP, class UObject* __WorldContext, bool* bInInstant)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckCharacterInInstantObject");

	Params::AJBIngameUtilFunctionLibrary_C_CheckCharacterInInstantObject Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bInInstant != nullptr)
		*bInInstant = Parms.bInInstant;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetDamageAffecterTargetActors
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor)

void UAJBIngameUtilFunctionLibrary_C::GetDamageAffecterTargetActors(class UObject* __WorldContext, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetDamageAffecterTargetActors");

	Params::AJBIngameUtilFunctionLibrary_C_GetDamageAffecterTargetActors Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RegisterDamageAffecterTargetActor
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::RegisterDamageAffecterTargetActor(class AActor* Actor, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RegisterDamageAffecterTargetActor");

	Params::AJBIngameUtilFunctionLibrary_C_RegisterDamageAffecterTargetActor Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.UnregisterDamageAffecterTargetActor
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::UnregisterDamageAffecterTargetActor(class AActor* Actor, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "UnregisterDamageAffecterTargetActor");

	Params::AJBIngameUtilFunctionLibrary_C_UnregisterDamageAffecterTargetActor Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.DestroyParticle
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameParticleEffect_C*&   AJBParticle                                            (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::DestroyParticle(class ABP_AJBInGameParticleEffect_C*& AJBParticle, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "DestroyParticle");

	Params::AJBIngameUtilFunctionLibrary_C_DestroyParticle Parms{};

	Parms.AJBParticle = AJBParticle;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	AJBParticle = Parms.AJBParticle;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckActiveBitesTheDust
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::CheckActiveBitesTheDust(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckActiveBitesTheDust");

	Params::AJBIngameUtilFunctionLibrary_C_CheckActiveBitesTheDust Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsPvEPlayMode
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsPvEPlayMode_0                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsPvEPlayMode(class UObject* __WorldContext, bool* IsPvEPlayMode_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsPvEPlayMode");

	Params::AJBIngameUtilFunctionLibrary_C_IsPvEPlayMode Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsPvEPlayMode_0 != nullptr)
		*IsPvEPlayMode_0 = Parms.IsPvEPlayMode_0;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsPvENPCPair
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           ActorA                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           ActorB                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::IsPvENPCPair(class AActor* ActorA, class AActor* ActorB, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsPvENPCPair");

	Params::AJBIngameUtilFunctionLibrary_C_IsPvENPCPair Parms{};

	Parms.ActorA = ActorA;
	Parms.ActorB = ActorB;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RefreshMatchingInfo
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::RefreshMatchingInfo(class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RefreshMatchingInfo");

	Params::AJBIngameUtilFunctionLibrary_C_RefreshMatchingInfo Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.EnableTheWorldStop
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::EnableTheWorldStop(bool bEnable, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "EnableTheWorldStop");

	Params::AJBIngameUtilFunctionLibrary_C_EnableTheWorldStop Parms{};

	Parms.bEnable = bEnable;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.AJBConvertWorldLocationToScreenLocation
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FVector&                   WorldLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector2D*                       Point                                                  (Parm, OutParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bReturnValue                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::AJBConvertWorldLocationToScreenLocation(const struct FVector& WorldLocation, class UObject* __WorldContext, struct FVector2D* Point, bool* bReturnValue)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "AJBConvertWorldLocationToScreenLocation");

	Params::AJBIngameUtilFunctionLibrary_C_AJBConvertWorldLocationToScreenLocation Parms{};

	Parms.WorldLocation = std::move(WorldLocation);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Point != nullptr)
		*Point = std::move(Parms.Point);

	if (bReturnValue != nullptr)
		*bReturnValue = Parms.bReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetStandUserCharacter
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_AJBInGameCharacter_C**        UserCharacter                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetStandUserCharacter(class ABP_AJBInGameCharacter_C* Target, class UObject* __WorldContext, class ABP_AJBInGameCharacter_C** UserCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetStandUserCharacter");

	Params::AJBIngameUtilFunctionLibrary_C_GetStandUserCharacter Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (UserCharacter != nullptr)
		*UserCharacter = Parms.UserCharacter;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckCharacterDetection
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         TargetCharacterBP                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bCheckDetection                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckCharacterDetection(class ABP_AJBInGameCharacter_C* TargetCharacterBP, class UObject* __WorldContext, bool* bCheckDetection)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckCharacterDetection");

	Params::AJBIngameUtilFunctionLibrary_C_CheckCharacterDetection Parms{};

	Parms.TargetCharacterBP = TargetCharacterBP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bCheckDetection != nullptr)
		*bCheckDetection = Parms.bCheckDetection;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.FindSkinData
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class FName                             SkinName                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FST_CharaSkin*                   SkinData                                               (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::FindSkinData(class FName SkinName, class UObject* __WorldContext, struct FST_CharaSkin* SkinData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "FindSkinData");

	Params::AJBIngameUtilFunctionLibrary_C_FindSkinData Parms{};

	Parms.SkinName = SkinName;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SkinData != nullptr)
		*SkinData = std::move(Parms.SkinData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.FindCharacterSkinDataFromMatchingPlayerInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FMatchingPlayerInfo&       MatchingPlayerInfo                                     (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FST_CharaSkin*                   SkinData                                               (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::FindCharacterSkinDataFromMatchingPlayerInfo(const struct FMatchingPlayerInfo& MatchingPlayerInfo, class UObject* __WorldContext, struct FST_CharaSkin* SkinData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "FindCharacterSkinDataFromMatchingPlayerInfo");

	Params::AJBIngameUtilFunctionLibrary_C_FindCharacterSkinDataFromMatchingPlayerInfo Parms{};

	Parms.MatchingPlayerInfo = std::move(MatchingPlayerInfo);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SkinData != nullptr)
		*SkinData = std::move(Parms.SkinData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.FindStandSkinDataFromMatchingPlayerInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FMatchingPlayerInfo&       MatchingPlayerInfo                                     (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FST_CharaSkin*                   SkinData                                               (Parm, OutParm, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::FindStandSkinDataFromMatchingPlayerInfo(const struct FMatchingPlayerInfo& MatchingPlayerInfo, class UObject* __WorldContext, struct FST_CharaSkin* SkinData, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "FindStandSkinDataFromMatchingPlayerInfo");

	Params::AJBIngameUtilFunctionLibrary_C_FindStandSkinDataFromMatchingPlayerInfo Parms{};

	Parms.MatchingPlayerInfo = std::move(MatchingPlayerInfo);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SkinData != nullptr)
		*SkinData = std::move(Parms.SkinData);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.FindMatchingPlayerInfo
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   MatchingPlayerIndex                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FString*                          PlayerName                                             (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// struct FMatchingPlayerInfo*             MatchingPlayerInfo                                     (Parm, OutParm)

void UAJBIngameUtilFunctionLibrary_C::FindMatchingPlayerInfo(int32 MatchingPlayerIndex, class UObject* __WorldContext, bool* Success, class FString* PlayerName, struct FMatchingPlayerInfo* MatchingPlayerInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "FindMatchingPlayerInfo");

	Params::AJBIngameUtilFunctionLibrary_C_FindMatchingPlayerInfo Parms{};

	Parms.MatchingPlayerIndex = MatchingPlayerIndex;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (PlayerName != nullptr)
		*PlayerName = std::move(Parms.PlayerName);

	if (MatchingPlayerInfo != nullptr)
		*MatchingPlayerInfo = std::move(Parms.MatchingPlayerInfo);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.FoldMaxFloat
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// TArray<float>&                          Array                                                  (BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float*                                  ResultParam                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::FoldMaxFloat(TArray<float>& Array, class UObject* __WorldContext, float* ResultParam)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "FoldMaxFloat");

	Params::AJBIngameUtilFunctionLibrary_C_FoldMaxFloat Parms{};

	Parms.Array = std::move(Array);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	Array = std::move(Parms.Array);

	if (ResultParam != nullptr)
		*ResultParam = Parms.ResultParam;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsEndurableDamageType
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    PenetrateAP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsEndurable                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsEndurableDamageType(const struct FGameplayTag& DamageType, bool PenetrateAP, class UObject* __WorldContext, bool* IsEndurable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsEndurableDamageType");

	Params::AJBIngameUtilFunctionLibrary_C_IsEndurableDamageType Parms{};

	Parms.DamageType = std::move(DamageType);
	Parms.PenetrateAP = PenetrateAP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsEndurable != nullptr)
		*IsEndurable = Parms.IsEndurable;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsStandWithIndividualHP
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsStandWithIndividualHP_0                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsStandWithIndividualHP(class AActor* Target, class UObject* __WorldContext, bool* IsStandWithIndividualHP_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsStandWithIndividualHP");

	Params::AJBIngameUtilFunctionLibrary_C_IsStandWithIndividualHP Parms{};

	Parms.Target = Target;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsStandWithIndividualHP_0 != nullptr)
		*IsStandWithIndividualHP_0 = Parms.IsStandWithIndividualHP_0;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RequestDamageDisplay_Local
// (Static, Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamagedActor                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   BaseDamage                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CuttingRateByBlocking                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bPenetrateAP                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FGameplayTag&              DamageType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bWithoutStand                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// const struct FVector&                   HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::RequestDamageDisplay_Local(class AActor* DamagedActor, class AActor* DamageCauser, int32 BaseDamage, float CuttingRateByBlocking, bool bPenetrateAP, const struct FGameplayTag& DamageType, bool bWithoutStand, const struct FVector& HitLocation, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RequestDamageDisplay_Local");

	Params::AJBIngameUtilFunctionLibrary_C_RequestDamageDisplay_Local Parms{};

	Parms.DamagedActor = DamagedActor;
	Parms.DamageCauser = DamageCauser;
	Parms.BaseDamage = BaseDamage;
	Parms.CuttingRateByBlocking = CuttingRateByBlocking;
	Parms.bPenetrateAP = bPenetrateAP;
	Parms.DamageType = std::move(DamageType);
	Parms.bWithoutStand = bWithoutStand;
	Parms.HitLocation = std::move(HitLocation);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetSeparatedStand
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         Owner                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AAJBInGameCharacterBase**         SeparatedStand                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetSeparatedStand(class ABP_AJBInGameCharacter_C* Owner, class UObject* __WorldContext, class AAJBInGameCharacterBase** SeparatedStand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetSeparatedStand");

	Params::AJBIngameUtilFunctionLibrary_C_GetSeparatedStand Parms{};

	Parms.Owner = Owner;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SeparatedStand != nullptr)
		*SeparatedStand = Parms.SeparatedStand;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.DamageLocal
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   Damage                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::DamageLocal(class AActor* HitActor, int32 Damage, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "DamageLocal");

	Params::AJBIngameUtilFunctionLibrary_C_DamageLocal Parms{};

	Parms.HitActor = HitActor;
	Parms.Damage = Damage;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsFriendlyFireTarget
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           SelfContext                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsFriendlyFireTarget_0                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsFriendlyFireTarget(class AActor* Target, class AActor* SelfContext, class UObject* __WorldContext, bool* IsFriendlyFireTarget_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsFriendlyFireTarget");

	Params::AJBIngameUtilFunctionLibrary_C_IsFriendlyFireTarget Parms{};

	Parms.Target = Target;
	Parms.SelfContext = SelfContext;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsFriendlyFireTarget_0 != nullptr)
		*IsFriendlyFireTarget_0 = Parms.IsFriendlyFireTarget_0;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsNPCEasy
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class APawn*                            Pawn                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bIsNPCEasy                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsNPCEasy(class APawn* Pawn, class UObject* __WorldContext, bool* bIsNPCEasy)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsNPCEasy");

	Params::AJBIngameUtilFunctionLibrary_C_IsNPCEasy Parms{};

	Parms.Pawn = Pawn;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bIsNPCEasy != nullptr)
		*bIsNPCEasy = Parms.bIsNPCEasy;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetCharacterBPByMatchingPlayerIndex
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   MatchingPlayerIndex                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bFound                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class ABP_AJBInGameCharacter_C**        CharacterBP                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetCharacterBPByMatchingPlayerIndex(int32 MatchingPlayerIndex, class UObject* __WorldContext, bool* bFound, class ABP_AJBInGameCharacter_C** CharacterBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetCharacterBPByMatchingPlayerIndex");

	Params::AJBIngameUtilFunctionLibrary_C_GetCharacterBPByMatchingPlayerIndex Parms{};

	Parms.MatchingPlayerIndex = MatchingPlayerIndex;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bFound != nullptr)
		*bFound = Parms.bFound;

	if (CharacterBP != nullptr)
		*CharacterBP = Parms.CharacterBP;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetDamageImpulseTargetActors
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// TArray<class AActor*>*                  OutActors                                              (Parm, OutParm, ZeroConstructor)

void UAJBIngameUtilFunctionLibrary_C::GetDamageImpulseTargetActors(class UObject* __WorldContext, TArray<class AActor*>* OutActors)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetDamageImpulseTargetActors");

	Params::AJBIngameUtilFunctionLibrary_C_GetDamageImpulseTargetActors Parms{};

	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (OutActors != nullptr)
		*OutActors = std::move(Parms.OutActors);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.RegisterDamageImpulseTargetActor
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::RegisterDamageImpulseTargetActor(class AActor* Actor, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "RegisterDamageImpulseTargetActor");

	Params::AJBIngameUtilFunctionLibrary_C_RegisterDamageImpulseTargetActor Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.UnregisterDamageImpulseTargetActor
// (Static, Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::UnregisterDamageImpulseTargetActor(class AActor* Actor, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "UnregisterDamageImpulseTargetActor");

	Params::AJBIngameUtilFunctionLibrary_C_UnregisterDamageImpulseTargetActor Parms{};

	Parms.Actor = Actor;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.WillDeterminateLastSurvivorOnThisFrame_OnServer
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const TSet<class ABP_AJBInGameCharacter_C*>&IgnoredCharacter                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool UAJBIngameUtilFunctionLibrary_C::WillDeterminateLastSurvivorOnThisFrame_OnServer(const TSet<class ABP_AJBInGameCharacter_C*>& IgnoredCharacter, class UObject* __WorldContext)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "WillDeterminateLastSurvivorOnThisFrame_OnServer");

	Params::AJBIngameUtilFunctionLibrary_C_WillDeterminateLastSurvivorOnThisFrame_OnServer Parms{};

	Parms.IgnoredCharacter = std::move(IgnoredCharacter);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.GetCharacterType
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// ECharacterBattleType*                   CharacterType                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::GetCharacterType(class ABP_AJBInGameCharacter_C* CharacterBP, class UObject* __WorldContext, ECharacterBattleType* CharacterType)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "GetCharacterType");

	Params::AJBIngameUtilFunctionLibrary_C_GetCharacterType Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterType != nullptr)
		*CharacterType = Parms.CharacterType;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckPassiveTagProhibition
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// const struct FGameplayTagContainer&     PassiveTagContainer                                    (BlueprintVisible, BlueprintReadOnly, Parm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bProhibitionTag                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckPassiveTagProhibition(const struct FGameplayTagContainer& PassiveTagContainer, class UObject* __WorldContext, bool* bProhibitionTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckPassiveTagProhibition");

	Params::AJBIngameUtilFunctionLibrary_C_CheckPassiveTagProhibition Parms{};

	Parms.PassiveTagContainer = std::move(PassiveTagContainer);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bProhibitionTag != nullptr)
		*bProhibitionTag = Parms.bProhibitionTag;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.ExtractEmoteId
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// const TSoftObjectPtr<class UAnimMontage>&Emote                                                  (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class FString*                          CharacterTag                                           (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// int32*                                  emoteId                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::ExtractEmoteId(const TSoftObjectPtr<class UAnimMontage>& Emote, class UObject* __WorldContext, bool* Success, class FString* CharacterTag, int32* emoteId)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "ExtractEmoteId");

	Params::AJBIngameUtilFunctionLibrary_C_ExtractEmoteId Parms{};

	Parms.Emote = Emote;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (Success != nullptr)
		*Success = Parms.Success;

	if (CharacterTag != nullptr)
		*CharacterTag = std::move(Parms.CharacterTag);

	if (emoteId != nullptr)
		*emoteId = Parms.emoteId;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.CheckTheWorldOperator
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bOperator                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::CheckTheWorldOperator(class ABP_AJBInGameCharacter_C* CharacterBP, class UObject* __WorldContext, bool* bOperator)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "CheckTheWorldOperator");

	Params::AJBIngameUtilFunctionLibrary_C_CheckTheWorldOperator Parms{};

	Parms.CharacterBP = CharacterBP;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (bOperator != nullptr)
		*bOperator = Parms.bOperator;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.FindCharacterInfo
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// int32                                   CharacterID                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FAJBCharacterInfo*               CharacterInfo                                          (Parm, OutParm)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::FindCharacterInfo(int32 CharacterID, class UObject* __WorldContext, struct FAJBCharacterInfo* CharacterInfo, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "FindCharacterInfo");

	Params::AJBIngameUtilFunctionLibrary_C_FindCharacterInfo Parms{};

	Parms.CharacterID = CharacterID;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterInfo != nullptr)
		*CharacterInfo = std::move(Parms.CharacterInfo);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.TakeCharacterShortName
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const struct FGameplayTag&              GameplayTag                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          CharacterShortName                                     (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::TakeCharacterShortName(const struct FGameplayTag& GameplayTag, class UObject* __WorldContext, class FString* CharacterShortName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "TakeCharacterShortName");

	Params::AJBIngameUtilFunctionLibrary_C_TakeCharacterShortName Parms{};

	Parms.GameplayTag = std::move(GameplayTag);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterShortName != nullptr)
		*CharacterShortName = std::move(Parms.CharacterShortName);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.MakeSkinName
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// const class FString&                    ShortName                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, HasGetValueTypeHash)
// uint8                                   skinID                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          SkinName                                               (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)

void UAJBIngameUtilFunctionLibrary_C::MakeSkinName(const class FString& ShortName, uint8 skinID, class UObject* __WorldContext, class FString* SkinName)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "MakeSkinName");

	Params::AJBIngameUtilFunctionLibrary_C_MakeSkinName Parms{};

	Parms.ShortName = std::move(ShortName);
	Parms.skinID = skinID;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (SkinName != nullptr)
		*SkinName = std::move(Parms.SkinName);
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.MakeCharacterSkinName
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const struct FMatchingPlayerInfo&       MatchingPlayerInfo                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          CharacterSkinName                                      (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::MakeCharacterSkinName(const struct FMatchingPlayerInfo& MatchingPlayerInfo, class UObject* __WorldContext, class FString* CharacterSkinName, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "MakeCharacterSkinName");

	Params::AJBIngameUtilFunctionLibrary_C_MakeCharacterSkinName Parms{};

	Parms.MatchingPlayerInfo = std::move(MatchingPlayerInfo);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (CharacterSkinName != nullptr)
		*CharacterSkinName = std::move(Parms.CharacterSkinName);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.MakeStandSkinName
// (Static, Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, Const)
// Parameters:
// const struct FMatchingPlayerInfo&       MatchingPlayerInfo                                     (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class FString*                          StandSkinName                                          (Parm, OutParm, ZeroConstructor, HasGetValueTypeHash)
// bool*                                   Success                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::MakeStandSkinName(const struct FMatchingPlayerInfo& MatchingPlayerInfo, class UObject* __WorldContext, class FString* StandSkinName, bool* Success)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "MakeStandSkinName");

	Params::AJBIngameUtilFunctionLibrary_C_MakeStandSkinName Parms{};

	Parms.MatchingPlayerInfo = std::move(MatchingPlayerInfo);
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (StandSkinName != nullptr)
		*StandSkinName = std::move(Parms.StandSkinName);

	if (Success != nullptr)
		*Success = Parms.Success;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsActiveTransferState
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   SkillState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsActiveState                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsActiveTransferState(uint8 SkillState, class UObject* __WorldContext, bool* IsActiveState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsActiveTransferState");

	Params::AJBIngameUtilFunctionLibrary_C_IsActiveTransferState Parms{};

	Parms.SkillState = SkillState;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsActiveState != nullptr)
		*IsActiveState = Parms.IsActiveState;
}


// Function AJBIngameUtilFunctionLibrary.AJBIngameUtilFunctionLibrary_C.IsAppearTransferState
// (Static, Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure, Const)
// Parameters:
// uint8                                   SkillState                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UObject*                          __WorldContext                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   IsAppearState                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UAJBIngameUtilFunctionLibrary_C::IsAppearTransferState(uint8 SkillState, class UObject* __WorldContext, bool* IsAppearState)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = StaticClass()->GetFunction("AJBIngameUtilFunctionLibrary_C", "IsAppearTransferState");

	Params::AJBIngameUtilFunctionLibrary_C_IsAppearTransferState Parms{};

	Parms.SkillState = SkillState;
	Parms.__WorldContext = __WorldContext;

	GetDefaultObj()->ProcessEvent(Func, &Parms);

	if (IsAppearState != nullptr)
		*IsAppearState = Parms.IsAppearState;
}

}

