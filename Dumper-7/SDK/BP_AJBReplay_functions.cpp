#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBReplay

#include "Basic.hpp"

#include "BP_AJBReplay_classes.hpp"
#include "BP_AJBReplay_parameters.hpp"


namespace SDK
{

// Function BP_AJBReplay.BP_AJBReplay_C.ExecuteUbergraph_BP_AJBReplay
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBReplay_C::ExecuteUbergraph_BP_AJBReplay(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "ExecuteUbergraph_BP_AJBReplay");

	Params::BP_AJBReplay_C_ExecuteUbergraph_BP_AJBReplay Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.StopLongInteractSe
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::StopLongInteractSe()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "StopLongInteractSe");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.PlayLongInteractSE
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::PlayLongInteractSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "PlayLongInteractSE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.OnInteractSucceedServer
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         TargetCharacterBP                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FTransform&                InteractActorTransform                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// const struct FDateTime&                 AccessedHistoryDateTime                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void UBP_AJBReplay_C::OnInteractSucceedServer(class ABP_AJBInGameCharacter_C* TargetCharacterBP, const struct FTransform& InteractActorTransform, const struct FDateTime& AccessedHistoryDateTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "OnInteractSucceedServer");

	Params::BP_AJBReplay_C_OnInteractSucceedServer Parms{};

	Parms.TargetCharacterBP = TargetCharacterBP;
	Parms.InteractActorTransform = std::move(InteractActorTransform);
	Parms.AccessedHistoryDateTime = std::move(AccessedHistoryDateTime);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.OnInteractSucceed
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                InteractActorTransform                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::OnInteractSucceed(const struct FTransform& InteractActorTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "OnInteractSucceed");

	Params::BP_AJBReplay_C_OnInteractSucceed Parms{};

	Parms.InteractActorTransform = std::move(InteractActorTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.MC_SuccessInteract
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// const struct FTransform&                InteractActorTransform                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::MC_SuccessInteract(const struct FTransform& InteractActorTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "MC_SuccessInteract");

	Params::BP_AJBReplay_C_MC_SuccessInteract Parms{};

	Parms.InteractActorTransform = std::move(InteractActorTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.OnCompleteReplay
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::OnCompleteReplay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "OnCompleteReplay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.ROS_SuccessInteract
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   TargetPlayerID                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FDateTime&                 AccessedHistoryDateTime                                (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// const struct FTransform&                InteractActorTransform                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::ROS_SuccessInteract(int32 TargetPlayerID, const struct FDateTime& AccessedHistoryDateTime, const struct FTransform& InteractActorTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "ROS_SuccessInteract");

	Params::BP_AJBReplay_C_ROS_SuccessInteract Parms{};

	Parms.TargetPlayerID = TargetPlayerID;
	Parms.AccessedHistoryDateTime = std::move(AccessedHistoryDateTime);
	Parms.InteractActorTransform = std::move(InteractActorTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.End_ReplayLoopSE
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::End_ReplayLoopSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "End_ReplayLoopSE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.Pause_ReplayLoopSE
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::Pause_ReplayLoopSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "Pause_ReplayLoopSE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.OnEnd_ReplayLoopSE
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// EAkCallbackType                         CallbackType                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UAkCallbackInfo*                  CallbackInfo                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBReplay_C::OnEnd_ReplayLoopSE(EAkCallbackType CallbackType, class UAkCallbackInfo* CallbackInfo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "OnEnd_ReplayLoopSE");

	Params::BP_AJBReplay_C_OnEnd_ReplayLoopSE Parms{};

	Parms.CallbackType = CallbackType;
	Parms.CallbackInfo = CallbackInfo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.Resume_ReplayLoopSE
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::Resume_ReplayLoopSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "Resume_ReplayLoopSE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.Play_ReplayLoopSE
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::Play_ReplayLoopSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "Play_ReplayLoopSE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.FindHistoryTarget
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// int32                                   PlayerID                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class ABP_AJBInGameCharacter_C**        TargetCharacterBP                                      (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBReplay_C::FindHistoryTarget(int32 PlayerID, class ABP_AJBInGameCharacter_C** TargetCharacterBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "FindHistoryTarget");

	Params::BP_AJBReplay_C_FindHistoryTarget Parms{};

	Parms.PlayerID = PlayerID;

	UObject::ProcessEvent(Func, &Parms);

	if (TargetCharacterBP != nullptr)
		*TargetCharacterBP = Parms.TargetCharacterBP;
}


// Function BP_AJBReplay.BP_AJBReplay_C.SpawnReplayActor
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         TargetCharacterBP                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// const struct FTransform&                InteractActorTransform                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::SpawnReplayActor(class ABP_AJBInGameCharacter_C* TargetCharacterBP, const struct FTransform& InteractActorTransform)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "SpawnReplayActor");

	Params::BP_AJBReplay_C_SpawnReplayActor Parms{};

	Parms.TargetCharacterBP = TargetCharacterBP;
	Parms.InteractActorTransform = std::move(InteractActorTransform);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.OnLongPressInteractBegan
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           InteractActor_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBReplay_C::OnLongPressInteractBegan(class AActor* InteractActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "OnLongPressInteractBegan");

	Params::BP_AJBReplay_C_OnLongPressInteractBegan Parms{};

	Parms.InteractActor_0 = InteractActor_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.OnLongPressInteractEnded
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bSuccess                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bForceCancel                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           InteractActor_0                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFlag01                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::OnLongPressInteractEnded(bool bSuccess, bool bForceCancel, class AActor* InteractActor_0, bool bFlag01)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "OnLongPressInteractEnded");

	Params::BP_AJBReplay_C_OnLongPressInteractEnded Parms{};

	Parms.bSuccess = bSuccess;
	Parms.bForceCancel = bForceCancel;
	Parms.InteractActor_0 = InteractActor_0;
	Parms.bFlag01 = bFlag01;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.OnChangedViewTarget
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_AJBReplay_C::OnChangedViewTarget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "OnChangedViewTarget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_AJBReplay_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBReplay.BP_AJBReplay_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBReplay_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "ReceiveTick");

	Params::BP_AJBReplay_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.BeginInteract
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool*                                   bSuccess                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::BeginInteract(bool* bSuccess)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "BeginInteract");

	Params::BP_AJBReplay_C_BeginInteract Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bSuccess != nullptr)
		*bSuccess = Parms.bSuccess;
}


// Function BP_AJBReplay.BP_AJBReplay_C.CheckInteractable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         OperatorCharacter                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           TargetActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   BaseTraceLength                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool*                                   bInteractable                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::CheckInteractable(class ABP_AJBInGameCharacter_C* OperatorCharacter, class AActor* TargetActor, float BaseTraceLength, bool* bInteractable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "CheckInteractable");

	Params::BP_AJBReplay_C_CheckInteractable Parms{};

	Parms.OperatorCharacter = OperatorCharacter;
	Parms.TargetActor = TargetActor;
	Parms.BaseTraceLength = BaseTraceLength;

	UObject::ProcessEvent(Func, &Parms);

	if (bInteractable != nullptr)
		*bInteractable = Parms.bInteractable;
}


// Function BP_AJBReplay.BP_AJBReplay_C.NotifyTheWorld
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAJBInGameCharacter*              Operator                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGeneralTiming                          Timing                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bOperatorIsEmpty                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "NotifyTheWorld");

	Params::BP_AJBReplay_C_NotifyTheWorld Parms{};

	Parms.Operator = Operator;
	Parms.Time = Time;
	Parms.Timing = Timing;
	Parms.bEnable = bEnable;
	Parms.bOperatorIsEmpty = bOperatorIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBReplay.BP_AJBReplay_C.CheckActive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool*                                   bActive                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBReplay_C::CheckActive(bool* bActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBReplay_C", "CheckActive");

	Params::BP_AJBReplay_C_CheckActive Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bActive != nullptr)
		*bActive = Parms.bActive;
}

}

