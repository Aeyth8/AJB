#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBSprintSkill

#include "Basic.hpp"

#include "E_SidlingFinishTiming_structs.hpp"
#include "Engine_structs.hpp"
#include "GameplayTags_structs.hpp"
#include "AJB_structs.hpp"
#include "BP_AJBSkillBase_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_AJBSprintSkill.BP_AJBSprintSkill_C
// 0x0098 (0x0280 - 0x01E8)
class UBP_AJBSprintSkill_C : public UBP_AJBSkillBase_C
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame_BP_AJBSprintSkill_C;                // 0x01E8(0x0008)(Transient, DuplicateTransient)
	float                                         MaxWaitTime_s_;                                    // 0x01F0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ActionTime;                                        // 0x01F4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ClearingTime;                                      // 0x01F8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SprintSpeed;                                       // 0x01FC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SprintAcceleration;                                // 0x0200(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_204[0x4];                                      // 0x0204(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class UAnimMontage*                           SprintMontage;                                     // 0x0208(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	struct FGameplayTag                           ViewModeTag;                                       // 0x0210(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	int32                                         CloseRangeKindSkillNo;                             // 0x0218(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AttackCollisionRadius;                             // 0x021C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ShouldStopOnHit;                                   // 0x0220(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          ShouldIgnoreBlocking;                              // 0x0221(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          ShouldIgnoreProps;                                 // 0x0222(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_223[0x5];                                      // 0x0223(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class UClass*                                 CollisionDetectorClass;                            // 0x0228(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          ShouldNotBreakWindow;                              // 0x0230(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_231[0x7];                                      // 0x0231(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           AddPassiveVoiceTag;                                // 0x0238(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	class ABP_AJBDamageActor_C*                   DamageActorCache;                                  // 0x0240(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, Transient, DisableEditOnInstance, IsPlainOldData, NoDestructor, AdvancedDisplay, HasGetValueTypeHash)
	TArray<struct FGameplayTag>                   VoiceTagsBlockingPassiveVoice;                     // 0x0248(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	bool                                          ShouldPenetrateBarrier;                            // 0x0258(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_259[0x7];                                      // 0x0259(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<ECharacterBattleType>                  CharacterTypeBlockingPassive;                      // 0x0260(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	bool                                          ShouldIgnorePassiveForMovableStand;                // 0x0270(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_271[0x7];                                      // 0x0271(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FGameplayTag                           SprintCameraTag;                                   // 0x0278(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)

public:
	void ExecuteUbergraph_BP_AJBSprintSkill(int32 EntryPoint);
	void ROS_ApplySprintDamage(class AActor* HitActor, class UActorComponent* HitComponent, const struct FVector& Hit_Location, const struct FVector& HitNormal, int32 SerialNumber_0, float CuttingRate);
	void MC_ApplySprintDamage(class AActor* HitActor, class UActorComponent* HitComponent, const struct FVector& HitLocation, const struct FVector& HitNormal, int32 SerialNumber_0, float CuttingRate);
	void ROS_OnOverlappedDamgeDetector(class AActor* Target, class AActor* DamageCauser, const struct FVector& HitLocation);
	void OnOverlappedDamgeDetector(class AActor* Target, class AActor* DamageCauser, const struct FVector& HitLocation);
	void OnBlockedDamageActor(class AActor* BlockedActor, const struct FVector& HitLocation, const struct FVector& HitNormal, float CuttingRate, bool bInvincible, bool bIsPenetration, bool bAvoidSkill);
	void ApplySprintDamage_Server(class AActor* HitActor, class UActorComponent* HitComponent, const struct FVector& Hit_Location, const struct FVector& HitNormal, int32 SerialNumber_0, float CuttingRate);
	void ApplySprintDamage_Local(class AActor* HitActor, class UActorComponent* HitComponent, const struct FVector& HitLocation, const struct FVector& HitNormal, int32 SerialNumber_0, float CuttingRate);
	void ApplySprintDamage(class AActor* HitActor, class UActorComponent* HitComponent, const struct FVector& Hit_Location, const struct FVector& HitNormal, float CuttingRate);
	void FinishDamageActor();
	void OnHitDamageActor(class AActor* HitActor, class UActorComponent* HitComponent, const struct FVector& HitLocation, const struct FVector& HitNormal, EPhysicalSurface SurfaceType, bool bDisableDamage, bool bIsPenetration);
	void InitDamageActor();
	void SetSkillMovementMode(bool IsEnabled);
	void ROS_EndState();
	void MC_EndState();
	void ROS_BeginState_Clearing();
	void MC_BeginState_Clearing();
	void ROS_BeginState_Action();
	void MC_BeginState_Action();
	void ROS_BeginState_Ready();
	void MC_BeginState_Ready();
	void EndState_Local();
	void EndState();
	void TickState_Clearing(float DeltaSeconds);
	void BeginState_Clearing_Local();
	void BeginState_Clearing();
	void TickState(float DeltaSeconds);
	void TickState_Action(float DeltaSeconds);
	void BeginState_Action_Local();
	void BeginState_Action();
	void TickState_Ready(float DeltaSeconds);
	void BeginState_Ready_Local();
	void BeginState_Ready();
	void DebugTick(float DeltaSeconds);
	void OnCompleted_7DDD297442D7CC4375E0C99B1D1DE40C(class FName NotifyName);
	void OnBlendOut_7DDD297442D7CC4375E0C99B1D1DE40C(class FName NotifyName);
	void OnInterrupted_7DDD297442D7CC4375E0C99B1D1DE40C(class FName NotifyName);
	void OnNotifyBegin_7DDD297442D7CC4375E0C99B1D1DE40C(class FName NotifyName);
	void OnNotifyEnd_7DDD297442D7CC4375E0C99B1D1DE40C(class FName NotifyName);
	void IsReadySprint(bool* IsReady);
	void IsCancelable(bool* IsCancelable_0);
	void CreateDamageActor(class ABP_AJBDamageActor_C** DamageActor);
	void GetLaunchedActorTarget(class AActor** LaunchedActorTarget);
	void GetBaseDamage(int32* BaseDamage);
	void GetOrCreateDamageActorCache(class ABP_AJBDamageActor_C** DamageActorCache_0);
	void GetDamageActorCache(class ABP_AJBDamageActor_C** DamageActorCache_0);
	void GetSprintCharacter(class ABP_AJBInGameCharacter_C** SprintCharacter);
	void ReceiveBeginPlay();
	void StateBeginPlay(bool bShouldRestore);
	void OnCancel();
	void OnActive();
	void ReceiveTick(float DeltaSeconds);
	void ShouldCancelOnLandingStop(bool* bShouldCancel);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_AJBSprintSkill_C">();
	}
	static class UBP_AJBSprintSkill_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_AJBSprintSkill_C>();
	}
};
static_assert(alignof(UBP_AJBSprintSkill_C) == 0x000008, "Wrong alignment on UBP_AJBSprintSkill_C");
static_assert(sizeof(UBP_AJBSprintSkill_C) == 0x000280, "Wrong size on UBP_AJBSprintSkill_C");
static_assert(offsetof(UBP_AJBSprintSkill_C, UberGraphFrame_BP_AJBSprintSkill_C) == 0x0001E8, "Member 'UBP_AJBSprintSkill_C::UberGraphFrame_BP_AJBSprintSkill_C' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, MaxWaitTime_s_) == 0x0001F0, "Member 'UBP_AJBSprintSkill_C::MaxWaitTime_s_' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ActionTime) == 0x0001F4, "Member 'UBP_AJBSprintSkill_C::ActionTime' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ClearingTime) == 0x0001F8, "Member 'UBP_AJBSprintSkill_C::ClearingTime' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, SprintSpeed) == 0x0001FC, "Member 'UBP_AJBSprintSkill_C::SprintSpeed' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, SprintAcceleration) == 0x000200, "Member 'UBP_AJBSprintSkill_C::SprintAcceleration' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, SprintMontage) == 0x000208, "Member 'UBP_AJBSprintSkill_C::SprintMontage' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ViewModeTag) == 0x000210, "Member 'UBP_AJBSprintSkill_C::ViewModeTag' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, CloseRangeKindSkillNo) == 0x000218, "Member 'UBP_AJBSprintSkill_C::CloseRangeKindSkillNo' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, AttackCollisionRadius) == 0x00021C, "Member 'UBP_AJBSprintSkill_C::AttackCollisionRadius' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ShouldStopOnHit) == 0x000220, "Member 'UBP_AJBSprintSkill_C::ShouldStopOnHit' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ShouldIgnoreBlocking) == 0x000221, "Member 'UBP_AJBSprintSkill_C::ShouldIgnoreBlocking' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ShouldIgnoreProps) == 0x000222, "Member 'UBP_AJBSprintSkill_C::ShouldIgnoreProps' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, CollisionDetectorClass) == 0x000228, "Member 'UBP_AJBSprintSkill_C::CollisionDetectorClass' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ShouldNotBreakWindow) == 0x000230, "Member 'UBP_AJBSprintSkill_C::ShouldNotBreakWindow' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, AddPassiveVoiceTag) == 0x000238, "Member 'UBP_AJBSprintSkill_C::AddPassiveVoiceTag' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, DamageActorCache) == 0x000240, "Member 'UBP_AJBSprintSkill_C::DamageActorCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, VoiceTagsBlockingPassiveVoice) == 0x000248, "Member 'UBP_AJBSprintSkill_C::VoiceTagsBlockingPassiveVoice' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ShouldPenetrateBarrier) == 0x000258, "Member 'UBP_AJBSprintSkill_C::ShouldPenetrateBarrier' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, CharacterTypeBlockingPassive) == 0x000260, "Member 'UBP_AJBSprintSkill_C::CharacterTypeBlockingPassive' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, ShouldIgnorePassiveForMovableStand) == 0x000270, "Member 'UBP_AJBSprintSkill_C::ShouldIgnorePassiveForMovableStand' has a wrong offset!");
static_assert(offsetof(UBP_AJBSprintSkill_C, SprintCameraTag) == 0x000278, "Member 'UBP_AJBSprintSkill_C::SprintCameraTag' has a wrong offset!");

}

