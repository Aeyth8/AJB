#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBDamageActor

#include "Basic.hpp"

#include "BP_AJBDamageActor_classes.hpp"
#include "BP_AJBDamageActor_parameters.hpp"


namespace SDK
{

// Function BP_AJBDamageActor.BP_AJBDamageActor_C.OnTargetHit__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EPhysicalSurface                        SurfaceType                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bDisableDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIsPenetration_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::OnTargetHit__DelegateSignature(class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& HitNormal, EPhysicalSurface SurfaceType, bool bDisableDamage, bool bIsPenetration_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "OnTargetHit__DelegateSignature");

	Params::BP_AJBDamageActor_C_OnTargetHit__DelegateSignature Parms{};

	Parms.HitActor = HitActor;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.SurfaceType = SurfaceType;
	Parms.bDisableDamage = bDisableDamage;
	Parms.bIsPenetration_0 = bIsPenetration_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.OnBlocking__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           BlockedActor_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   CuttingRate                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bInvincible                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIsPenetration_0                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::OnBlocking__DelegateSignature(class AActor* BlockedActor_0, const struct FVector& HitLocation, float CuttingRate, bool bInvincible, bool bIsPenetration_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "OnBlocking__DelegateSignature");

	Params::BP_AJBDamageActor_C_OnBlocking__DelegateSignature Parms{};

	Parms.BlockedActor_0 = BlockedActor_0;
	Parms.HitLocation = std::move(HitLocation);
	Parms.CuttingRate = CuttingRate;
	Parms.bInvincible = bInvincible;
	Parms.bIsPenetration_0 = bIsPenetration_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.OnTargetOverlap__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           DamageCauser                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::OnTargetOverlap__DelegateSignature(class AActor* Target, class AActor* DamageCauser, const struct FVector& HitLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "OnTargetOverlap__DelegateSignature");

	Params::BP_AJBDamageActor_C_OnTargetOverlap__DelegateSignature Parms{};

	Parms.Target = Target;
	Parms.DamageCauser = DamageCauser;
	Parms.HitLocation = std::move(HitLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.OnPenetrateHit__DelegateSignature
// (Public, Delegate, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          Location                                               (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Normal                                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bCharacter                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::OnPenetrateHit__DelegateSignature(const struct FVector& Location, const struct FVector& Normal, bool bCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "OnPenetrateHit__DelegateSignature");

	Params::BP_AJBDamageActor_C_OnPenetrateHit__DelegateSignature Parms{};

	Parms.Location = std::move(Location);
	Parms.Normal = std::move(Normal);
	Parms.bCharacter = bCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.ExecuteUbergraph_BP_AJBDamageActor
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::ExecuteUbergraph_BP_AJBDamageActor(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "ExecuteUbergraph_BP_AJBDamageActor");

	Params::BP_AJBDamageActor_C_ExecuteUbergraph_BP_AJBDamageActor Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.ReceiveEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "ReceiveEndPlay");

	Params::BP_AJBDamageActor_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.UpdateTransform
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::UpdateTransform()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "UpdateTransform");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature
// (HasOutParams, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       SweepResult                                            (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ReferenceParm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_AJBDamageActor_C::BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature");

	Params::BP_AJBDamageActor_C_BndEvt__Sphere_K2Node_ComponentBoundEvent_0_ComponentBeginOverlapSignature__DelegateSignature Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.OnHit
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       SweepResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_AJBDamageActor_C::OnHit(class AActor* OtherActor, class UPrimitiveComponent* OtherComp, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "OnHit");

	Params::BP_AJBDamageActor_C_OnHit Parms{};

	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "ReceiveTick");

	Params::BP_AJBDamageActor_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.TryGivePassive
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Target                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     CauserType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::TryGivePassive(class UObject* Target, const struct FGameplayTag& CauserType, int32 SerialNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "TryGivePassive");

	Params::BP_AJBDamageActor_C_TryGivePassive Parms{};

	Parms.Target = Target;
	Parms.CauserType = std::move(CauserType);
	Parms.SerialNumber = SerialNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.StopParticle
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::StopParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "StopParticle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.StartParticle
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::StartParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "StartParticle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_AJBDamageActor_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.OnOverlapped
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              OverlappedComponent                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UPrimitiveComponent*              OtherComp                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   OtherBodyIndex                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bFromSweep                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FHitResult                       SweepResult                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)

void ABP_AJBDamageActor_C::OnOverlapped(class UPrimitiveComponent* OverlappedComponent, class AActor* OtherActor, class UPrimitiveComponent* OtherComp, int32 OtherBodyIndex, bool bFromSweep, const struct FHitResult& SweepResult)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "OnOverlapped");

	Params::BP_AJBDamageActor_C_OnOverlapped Parms{};

	Parms.OverlappedComponent = OverlappedComponent;
	Parms.OtherActor = OtherActor;
	Parms.OtherComp = OtherComp;
	Parms.OtherBodyIndex = OtherBodyIndex;
	Parms.bFromSweep = bFromSweep;
	Parms.SweepResult = std::move(SweepResult);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.Blocking
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           BlockedActor_0                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AActor*                           OtherActor                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitLocation                                            (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          HitNormal                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CuttingProjectile___                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CuttingOther___                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bInvincible                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bReflectProjectile                                     (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FRotator                         ReflectRotation                                        (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor)
// bool                                    bAvoidSkill                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bSeparateStandAttack                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FGameplayTag                     ReflectSkillTag                                        (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::Blocking(class AActor* BlockedActor_0, class AActor* OtherActor, const struct FVector& HitLocation, const struct FVector& HitNormal, int32 CuttingProjectile___, int32 CuttingOther___, bool bInvincible, bool bReflectProjectile, const struct FRotator& ReflectRotation, bool bAvoidSkill, bool bSeparateStandAttack, const struct FGameplayTag& ReflectSkillTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "Blocking");

	Params::BP_AJBDamageActor_C_Blocking Parms{};

	Parms.BlockedActor_0 = BlockedActor_0;
	Parms.OtherActor = OtherActor;
	Parms.HitLocation = std::move(HitLocation);
	Parms.HitNormal = std::move(HitNormal);
	Parms.CuttingProjectile___ = CuttingProjectile___;
	Parms.CuttingOther___ = CuttingOther___;
	Parms.bInvincible = bInvincible;
	Parms.bReflectProjectile = bReflectProjectile;
	Parms.ReflectRotation = std::move(ReflectRotation);
	Parms.bAvoidSkill = bAvoidSkill;
	Parms.bSeparateStandAttack = bSeparateStandAttack;
	Parms.ReflectSkillTag = std::move(ReflectSkillTag);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.ChangeEnable
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           TargetActor_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UActorComponent*                  TargetComponent_0                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          TargetActorHitLocation                                 (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// int32                                   CloseRangeSkillNo_0                                    (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::ChangeEnable(bool bEnable, class AActor* TargetActor_0, class UActorComponent* TargetComponent_0, const struct FVector& TargetActorHitLocation, int32 CloseRangeSkillNo_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "ChangeEnable");

	Params::BP_AJBDamageActor_C_ChangeEnable Parms{};

	Parms.bEnable = bEnable;
	Parms.TargetActor_0 = TargetActor_0;
	Parms.TargetComponent_0 = TargetComponent_0;
	Parms.TargetActorHitLocation = std::move(TargetActorHitLocation);
	Parms.CloseRangeSkillNo_0 = CloseRangeSkillNo_0;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckTargetMatch
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AActor*                           HitActor                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class UActorComponent*                  HitComponent                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bMatch                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::CheckTargetMatch(class AActor* HitActor, class UActorComponent* HitComponent, bool* bMatch)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckTargetMatch");

	Params::BP_AJBDamageActor_C_CheckTargetMatch Parms{};

	Parms.HitActor = HitActor;
	Parms.HitComponent = HitComponent;

	UObject::ProcessEvent(Func, &Parms);

	if (bMatch != nullptr)
		*bMatch = Parms.bMatch;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.TrackingStandPoint
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::TrackingStandPoint()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "TrackingStandPoint");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.TrackingStandRotation
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::TrackingStandRotation()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "TrackingStandRotation");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.ChangeCollisionEnable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::ChangeCollisionEnable(bool bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "ChangeCollisionEnable");

	Params::BP_AJBDamageActor_C_ChangeCollisionEnable Parms{};

	Parms.bEnable = bEnable;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckCollisionEnable
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bEnable                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::CheckCollisionEnable(bool* bEnable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckCollisionEnable");

	Params::BP_AJBDamageActor_C_CheckCollisionEnable Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bEnable != nullptr)
		*bEnable = Parms.bEnable;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.DebugShowCollision
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bNeedEnableCheck                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FLinearColor                     LineColor                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::DebugShowCollision(bool bNeedEnableCheck, const struct FLinearColor& LineColor)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "DebugShowCollision");

	Params::BP_AJBDamageActor_C_DebugShowCollision Parms{};

	Parms.bNeedEnableCheck = bNeedEnableCheck;
	Parms.LineColor = std::move(LineColor);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.DebugShowLine
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          NextLocation                                           (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::DebugShowLine(const struct FVector& NextLocation)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "DebugShowLine");

	Params::BP_AJBDamageActor_C_DebugShowLine Parms{};

	Parms.NextLocation = std::move(NextLocation);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.TryChangeDisable
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsCharacter                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::TryChangeDisable(bool bIsCharacter)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "TryChangeDisable");

	Params::BP_AJBDamageActor_C_TryChangeDisable Parms{};

	Parms.bIsCharacter = bIsCharacter;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.UpdateLocationPreTick
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::UpdateLocationPreTick()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "UpdateLocationPreTick");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckShouldCharacterHit
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    bShouldCharacterHit                                    (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::CheckShouldCharacterHit(const struct FHitResult& HitResult, bool* bShouldCharacterHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckShouldCharacterHit");

	Params::BP_AJBDamageActor_C_CheckShouldCharacterHit Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldCharacterHit != nullptr)
		*bShouldCharacterHit = Parms.bShouldCharacterHit;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckHit
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::CheckHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.HitTrace
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          StartLocation                                          (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FVector                          Direction                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Distance                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bContinued                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::HitTrace(const struct FVector& StartLocation, const struct FVector& Direction, float Distance, bool* bContinued)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "HitTrace");

	Params::BP_AJBDamageActor_C_HitTrace Parms{};

	Parms.StartLocation = std::move(StartLocation);
	Parms.Direction = std::move(Direction);
	Parms.Distance = Distance;

	UObject::ProcessEvent(Func, &Parms);

	if (bContinued != nullptr)
		*bContinued = Parms.bContinued;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckCharacterHitOwner
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    bHit                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::CheckCharacterHitOwner(const struct FHitResult& HitResult, bool* bHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckCharacterHitOwner");

	Params::BP_AJBDamageActor_C_CheckCharacterHitOwner Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (bHit != nullptr)
		*bHit = Parms.bHit;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckCharacterHitTarget
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    bHit                                                   (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::CheckCharacterHitTarget(const struct FHitResult& HitResult, bool* bHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckCharacterHitTarget");

	Params::BP_AJBDamageActor_C_CheckCharacterHitTarget Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (bHit != nullptr)
		*bHit = Parms.bHit;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.NotifyEndMultipleHit
// (Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBDamageActor_C::NotifyEndMultipleHit()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "NotifyEndMultipleHit");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.IsPassiveOnly
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBDamageActor_C::IsPassiveOnly()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "IsPassiveOnly");

	Params::BP_AJBDamageActor_C_IsPassiveOnly Parms{};

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.RemoveFromHittedActor
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor_0                                          (ConstParm, BlueprintVisible, BlueprintReadOnly, Parm, OutParm, ZeroConstructor, ReferenceParm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    ReturnValue                                            (Parm, OutParm, ZeroConstructor, ReturnParm, IsPlainOldData, NoDestructor)

bool ABP_AJBDamageActor_C::RemoveFromHittedActor(const class AActor*& TargetActor_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "RemoveFromHittedActor");

	Params::BP_AJBDamageActor_C_RemoveFromHittedActor Parms{};

	Parms.TargetActor_0 = TargetActor_0;

	UObject::ProcessEvent(Func, &Parms);

	return Parms.ReturnValue;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.IsHittableCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           Actor                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIsHittable                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::IsHittableCharacter(class AActor* Actor, bool* bIsHittable)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "IsHittableCharacter");

	Params::BP_AJBDamageActor_C_IsHittableCharacter Parms{};

	Parms.Actor = Actor;

	UObject::ProcessEvent(Func, &Parms);

	if (bIsHittable != nullptr)
		*bIsHittable = Parms.bIsHittable;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.GetSkillInfoOnPassiveAdded
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     SkillTag                                               (Parm, OutParm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber                                           (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::GetSkillInfoOnPassiveAdded(struct FGameplayTag* SkillTag, int32* SerialNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "GetSkillInfoOnPassiveAdded");

	Params::BP_AJBDamageActor_C_GetSkillInfoOnPassiveAdded Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (SkillTag != nullptr)
		*SkillTag = std::move(Parms.SkillTag);

	if (SerialNumber != nullptr)
		*SerialNumber = Parms.SerialNumber;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.ShouldHitCheck
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FHitResult                       HitResult                                              (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, ContainsInstancedReference)
// bool                                    bShouldHit                                             (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::ShouldHitCheck(const struct FHitResult& HitResult, bool* bShouldHit)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "ShouldHitCheck");

	Params::BP_AJBDamageActor_C_ShouldHitCheck Parms{};

	Parms.HitResult = std::move(HitResult);

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldHit != nullptr)
		*bShouldHit = Parms.bShouldHit;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckIgnoreBlocking
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           TargetActor_0                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnore                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::CheckIgnoreBlocking(class AActor* TargetActor_0, bool* bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckIgnoreBlocking");

	Params::BP_AJBDamageActor_C_CheckIgnoreBlocking Parms{};

	Parms.TargetActor_0 = TargetActor_0;

	UObject::ProcessEvent(Func, &Parms);

	if (bIgnore != nullptr)
		*bIgnore = Parms.bIgnore;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.CheckPassiveOnly
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bIsPassiveOnly                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBDamageActor_C::CheckPassiveOnly(bool* bIsPassiveOnly)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "CheckPassiveOnly");

	Params::BP_AJBDamageActor_C_CheckPassiveOnly Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bIsPassiveOnly != nullptr)
		*bIsPassiveOnly = Parms.bIsPassiveOnly;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.GetDuration
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   Duration                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::GetDuration(float* Duration)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "GetDuration");

	Params::BP_AJBDamageActor_C_GetDuration Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Duration != nullptr)
		*Duration = Parms.Duration;
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.GetPassiveSkillTag
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     PassiveSkillTag                                        (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::GetPassiveSkillTag(struct FGameplayTag* PassiveSkillTag)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "GetPassiveSkillTag");

	Params::BP_AJBDamageActor_C_GetPassiveSkillTag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (PassiveSkillTag != nullptr)
		*PassiveSkillTag = std::move(Parms.PassiveSkillTag);
}


// Function BP_AJBDamageActor.BP_AJBDamageActor_C.GetCauserOwnerCharacterBP
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class ABP_AJBInGameCharacter_C*         CharacterBP                                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBDamageActor_C::GetCauserOwnerCharacterBP(class ABP_AJBInGameCharacter_C** CharacterBP)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBDamageActor_C", "GetCauserOwnerCharacterBP");

	Params::BP_AJBDamageActor_C_GetCauserOwnerCharacterBP Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterBP != nullptr)
		*CharacterBP = Parms.CharacterBP;
}

}

