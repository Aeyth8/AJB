#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBBattleGameState

#include "Basic.hpp"

#include "CoreUObject_structs.hpp"
#include "Engine_structs.hpp"
#include "AJB_structs.hpp"
#include "AJB_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_AJBBattleGameState.BP_AJBBattleGameState_C
// 0x0130 (0x04C0 - 0x0390)
class ABP_AJBBattleGameState_C final : public AAJBBattleGameState
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x0390(0x0008)(Transient, DuplicateTransient)
	class UBP_AJBInGameLastSurvivorSceneDirector_C* BP_AJBInGameLastSurvivorSceneDirector;             // 0x0398(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AJBActionLogSender_GameState_C*     BP_AJBActionLogSender_GameState;                   // 0x03A0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AJBTutorialTriggerSender_GameState_C* BP_AJBTutorialTriggerSender_GameState;             // 0x03A8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AJBInGameSpeedTreeWindBlower_C*     BP_AJBInGameSpeedTreeWindBlower;                   // 0x03B0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AJBDamageAreaLocal_C*               BP_AJBDamageAreaLocal;                             // 0x03B8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class UBP_AJBDamageAreaContext_C*             BP_AJBDamageAreaContext;                           // 0x03C0(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	class USceneComponent*                        DefaultSceneRoot;                                  // 0x03C8(0x0008)(BlueprintVisible, ZeroConstructor, InstancedReference, IsPlainOldData, NonTransactional, NoDestructor, HasGetValueTypeHash)
	struct FDateTime                              BattleStartGameTime;                               // 0x03D0(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FDateTime                              StartPauseTime;                                    // 0x03D8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          bEnablePause;                                      // 0x03E0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_3E1[0x3];                                      // 0x03E1(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         InitialPlayerLivingCount;                          // 0x03E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         LivingPlayerCount;                                 // 0x03E8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_3EC[0x4];                                      // 0x03EC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	TArray<struct FTimespan>                      StockLossTime;                                     // 0x03F0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance)
	struct FDateTime                              CurrentTimeOnTimeStop;                             // 0x0400(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	UMulticastDelegateProperty_                   OnChangeLivingPlayerCount;                         // 0x0408(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	float                                         Rep_TheWorldRemainingTime;                         // 0x0418(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_41C[0x4];                                      // 0x041C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              BattleStartGameTime_FromBeforeCountDown;           // 0x0420(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	UMulticastDelegateProperty_                   OnFinishedGameDispatcher;                          // 0x0428(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	UMulticastDelegateProperty_                   OnStartGameDispatcher;                             // 0x0438(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bFinishedBattleGame;                               // 0x0448(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bStartBattleGame;                                  // 0x0449(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	bool                                          bFirstBloodHasFlowed;                              // 0x044A(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_44B[0x5];                                      // 0x044B(0x0005)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_AJBInGameTimeRecorder_C*            InGameTimeRecorder;                                // 0x0450(0x0008)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         LivingPlayerCountWithoutCPU_Server_;               // 0x0458(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_45C[0x4];                                      // 0x045C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              BeforeTickDateTime;                                // 0x0460(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	struct FTimespan                              RealDeltaTimeSpan;                                 // 0x0468(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	float                                         RealDeltaTime;                                     // 0x0470(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	int32                                         LivingPairCount;                                   // 0x0474(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	UMulticastDelegateProperty_                   OnSetLivingPlayerCountForHighlight;                // 0x0478(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         LivingPlayerCountToMakeAllCharacterAlwaysRelevant; // 0x0488(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_48C[0x4];                                      // 0x048C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnStartLastSurvivorScene_Server;                   // 0x0490(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	float                                         Rep_LossTimeFloat_Sec_;                            // 0x04A0(0x0004)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bLastSurvivorIsDetermined;                         // 0x04A4(0x0001)(Edit, BlueprintVisible, Net, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, RepNotify, NoDestructor)
	uint8                                         Pad_4A5[0x3];                                      // 0x04A5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	struct FTimespan                              BattleLimitTime;                                   // 0x04A8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)
	bool                                          bDisableTimeLimit_Debug_;                          // 0x04B0(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_4B1[0x7];                                      // 0x04B1(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	struct FDateTime                              AfterOpenTheGameTime;                              // 0x04B8(0x0008)(Edit, BlueprintVisible, DisableEditOnInstance, NoDestructor, HasGetValueTypeHash)

public:
	void OnChangeLivingPlayerCount__DelegateSignature(int32 Count, float LivingPlayerRate, int32 PairCount);
	void OnFinishedGameDispatcher__DelegateSignature();
	void OnStartGameDispatcher__DelegateSignature();
	void OnSetLivingPlayerCountForHighlight__DelegateSignature(int32 LivingPlayerCount_0, int32 LivingPairCount_0);
	void OnStartLastSurvivorScene_Server__DelegateSignature();
	void ExecuteUbergraph_BP_AJBBattleGameState(int32 EntryPoint);
	void BattleStart_Local();
	void OnFinishedBattleGame_Core();
	void OnFinishedBattleGame_OnServer();
	void StartLastSurvivorScene_Server_(class ABP_AJBInGameCharacter_C* LastSurvivorMainCharacter, class ABP_AJBInGameCharacter_C* LastSurvivorPairCharacter, class ABP_AJBInGameCharacter_C* LastDefeatedCharacter, class AActor* LastDamageCauser);
	void MakeActiveCharactersAlwaysRelevant_Svr_();
	void MC_StartLastSurvivorScene(class ABP_AJBInGameCharacter_C* LastSurvivorMainCharacter, int32 LastSurvivorMainMatchingPlayerIndex, class ABP_AJBInGameCharacter_C* LastSurvivorPairCharacter, class ABP_AJBInGameCharacter_C* LastDefeatedCharacter, int32 LastDefeatedMatchingPlayerIndex, bool bShouldPayAttentionTo2ndOnCut1);
	void MC_SetLivingPlayerCount(int32 PlayerCount, int32 PairCount);
	void OnBattleStart_Server();
	void MC_OnFinishedBattleGame();
	void UpdateTheWorldRemainingTime(float RemainingTime);
	void ReceiveBeginPlay();
	void UpdateLivingPlayerCount_Svr_();
	void SetLivingPlayerCount_Svr_(int32 LivingPlayerCount_0, int32 LivingPlayerCountWithoutCPU);
	void ReceiveTick(float DeltaSeconds);
	void OnEntryPlayer(class ABP_AJBInGamePlayerController_C* PlayerController);
	void MC_OnBattleGameStart(const struct FDateTime& BattleStartGameTime_0);
	void NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty);
	void UserConstructionScript();
	struct FTimespan GetElapsedGameTimespan();
	struct FDateTime GetBattleStartGameTime();
	void GetLivingPlayerCount(int32* Count);
	void UpdateCurrentTime();
	void GetTheWorldRemainingTime(float* RemainingTime);
	struct FDateTime GetCurrentGameTime();
	struct FTimespan GetElapsedGameTimespan_FromBeforeCountDown();
	void UpdateInitialPlayerLivingCount();
	void GetInitialPlayerLivingCount(bool* bSuccess, int32* InitialPlayerLivingCount_0);
	void IsFinishedBattleGame(bool* bFinished);
	void JudgeFirstBlood(bool* IsFirstBlood);
	struct FTimespan GetElapsedInGameTimespan();
	bool Private_IsPlayingReplay();
	void IsStartBattleGame(bool* bStart);
	void GetLivingPlayerCountWithoutCPU_Server_(int32* Count);
	void UpdateLossTimeBySlomo();
	void UpdateRealDeltaTime();
	void CallChangeLivingPlayerCountEvent();
	void GetLivingPairCount(int32* Count);
	float GetLivingRate();
	void CallChangeLivingPlayerCount(int32 LivingPlayerCount_0, int32 LivingPairCount_0);
	void InterruptLastSurvivorScene();
	void OnRep_bLastSurvivorIsDetermined();
	bool DoesCharacterHavePlayerController(class AAJBInGameCharacterBase* CharacterBase);
	struct FTimespan GetRemainingLimitTimespan_FromAfterOpenTheGame();
	struct FTimespan GetElapsedGameTimespanWithoutTheWorld();

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_AJBBattleGameState_C">();
	}
	static class ABP_AJBBattleGameState_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<ABP_AJBBattleGameState_C>();
	}
};
static_assert(alignof(ABP_AJBBattleGameState_C) == 0x000008, "Wrong alignment on ABP_AJBBattleGameState_C");
static_assert(sizeof(ABP_AJBBattleGameState_C) == 0x0004C0, "Wrong size on ABP_AJBBattleGameState_C");
static_assert(offsetof(ABP_AJBBattleGameState_C, UberGraphFrame) == 0x000390, "Member 'ABP_AJBBattleGameState_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BP_AJBInGameLastSurvivorSceneDirector) == 0x000398, "Member 'ABP_AJBBattleGameState_C::BP_AJBInGameLastSurvivorSceneDirector' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BP_AJBActionLogSender_GameState) == 0x0003A0, "Member 'ABP_AJBBattleGameState_C::BP_AJBActionLogSender_GameState' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BP_AJBTutorialTriggerSender_GameState) == 0x0003A8, "Member 'ABP_AJBBattleGameState_C::BP_AJBTutorialTriggerSender_GameState' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BP_AJBInGameSpeedTreeWindBlower) == 0x0003B0, "Member 'ABP_AJBBattleGameState_C::BP_AJBInGameSpeedTreeWindBlower' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BP_AJBDamageAreaLocal) == 0x0003B8, "Member 'ABP_AJBBattleGameState_C::BP_AJBDamageAreaLocal' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BP_AJBDamageAreaContext) == 0x0003C0, "Member 'ABP_AJBBattleGameState_C::BP_AJBDamageAreaContext' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, DefaultSceneRoot) == 0x0003C8, "Member 'ABP_AJBBattleGameState_C::DefaultSceneRoot' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BattleStartGameTime) == 0x0003D0, "Member 'ABP_AJBBattleGameState_C::BattleStartGameTime' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, StartPauseTime) == 0x0003D8, "Member 'ABP_AJBBattleGameState_C::StartPauseTime' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, bEnablePause) == 0x0003E0, "Member 'ABP_AJBBattleGameState_C::bEnablePause' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, InitialPlayerLivingCount) == 0x0003E4, "Member 'ABP_AJBBattleGameState_C::InitialPlayerLivingCount' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, LivingPlayerCount) == 0x0003E8, "Member 'ABP_AJBBattleGameState_C::LivingPlayerCount' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, StockLossTime) == 0x0003F0, "Member 'ABP_AJBBattleGameState_C::StockLossTime' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, CurrentTimeOnTimeStop) == 0x000400, "Member 'ABP_AJBBattleGameState_C::CurrentTimeOnTimeStop' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, OnChangeLivingPlayerCount) == 0x000408, "Member 'ABP_AJBBattleGameState_C::OnChangeLivingPlayerCount' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, Rep_TheWorldRemainingTime) == 0x000418, "Member 'ABP_AJBBattleGameState_C::Rep_TheWorldRemainingTime' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BattleStartGameTime_FromBeforeCountDown) == 0x000420, "Member 'ABP_AJBBattleGameState_C::BattleStartGameTime_FromBeforeCountDown' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, OnFinishedGameDispatcher) == 0x000428, "Member 'ABP_AJBBattleGameState_C::OnFinishedGameDispatcher' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, OnStartGameDispatcher) == 0x000438, "Member 'ABP_AJBBattleGameState_C::OnStartGameDispatcher' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, bFinishedBattleGame) == 0x000448, "Member 'ABP_AJBBattleGameState_C::bFinishedBattleGame' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, bStartBattleGame) == 0x000449, "Member 'ABP_AJBBattleGameState_C::bStartBattleGame' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, bFirstBloodHasFlowed) == 0x00044A, "Member 'ABP_AJBBattleGameState_C::bFirstBloodHasFlowed' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, InGameTimeRecorder) == 0x000450, "Member 'ABP_AJBBattleGameState_C::InGameTimeRecorder' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, LivingPlayerCountWithoutCPU_Server_) == 0x000458, "Member 'ABP_AJBBattleGameState_C::LivingPlayerCountWithoutCPU_Server_' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BeforeTickDateTime) == 0x000460, "Member 'ABP_AJBBattleGameState_C::BeforeTickDateTime' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, RealDeltaTimeSpan) == 0x000468, "Member 'ABP_AJBBattleGameState_C::RealDeltaTimeSpan' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, RealDeltaTime) == 0x000470, "Member 'ABP_AJBBattleGameState_C::RealDeltaTime' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, LivingPairCount) == 0x000474, "Member 'ABP_AJBBattleGameState_C::LivingPairCount' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, OnSetLivingPlayerCountForHighlight) == 0x000478, "Member 'ABP_AJBBattleGameState_C::OnSetLivingPlayerCountForHighlight' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, LivingPlayerCountToMakeAllCharacterAlwaysRelevant) == 0x000488, "Member 'ABP_AJBBattleGameState_C::LivingPlayerCountToMakeAllCharacterAlwaysRelevant' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, OnStartLastSurvivorScene_Server) == 0x000490, "Member 'ABP_AJBBattleGameState_C::OnStartLastSurvivorScene_Server' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, Rep_LossTimeFloat_Sec_) == 0x0004A0, "Member 'ABP_AJBBattleGameState_C::Rep_LossTimeFloat_Sec_' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, bLastSurvivorIsDetermined) == 0x0004A4, "Member 'ABP_AJBBattleGameState_C::bLastSurvivorIsDetermined' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, BattleLimitTime) == 0x0004A8, "Member 'ABP_AJBBattleGameState_C::BattleLimitTime' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, bDisableTimeLimit_Debug_) == 0x0004B0, "Member 'ABP_AJBBattleGameState_C::bDisableTimeLimit_Debug_' has a wrong offset!");
static_assert(offsetof(ABP_AJBBattleGameState_C, AfterOpenTheGameTime) == 0x0004B8, "Member 'ABP_AJBBattleGameState_C::AfterOpenTheGameTime' has a wrong offset!");

}

