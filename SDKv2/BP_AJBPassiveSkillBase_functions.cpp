#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBPassiveSkillBase

#include "Basic.hpp"

#include "BP_AJBPassiveSkillBase_classes.hpp"
#include "BP_AJBPassiveSkillBase_parameters.hpp"


namespace SDK
{

// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ExecuteUbergraph_BP_AJBPassiveSkillBase
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::ExecuteUbergraph_BP_AJBPassiveSkillBase(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ExecuteUbergraph_BP_AJBPassiveSkillBase");

	Params::BP_AJBPassiveSkillBase_C_ExecuteUbergraph_BP_AJBPassiveSkillBase Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ROS_ExtendActiveTime
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   AdditionalTime                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::ROS_ExtendActiveTime(float AdditionalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ROS_ExtendActiveTime");

	Params::BP_AJBPassiveSkillBase_C_ROS_ExtendActiveTime Parms{};

	Parms.AdditionalTime = AdditionalTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ExtendActiveTime_Local
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// float                                   AdditionalTime                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::ExtendActiveTime_Local(float AdditionalTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ExtendActiveTime_Local");

	Params::BP_AJBPassiveSkillBase_C_ExtendActiveTime_Local Parms{};

	Parms.AdditionalTime = AdditionalTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.MC_SetShouldUpdateLectActiveTime
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bShouldUpdateLeftActiveTime                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::MC_SetShouldUpdateLectActiveTime(bool bShouldUpdateLeftActiveTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "MC_SetShouldUpdateLectActiveTime");

	Params::BP_AJBPassiveSkillBase_C_MC_SetShouldUpdateLectActiveTime Parms{};

	Parms.bShouldUpdateLeftActiveTime = bShouldUpdateLeftActiveTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.PlayInactiveSE
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::PlayInactiveSE()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "PlayInactiveSE");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ReceiveEndPlay
// (Event, Public, BlueprintEvent)
// Parameters:
// EEndPlayReason                          EndPlayReason                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::ReceiveEndPlay(EEndPlayReason EndPlayReason)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ReceiveEndPlay");

	Params::BP_AJBPassiveSkillBase_C_ReceiveEndPlay Parms{};

	Parms.EndPlayReason = EndPlayReason;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ROS_SetShouldUpdateLeftActiveTime
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     FactorTag                                              (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    bShouldUpdateActiveTime                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::ROS_SetShouldUpdateLeftActiveTime(const struct FGameplayTag& FactorTag, bool bShouldUpdateActiveTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ROS_SetShouldUpdateLeftActiveTime");

	Params::BP_AJBPassiveSkillBase_C_ROS_SetShouldUpdateLeftActiveTime Parms{};

	Parms.FactorTag = std::move(FactorTag);
	Parms.bShouldUpdateActiveTime = bShouldUpdateActiveTime;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnContinuedParticleInactivated
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::OnContinuedParticleInactivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnContinuedParticleInactivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnContinuedParticleActivated
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::OnContinuedParticleActivated()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnContinuedParticleActivated");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.InactiveContinuedParticle
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::InactiveContinuedParticle()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "InactiveContinuedParticle");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ActiveContinuedParticle
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bActiveForOwner                                        (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bActiveForMovableStand                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::ActiveContinuedParticle(bool bActiveForOwner, bool bActiveForMovableStand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ActiveContinuedParticle");

	Params::BP_AJBPassiveSkillBase_C_ActiveContinuedParticle Parms{};

	Parms.bActiveForOwner = bActiveForOwner;
	Parms.bActiveForMovableStand = bActiveForMovableStand;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnMC_ActivePassive
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     CauserType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::OnMC_ActivePassive(class UObject* Causer, const struct FGameplayTag& CauserType, int32 SerialNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnMC_ActivePassive");

	Params::BP_AJBPassiveSkillBase_C_OnMC_ActivePassive Parms{};

	Parms.Causer = Causer;
	Parms.CauserType = std::move(CauserType);
	Parms.SerialNumber = SerialNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.MC_ActivePassive_
// (Net, NetReliable, NetMulticast, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// struct FGameplayTag                     CauserType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::MC_ActivePassive_(class UObject* Causer, const struct FGameplayTag& CauserType, int32 SerialNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "MC_ActivePassive_");

	Params::BP_AJBPassiveSkillBase_C_MC_ActivePassive_ Parms{};

	Parms.Causer = Causer;
	Parms.CauserType = std::move(CauserType);
	Parms.SerialNumber = SerialNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnPossessTargetChanged
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAJBInGameCharacterBase*          SeparateFrom                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// class AAJBInGameCharacterBase*          SeparateTo                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::OnPossessTargetChanged(class AAJBInGameCharacterBase* SeparateFrom, class AAJBInGameCharacterBase* SeparateTo)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnPossessTargetChanged");

	Params::BP_AJBPassiveSkillBase_C_OnPossessTargetChanged Parms{};

	Parms.SeparateFrom = SeparateFrom;
	Parms.SeparateTo = SeparateTo;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.UnboundCharacterPossessTiming
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::UnboundCharacterPossessTiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "UnboundCharacterPossessTiming");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.BindCharacterPossessTiming
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::BindCharacterPossessTiming()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "BindCharacterPossessTiming");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.StopSE
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::StopSE(class UObject* Causer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "StopSE");

	Params::BP_AJBPassiveSkillBase_C_StopSE Parms{};

	Parms.Causer = Causer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.PlaySE
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::PlaySE(class UObject* Causer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "PlaySE");

	Params::BP_AJBPassiveSkillBase_C_PlaySE Parms{};

	Parms.Causer = Causer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.UpdateLeftTime
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::UpdateLeftTime(class UObject* Causer)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "UpdateLeftTime");

	Params::BP_AJBPassiveSkillBase_C_UpdateLeftTime Parms{};

	Parms.Causer = Causer;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ActivePassive
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class UObject*                          Causer                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bTriggeredByStand                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// struct FGameplayTag                     CauserType                                             (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// int32                                   SerialNumber                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::ActivePassive(class UObject* Causer, bool bTriggeredByStand, const struct FGameplayTag& CauserType, int32 SerialNumber)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ActivePassive");

	Params::BP_AJBPassiveSkillBase_C_ActivePassive Parms{};

	Parms.Causer = Causer;
	Parms.bTriggeredByStand = bTriggeredByStand;
	Parms.CauserType = std::move(CauserType);
	Parms.SerialNumber = SerialNumber;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.NotifyChangeFXVisibility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FST_FXVisibilityInfo             PrevFXVisibility                                       (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)
// struct FST_FXVisibilityInfo             FXVisibility                                           (BlueprintVisible, BlueprintReadOnly, Parm, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::NotifyChangeFXVisibility(const struct FST_FXVisibilityInfo& PrevFXVisibility, const struct FST_FXVisibilityInfo& FXVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "NotifyChangeFXVisibility");

	Params::BP_AJBPassiveSkillBase_C_NotifyChangeFXVisibility Parms{};

	Parms.PrevFXVisibility = std::move(PrevFXVisibility);
	Parms.FXVisibility = std::move(FXVisibility);

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.InactiveWidget
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::InactiveWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "InactiveWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ActiveWidget
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::ActiveWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ActiveWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.TryRegisterPassiveWidget
// (BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::TryRegisterPassiveWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "TryRegisterPassiveWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ShouldUpdateLeftActiveTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bShould                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::ShouldUpdateLeftActiveTime(bool* bShould)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ShouldUpdateLeftActiveTime");

	Params::BP_AJBPassiveSkillBase_C_ShouldUpdateLeftActiveTime Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bShould != nullptr)
		*bShould = Parms.bShould;
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.GetCurrentPossessedCharacter
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// class AAJBInGameCharacterBase*          CharacterBase                                          (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::GetCurrentPossessedCharacter(class AAJBInGameCharacterBase** CharacterBase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "GetCurrentPossessedCharacter");

	Params::BP_AJBPassiveSkillBase_C_GetCurrentPossessedCharacter Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (CharacterBase != nullptr)
		*CharacterBase = Parms.CharacterBase;
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ChangeParticleVisibility
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bNewVisibility                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::ChangeParticleVisibility(bool bNewVisibility)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ChangeParticleVisibility");

	Params::BP_AJBPassiveSkillBase_C_ChangeParticleVisibility Parms{};

	Parms.bNewVisibility = bNewVisibility;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnRegisterPassiveWidget
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UWB_AJBPassiveSkillWidget_C*      NewPassiveWidget                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::OnRegisterPassiveWidget(class UWB_AJBPassiveSkillWidget_C* NewPassiveWidget)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnRegisterPassiveWidget");

	Params::BP_AJBPassiveSkillBase_C_OnRegisterPassiveWidget Parms{};

	Parms.NewPassiveWidget = NewPassiveWidget;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnUnregisterPassiveWidget
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::OnUnregisterPassiveWidget()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnUnregisterPassiveWidget");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.TryDestroyParticles
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::TryDestroyParticles()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "TryDestroyParticles");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnTimeup
// (Public, BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::OnTimeup()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnTimeup");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.GetParticleTag
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// struct FGameplayTag                     ParticleTag_0                                          (Parm, OutParm, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::GetParticleTag(struct FGameplayTag* ParticleTag_0)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "GetParticleTag");

	Params::BP_AJBPassiveSkillBase_C_GetParticleTag Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (ParticleTag_0 != nullptr)
		*ParticleTag_0 = std::move(Parms.ParticleTag_0);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.CheckShouldUpdateLeftActiveTime
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     NewFactorTag                                           (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// bool                                    NewParam                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bShouldUpdateLeftActiveTime                            (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::CheckShouldUpdateLeftActiveTime(const struct FGameplayTag& NewFactorTag, bool NewParam, bool* bShouldUpdateLeftActiveTime)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "CheckShouldUpdateLeftActiveTime");

	Params::BP_AJBPassiveSkillBase_C_CheckShouldUpdateLeftActiveTime Parms{};

	Parms.NewFactorTag = std::move(NewFactorTag);
	Parms.NewParam = NewParam;

	UObject::ProcessEvent(Func, &Parms);

	if (bShouldUpdateLeftActiveTime != nullptr)
		*bShouldUpdateLeftActiveTime = Parms.bShouldUpdateLeftActiveTime;
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.DebugPrintShouldUpdateMap
// (Public, HasDefaults, BlueprintCallable, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::DebugPrintShouldUpdateMap()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "DebugPrintShouldUpdateMap");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.GetCurrentPhase
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// int32                                   Phase                                                  (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::GetCurrentPhase(int32* Phase)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "GetCurrentPhase");

	Params::BP_AJBPassiveSkillBase_C_GetCurrentPhase Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (Phase != nullptr)
		*Phase = Parms.Phase;
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ReceiveBeginPlay
// (Event, Public, BlueprintEvent)

void UBP_AJBPassiveSkillBase_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.ReceiveTick
// (Event, Public, BlueprintEvent)
// Parameters:
// float                                   DeltaSeconds                                           (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void UBP_AJBPassiveSkillBase_C::ReceiveTick(float DeltaSeconds)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "ReceiveTick");

	Params::BP_AJBPassiveSkillBase_C_ReceiveTick Parms{};

	Parms.DeltaSeconds = DeltaSeconds;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnActionInactivate
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bTriggeredByStand                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::OnActionInactivate(bool bTriggeredByStand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnActionInactivate");

	Params::BP_AJBPassiveSkillBase_C_OnActionInactivate Parms{};

	Parms.bTriggeredByStand = bTriggeredByStand;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.OnActionActivate
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// bool                                    bTriggeredByStand                                      (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::OnActionActivate(bool bTriggeredByStand)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "OnActionActivate");

	Params::BP_AJBPassiveSkillBase_C_OnActionActivate Parms{};

	Parms.bTriggeredByStand = bTriggeredByStand;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBPassiveSkillBase.BP_AJBPassiveSkillBase_C.NotifyTheWorld
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAJBInGameCharacter*              Operator                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGeneralTiming                          Timing                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bOperatorIsEmpty                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void UBP_AJBPassiveSkillBase_C::NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBPassiveSkillBase_C", "NotifyTheWorld");

	Params::BP_AJBPassiveSkillBase_C_NotifyTheWorld Parms{};

	Parms.Operator = Operator;
	Parms.Time = Time;
	Parms.Timing = Timing;
	Parms.bEnable = bEnable;
	Parms.bOperatorIsEmpty = bOperatorIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}

}

