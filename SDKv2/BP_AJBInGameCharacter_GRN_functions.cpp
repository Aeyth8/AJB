#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBInGameCharacter_GRN

#include "Basic.hpp"

#include "BP_AJBInGameCharacter_GRN_classes.hpp"
#include "BP_AJBInGameCharacter_GRN_parameters.hpp"


namespace SDK
{

// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.ExecuteUbergraph_BP_AJBInGameCharacter_GRN
// (HasDefaults)
// Parameters:
// int32                                   EntryPoint                                             (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameCharacter_GRN_C::ExecuteUbergraph_BP_AJBInGameCharacter_GRN(int32 EntryPoint)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "ExecuteUbergraph_BP_AJBInGameCharacter_GRN");

	Params::BP_AJBInGameCharacter_GRN_C_ExecuteUbergraph_BP_AJBInGameCharacter_GRN Parms{};

	Parms.EntryPoint = EntryPoint;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.NotifyTheWorldOnEventGraph
// (BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAJBInGameCharacter*              Operator                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGeneralTiming                          Timing                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bOperatorIsEmpty                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::NotifyTheWorldOnEventGraph(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "NotifyTheWorldOnEventGraph");

	Params::BP_AJBInGameCharacter_GRN_C_NotifyTheWorldOnEventGraph Parms{};

	Parms.Operator = Operator;
	Parms.Time = Time;
	Parms.Timing = Timing;
	Parms.bEnable = bEnable;
	Parms.bOperatorIsEmpty = bOperatorIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.ROS_AddGameplayTag_InvincibleGEXRequiem
// (Net, NetReliable, NetServer, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::ROS_AddGameplayTag_InvincibleGEXRequiem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "ROS_AddGameplayTag_InvincibleGEXRequiem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.AddGameplayTag_InvincibleGEXRequiem
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::AddGameplayTag_InvincibleGEXRequiem()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "AddGameplayTag_InvincibleGEXRequiem");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.InactiveContinuedAccompany
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::InactiveContinuedAccompany()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "InactiveContinuedAccompany");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.ActiveContinuedAccompany
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::ActiveContinuedAccompany()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "ActiveContinuedAccompany");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.OnBlocking
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FVector                          BlockingLocation                                       (BlueprintVisible, BlueprintReadOnly, Parm, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    Reflect                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bIsPairAttack                                          (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bImpulseDamage                                         (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// class AActor*                           DamageOwner                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bSeparateStandAttack                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::OnBlocking(const struct FVector& BlockingLocation, bool Reflect, bool bIsPairAttack, bool bImpulseDamage, class AActor* DamageOwner, bool bSeparateStandAttack)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "OnBlocking");

	Params::BP_AJBInGameCharacter_GRN_C_OnBlocking Parms{};

	Parms.BlockingLocation = std::move(BlockingLocation);
	Parms.Reflect = Reflect;
	Parms.bIsPairAttack = bIsPairAttack;
	Parms.bImpulseDamage = bImpulseDamage;
	Parms.DamageOwner = DamageOwner;
	Parms.bSeparateStandAttack = bSeparateStandAttack;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.CheckBlockingValid
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           DamageActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockingValid                                         (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::CheckBlockingValid(class AActor* DamageActor, bool* bBlockingValid)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "CheckBlockingValid");

	Params::BP_AJBInGameCharacter_GRN_C_CheckBlockingValid Parms{};

	Parms.DamageActor = DamageActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bBlockingValid != nullptr)
		*bBlockingValid = Parms.bBlockingValid;
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.CheckBlockingComponent
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlockingComponent                                     (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::CheckBlockingComponent(class UPrimitiveComponent* Component, bool* bBlockingComponent)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "CheckBlockingComponent");

	Params::BP_AJBInGameCharacter_GRN_C_CheckBlockingComponent Parms{};

	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);

	if (bBlockingComponent != nullptr)
		*bBlockingComponent = Parms.bBlockingComponent;
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.IgnoreGivePassive
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UPrimitiveComponent*              Component                                              (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bIgnore                                                (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::IgnoreGivePassive(class UPrimitiveComponent* Component, bool* bIgnore)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "IgnoreGivePassive");

	Params::BP_AJBInGameCharacter_GRN_C_IgnoreGivePassive Parms{};

	Parms.Component = Component;

	UObject::ProcessEvent(Func, &Parms);

	if (bIgnore != nullptr)
		*bIgnore = Parms.bIgnore;
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.BlockPenetrate
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AActor*                           CauserActor                                            (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bBlock                                                 (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::BlockPenetrate(class AActor* CauserActor, bool* bBlock)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "BlockPenetrate");

	Params::BP_AJBInGameCharacter_GRN_C_BlockPenetrate Parms{};

	Parms.CauserActor = CauserActor;

	UObject::ProcessEvent(Func, &Parms);

	if (bBlock != nullptr)
		*bBlock = Parms.bBlock;
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.ReceiveBeginPlay
// (Event, Protected, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::ReceiveBeginPlay()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "ReceiveBeginPlay");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.PressedButton_ActiveBase
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::PressedButton_ActiveBase()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "PressedButton_ActiveBase");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.PressedButton_Ultimate
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::PressedButton_Ultimate()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "PressedButton_Ultimate");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.ReleasedButton_ActiveSpecial
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::ReleasedButton_ActiveSpecial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "ReleasedButton_ActiveSpecial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.PressedButton_ActiveSpecial
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::PressedButton_ActiveSpecial()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "PressedButton_ActiveSpecial");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.ReleasedButton_Basic
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::ReleasedButton_Basic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "ReleasedButton_Basic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.PressedButton_Basic
// (BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::PressedButton_Basic()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "PressedButton_Basic");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.NotifyTheWorld
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class AAJBInGameCharacter*              Operator                                               (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// float                                   Time                                                   (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// EGeneralTiming                          Timing                                                 (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
// bool                                    bEnable                                                (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)
// bool                                    bOperatorIsEmpty                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::NotifyTheWorld(class AAJBInGameCharacter* Operator, float Time, EGeneralTiming Timing, bool bEnable, bool bOperatorIsEmpty)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "NotifyTheWorld");

	Params::BP_AJBInGameCharacter_GRN_C_NotifyTheWorld Parms{};

	Parms.Operator = Operator;
	Parms.Time = Time;
	Parms.Timing = Timing;
	Parms.bEnable = bEnable;
	Parms.bOperatorIsEmpty = bOperatorIsEmpty;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.UserConstructionScript
// (Event, Public, BlueprintCallable, BlueprintEvent)

void ABP_AJBInGameCharacter_GRN_C::UserConstructionScript()
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "UserConstructionScript");

	UObject::ProcessEvent(Func, nullptr);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.ConsumeGrowup
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTag                     Growup                                                 (BlueprintVisible, BlueprintReadOnly, Parm, NoDestructor, HasGetValueTypeHash)
// float                                   Value                                                  (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameCharacter_GRN_C::ConsumeGrowup(const struct FGameplayTag& Growup, float Value)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "ConsumeGrowup");

	Params::BP_AJBInGameCharacter_GRN_C_ConsumeGrowup Parms{};

	Parms.Growup = std::move(Growup);
	Parms.Value = Value;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.SkillInactivated
// (Public, BlueprintCallable, BlueprintEvent)
// Parameters:
// class UBP_AJBSkillBase_C*               InactivatedSkill                                       (BlueprintVisible, BlueprintReadOnly, Parm, ZeroConstructor, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)

void ABP_AJBInGameCharacter_GRN_C::SkillInactivated(class UBP_AJBSkillBase_C* InactivatedSkill)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "SkillInactivated");

	Params::BP_AJBInGameCharacter_GRN_C_SkillInactivated Parms{};

	Parms.InactivatedSkill = InactivatedSkill;

	UObject::ProcessEvent(Func, &Parms);
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.CanEmote
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent)
// Parameters:
// struct FGameplayTagContainer            FailureFactor                                          (Parm, OutParm)
// struct FGameplayTagContainer            FailureSkills                                          (Parm, OutParm)
// bool                                    bCanEmote                                              (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::CanEmote(struct FGameplayTagContainer* FailureFactor, struct FGameplayTagContainer* FailureSkills, bool* bCanEmote)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "CanEmote");

	Params::BP_AJBInGameCharacter_GRN_C_CanEmote Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (FailureFactor != nullptr)
		*FailureFactor = std::move(Parms.FailureFactor);

	if (FailureSkills != nullptr)
		*FailureSkills = std::move(Parms.FailureSkills);

	if (bCanEmote != nullptr)
		*bCanEmote = Parms.bCanEmote;
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.CheckAnySkillActiveOnTiltOneDash
// (Public, HasOutParams, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bAnySkillActive                                        (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::CheckAnySkillActiveOnTiltOneDash(bool* bAnySkillActive)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "CheckAnySkillActiveOnTiltOneDash");

	Params::BP_AJBInGameCharacter_GRN_C_CheckAnySkillActiveOnTiltOneDash Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bAnySkillActive != nullptr)
		*bAnySkillActive = Parms.bAnySkillActive;
}


// Function BP_AJBInGameCharacter_GRN.BP_AJBInGameCharacter_GRN_C.CheckSidlingOnTiltOnce
// (Public, HasOutParams, HasDefaults, BlueprintCallable, BlueprintEvent, BlueprintPure)
// Parameters:
// bool                                    bSidling                                               (Parm, OutParm, ZeroConstructor, IsPlainOldData, NoDestructor)

void ABP_AJBInGameCharacter_GRN_C::CheckSidlingOnTiltOnce(bool* bSidling)
{
	static class UFunction* Func = nullptr;

	if (Func == nullptr)
		Func = Class->GetFunction("BP_AJBInGameCharacter_GRN_C", "CheckSidlingOnTiltOnce");

	Params::BP_AJBInGameCharacter_GRN_C_CheckSidlingOnTiltOnce Parms{};

	UObject::ProcessEvent(Func, &Parms);

	if (bSidling != nullptr)
		*bSidling = Parms.bSidling;
}

}

