#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BP_AJBInGameAIRecognition

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "AJB_structs.hpp"
#include "AJB_classes.hpp"


namespace SDK
{

// BlueprintGeneratedClass BP_AJBInGameAIRecognition.BP_AJBInGameAIRecognition_C
// 0x0250 (0x0340 - 0x00F0)
class UBP_AJBInGameAIRecognition_C final : public UAJBInGameAIRecognitionComponent
{
public:
	struct FPointerToUberGraphFrame               UberGraphFrame;                                    // 0x00F0(0x0008)(Transient, DuplicateTransient)
	class ABP_AJBInGameCharacter_C*               ControlledCharacter;                               // 0x00F8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class AAJBInGameAIController*                 MyAIController;                                    // 0x0100(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_AJBInGameAIImaginaryCharacter_C*    ImaginaryCharacterSelf;                            // 0x0108(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SmallSafeAreaRadiusParam;                          // 0x0110(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bIsInitialized;                                    // 0x0114(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_115[0x3];                                      // 0x0115(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   OnDead;                                            // 0x0118(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	float                                         LessMPThreshold;                                   // 0x0128(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_12C[0x4];                                      // 0x012C(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_AJBInGameAIImaginaryCharacter_C*    ImaginaryCharacterSelfStand;                       // 0x0130(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class ABP_AJBInGameAIImaginaryCharacter_C*    ImaginaryCharacterPair;                            // 0x0138(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bBeingDamaged;                                     // 0x0140(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_141[0x7];                                      // 0x0141(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	class ABP_AJBInGameCharacter_C*               LatestDamagingEnemy;                               // 0x0148(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	class UBP_AJBInGameAIEnvironment_C*           AIEnvironmentRef;                                  // 0x0150(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TArray<class ABP_AJBAIGionSource_C*>          AttackingGionsInRange;                             // 0x0158(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance)
	TArray<class ABP_AJBAIGionSource_C*>          MovingGionsInRange;                                // 0x0168(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance)
	TMap<class FName, float>                      FloatParams;                                       // 0x0178(0x0050)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance)
	class UBP_AJBDamageAreaLocal_C*               DamageAreaLocalRef;                                // 0x01C8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, InstancedReference, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	TMap<class ABP_AJBInGameAIImaginaryCharacter_C*, class ABP_AJBInGameAIObservedCharacter_C*> ObservedCharacters;                                // 0x01D0(0x0050)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance)
	TMap<class ABP_AJBInGameAIImaginaryCharacter_C*, class ABP_AJBInGameAIObservedCharacter_C*> CharactersInSight;                                 // 0x0220(0x0050)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance)
	class AEventTagLockHolder*                    EventTagLockHolder;                                // 0x0270(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	UMulticastDelegateProperty_                   ContextPushed;                                     // 0x0278(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	UMulticastDelegateProperty_                   ErrorContextPushed;                                // 0x0288(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	float                                         ObservableDistanceParam;                           // 0x0298(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DistanceThresholdToPlayerForFindingEnemyParam;     // 0x029C(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         ProbabilityToFindEnemyIfNoPlayersAroundParam;      // 0x02A0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         DistanceFromNearestLivingPlayer;                   // 0x02A4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         InitialDistanceFromNearestLivingPlayer;            // 0x02A8(0x0004)(Edit, BlueprintVisible, BlueprintReadOnly, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2AC[0x4];                                      // 0x02AC(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   InteractActorChanged;                              // 0x02B0(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	int32                                         TimeSecondsToWarnStartSafeAreaReductionParam;      // 0x02C0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	bool                                          bAILevelSetupFinished;                             // 0x02C4(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2C5[0x3];                                      // 0x02C5(0x0003)(Fixing Size After Last Property [ Dumper-7 ])
	int32                                         AILevel;                                           // 0x02C8(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         AdditionalDistanceFromNPCParam;                    // 0x02CC(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         SafeAreaRadiusMinParam;                            // 0x02D0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	uint8                                         Pad_2D4[0x4];                                      // 0x02D4(0x0004)(Fixing Size After Last Property [ Dumper-7 ])
	class AEventTagLocker*                        TheWorldEventTagLocker;                            // 0x02D8(0x0008)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnTemplate, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CameraLookUpDegreeToInputScale;                    // 0x02E0(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	float                                         CameraTurnDegreeToInputScale;                      // 0x02E4(0x0004)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor, HasGetValueTypeHash)
	UMulticastDelegateProperty_                   OnDamaged;                                         // 0x02E8(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	bool                                          bDamageAreaAvailableCache;                         // 0x02F8(0x0001)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, IsPlainOldData, NoDestructor)
	uint8                                         Pad_2F9[0x7];                                      // 0x02F9(0x0007)(Fixing Size After Last Property [ Dumper-7 ])
	UMulticastDelegateProperty_                   EventTagLocked;                                    // 0x0300(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	UMulticastDelegateProperty_                   EventTagUnlocked;                                  // 0x0310(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	UMulticastDelegateProperty_                   DebugEventReplayPushed;                            // 0x0320(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)
	UMulticastDelegateProperty_                   DebugEventReplayPathPushed;                        // 0x0330(0x0010)(Edit, BlueprintVisible, ZeroConstructor, DisableEditOnInstance, BlueprintAssignable, BlueprintCallable)

public:
	void OnDead__DelegateSignature(class AAIController* AIController, const struct FGameplayTag& DamageType);
	void ContextPushed__DelegateSignature(const struct FGameplayTag& Tag);
	void ErrorContextPushed__DelegateSignature(const struct FGameplayTag& Tag);
	void InteractActorChanged__DelegateSignature(class AActor* InteractActor);
	void OnDamaged__DelegateSignature(const struct FGameplayTag& DamageType, class AActor* DamageCauser);
	void EventTagLocked__DelegateSignature(const struct FGameplayTag& EventTag);
	void EventTagUnlocked__DelegateSignature(const struct FGameplayTag& EventTag);
	void DebugEventReplayPushed__DelegateSignature(const struct FGameplayTag& Tag, const struct FVector& V1, const struct FVector& V2);
	void DebugEventReplayPathPushed__DelegateSignature(const struct FGameplayTag& Tag, class UNavigationPath* NavigationPath);
	void ExecuteUbergraph_BP_AJBInGameAIRecognition(int32 EntryPoint);
	void DebugPushEventReplayPath(const struct FGameplayTag& Tag, class UNavigationPath* NavigationPath);
	void DebugPushEventReplay(const struct FGameplayTag& Tag, const struct FVector& V1, const struct FVector& V2);
	void OnEventTagUnlocked(const struct FGameplayTag& EventTag);
	void OnEventTagLocked(const struct FGameplayTag& EventTag);
	void OnCharacterDamaged(int32 Damage, const struct FGameplayTag& DamageType, class AActor* DamageCauser, bool bRemainHP, bool bDamageIsCutByStatus, bool bDamageIsCutByAAP);
	void OnTheWorldEnd();
	void OnTheWorldBegin();
	void OnChangeInteractActor(class ABP_AJBInGameCharacter_C* OperatorCharacter, class AActor* InteractActor);
	void UpdateDistanceFromNearestLivingPlayer();
	void PushErrorContextTag(const struct FGameplayTag& Tag);
	void PushContextTag(const struct FGameplayTag& Tag);
	void SetupPair(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryCharacterPair_0);
	void SetupAILevel(int32 AI_Level);
	void UpdateMovingGionsInRange();
	void UpdateAttackingGionsInRange();
	void OnCharacterDead(const struct FGameplayTag& DamageType, class AActor* DeadActor, class AActor* DamageCauser);
	void RemoveFromObservation(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryCharacter);
	void UpdateObservedCharacters();
	void OnPerceptionUpdated(class UAIPerceptionComponent* AIPerception, const TArray<class AActor*>& UpdatedActors);
	void ReceiveTick(float DeltaSeconds);
	void ReceiveBeginPlay();
	bool IsReachableActor(class AActor* Actor, class UNavigationPath** NavigationPath);
	bool IsTargetableCharacter(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryCharacter, float TargetingRangeBuffer);
	bool IfCharacterAssumeToBeCounteredBy(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryCharacter);
	class ABP_AJBInGameAIObservedCharacter_C* FindObservedCharacterBody(class APawn* Character, bool* Found);
	class ABP_AJBInGameAIObservedCharacter_C* FindOrCreateObservedCharacterBody(class APawn* Pawn);
	class ABP_AJBInGameAIImaginaryCharacter_C* NearestEnemy();
	bool CanInvokeSkill(const struct FGameplayTag& SkillTag);
	bool IsFullMP(float FullRatio);
	bool IsLessMP();
	bool IfCharacterInSight(const class ABP_AJBInGameAIImaginaryCharacter_C*& ImaginaryCharacter);
	class UBP_AJBInGameAIEnvironment_C* GetEnvironment();
	class UAJBAIEnvironmentBlock* GetEnvironmentBlockSelf();
	void GetSaferArea(struct FVector* Location, float* Radius);
	bool InSaferArea(const struct FVector& Location);
	bool InSaferAreaSelf();
	bool IfAttemptToGoOutFromSaferArea(const struct FVector& Destination);
	bool IsSafeAreaSmall();
	class UAJBAIEnvironmentBlock* GetEnvironmentBlock(const struct FVector& LocationInBlock);
	struct FVector GetVectorFromSelfToSaferAreaCenter();
	struct FVector GetDirectionFromSelfToSaferAreaCenter();
	bool InSafeAreaSelf(float RadiusBuffer);
	void GetSafeArea(float RadiusBuffer, struct FVector* Location, float* Radius);
	bool InSafeArea(const struct FVector& Location, float RadiusBuffer);
	bool IsComponentInitialized();
	bool IsSafeAreaProceedingReduction();
	bool IsOutOfNavMesh();
	TArray<class UAJBAIEnvironmentBlock*> GetEnvironmentBlockWithBlocksAroundSelf(bool bExceptCenterBlock, float CullingRadiusRatioByBlockUnitSize);
	TArray<struct FVector> GetWaySpotsAround(float CullingRadius);
	void GetIndoorVolumes(TArray<class UPrimitiveComponent*>* OverlapVolume);
	class AActor* GetIndoorHouse();
	class FString DebugCharacterInputStatusText();
	float GetFloatParam(class FName Name_0, bool* Found);
	void GetObservedCharacters(TArray<class ABP_AJBInGameAIObservedCharacter_C*>* Values);
	bool IsObservableCharacter(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryCharacter);
	class ABP_AJBInGameAIImaginaryCharacter_C* GetImaginaryCharacterFromPawn(class APawn* Pawn, bool* Found);
	bool IsPawnNPC(class APawn* Pawn);
	class ABP_AJBInGameAIObservedCharacter_C* FindOrCreateObservedCharacterStand(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryStand);
	float ApproachableDiffZToInteractableActor();
	TArray<class UAJBAIEnvironmentBlock*> GetEnvironmentBlockWithBlocksAround(const struct FVector& BaseLocation, bool bExceptCenterBlock, bool bUseCullingFromSelf, float CullingRadiusRatioByBlockUnitSize);
	void GetTargetSafeArea(struct FVector* Location, float* Radius);
	bool HasPair();
	class ABP_AJBInGameAIImaginaryCharacter_C* GetControllingImaginaryCharacter();
	class ABP_AJBInGameAIImaginaryCharacter_C* GetImaginaryCharacterBody();
	class ABP_AJBInGameAIImaginaryCharacter_C* GetImaginaryCharacterMovableStand();
	bool IsEventTagLocked(const struct FGameplayTag& EventTag, bool bExactMatch);
	bool HasInteractActor();
	struct FVector GetNearestHouseEntrance(class AActor* HouseActor, class AActor** GateActor, bool* Succeeded);
	int32 GetObservedCharactersCount();
	TArray<class ABP_AJBInGameItem_SP_C*> GetItemSPs();
	void GetHP(int32* Rep_HP);
	void GetHPMax(int32* Rep_HP);
	int32 GetLivingPlayerCount();
	class ABP_AJBInGameAIImaginaryCharacter_C* GetNearestPlayerCharacter(float* DistanceXY);
	class AActor* GetInteractActor();
	bool IsSafeAreaAlmostProceedingReduction();
	bool IsAILevelSetupFinished();
	int32 GetAILevel();
	bool IsUltimateSkillTarget(class ABP_AJBInGameAIImaginaryCharacter_C* ImaginaryEnemy);
	bool HasHealingPairSkill();
	float GetCameraLookUpDegreeToInputScale();
	float GetCameraTurnDegreeToInputScale();
	class ABP_AJBAIHouseInfo_C* FindIndoorHouseInfo();
	bool IsFullHP();
	bool IsDamageAreaAvailable();
	bool IsBeingDamagedFromPlayer();
	bool IsBeingDamaged();
	class AEventTagLocker* SpawnEventTagLocker();
	struct FGameplayTagContainer GetLockedEventTags();
	class AActor* GetContextActor();
	bool IsEnvEventTagLocked(const struct FGameplayTag& EventTag, bool bExactMatch);
	bool IsEnvOrLocalEventTagLocked(const struct FGameplayTag& EventTag, bool bExactMatch);
	float ExpectedJumpHeight();
	int32 IndoorHouseInfoAroundCount(bool bExceptCenterBlock, bool bUseCullingFromSelf, float CullingRadiusRatioByBlockUnitSize);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BP_AJBInGameAIRecognition_C">();
	}
	static class UBP_AJBInGameAIRecognition_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBP_AJBInGameAIRecognition_C>();
	}
};
static_assert(alignof(UBP_AJBInGameAIRecognition_C) == 0x000008, "Wrong alignment on UBP_AJBInGameAIRecognition_C");
static_assert(sizeof(UBP_AJBInGameAIRecognition_C) == 0x000340, "Wrong size on UBP_AJBInGameAIRecognition_C");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, UberGraphFrame) == 0x0000F0, "Member 'UBP_AJBInGameAIRecognition_C::UberGraphFrame' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ControlledCharacter) == 0x0000F8, "Member 'UBP_AJBInGameAIRecognition_C::ControlledCharacter' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, MyAIController) == 0x000100, "Member 'UBP_AJBInGameAIRecognition_C::MyAIController' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ImaginaryCharacterSelf) == 0x000108, "Member 'UBP_AJBInGameAIRecognition_C::ImaginaryCharacterSelf' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, SmallSafeAreaRadiusParam) == 0x000110, "Member 'UBP_AJBInGameAIRecognition_C::SmallSafeAreaRadiusParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, bIsInitialized) == 0x000114, "Member 'UBP_AJBInGameAIRecognition_C::bIsInitialized' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, OnDead) == 0x000118, "Member 'UBP_AJBInGameAIRecognition_C::OnDead' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, LessMPThreshold) == 0x000128, "Member 'UBP_AJBInGameAIRecognition_C::LessMPThreshold' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ImaginaryCharacterSelfStand) == 0x000130, "Member 'UBP_AJBInGameAIRecognition_C::ImaginaryCharacterSelfStand' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ImaginaryCharacterPair) == 0x000138, "Member 'UBP_AJBInGameAIRecognition_C::ImaginaryCharacterPair' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, bBeingDamaged) == 0x000140, "Member 'UBP_AJBInGameAIRecognition_C::bBeingDamaged' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, LatestDamagingEnemy) == 0x000148, "Member 'UBP_AJBInGameAIRecognition_C::LatestDamagingEnemy' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, AIEnvironmentRef) == 0x000150, "Member 'UBP_AJBInGameAIRecognition_C::AIEnvironmentRef' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, AttackingGionsInRange) == 0x000158, "Member 'UBP_AJBInGameAIRecognition_C::AttackingGionsInRange' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, MovingGionsInRange) == 0x000168, "Member 'UBP_AJBInGameAIRecognition_C::MovingGionsInRange' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, FloatParams) == 0x000178, "Member 'UBP_AJBInGameAIRecognition_C::FloatParams' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, DamageAreaLocalRef) == 0x0001C8, "Member 'UBP_AJBInGameAIRecognition_C::DamageAreaLocalRef' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ObservedCharacters) == 0x0001D0, "Member 'UBP_AJBInGameAIRecognition_C::ObservedCharacters' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, CharactersInSight) == 0x000220, "Member 'UBP_AJBInGameAIRecognition_C::CharactersInSight' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, EventTagLockHolder) == 0x000270, "Member 'UBP_AJBInGameAIRecognition_C::EventTagLockHolder' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ContextPushed) == 0x000278, "Member 'UBP_AJBInGameAIRecognition_C::ContextPushed' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ErrorContextPushed) == 0x000288, "Member 'UBP_AJBInGameAIRecognition_C::ErrorContextPushed' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ObservableDistanceParam) == 0x000298, "Member 'UBP_AJBInGameAIRecognition_C::ObservableDistanceParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, DistanceThresholdToPlayerForFindingEnemyParam) == 0x00029C, "Member 'UBP_AJBInGameAIRecognition_C::DistanceThresholdToPlayerForFindingEnemyParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, ProbabilityToFindEnemyIfNoPlayersAroundParam) == 0x0002A0, "Member 'UBP_AJBInGameAIRecognition_C::ProbabilityToFindEnemyIfNoPlayersAroundParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, DistanceFromNearestLivingPlayer) == 0x0002A4, "Member 'UBP_AJBInGameAIRecognition_C::DistanceFromNearestLivingPlayer' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, InitialDistanceFromNearestLivingPlayer) == 0x0002A8, "Member 'UBP_AJBInGameAIRecognition_C::InitialDistanceFromNearestLivingPlayer' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, InteractActorChanged) == 0x0002B0, "Member 'UBP_AJBInGameAIRecognition_C::InteractActorChanged' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, TimeSecondsToWarnStartSafeAreaReductionParam) == 0x0002C0, "Member 'UBP_AJBInGameAIRecognition_C::TimeSecondsToWarnStartSafeAreaReductionParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, bAILevelSetupFinished) == 0x0002C4, "Member 'UBP_AJBInGameAIRecognition_C::bAILevelSetupFinished' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, AILevel) == 0x0002C8, "Member 'UBP_AJBInGameAIRecognition_C::AILevel' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, AdditionalDistanceFromNPCParam) == 0x0002CC, "Member 'UBP_AJBInGameAIRecognition_C::AdditionalDistanceFromNPCParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, SafeAreaRadiusMinParam) == 0x0002D0, "Member 'UBP_AJBInGameAIRecognition_C::SafeAreaRadiusMinParam' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, TheWorldEventTagLocker) == 0x0002D8, "Member 'UBP_AJBInGameAIRecognition_C::TheWorldEventTagLocker' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, CameraLookUpDegreeToInputScale) == 0x0002E0, "Member 'UBP_AJBInGameAIRecognition_C::CameraLookUpDegreeToInputScale' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, CameraTurnDegreeToInputScale) == 0x0002E4, "Member 'UBP_AJBInGameAIRecognition_C::CameraTurnDegreeToInputScale' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, OnDamaged) == 0x0002E8, "Member 'UBP_AJBInGameAIRecognition_C::OnDamaged' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, bDamageAreaAvailableCache) == 0x0002F8, "Member 'UBP_AJBInGameAIRecognition_C::bDamageAreaAvailableCache' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, EventTagLocked) == 0x000300, "Member 'UBP_AJBInGameAIRecognition_C::EventTagLocked' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, EventTagUnlocked) == 0x000310, "Member 'UBP_AJBInGameAIRecognition_C::EventTagUnlocked' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, DebugEventReplayPushed) == 0x000320, "Member 'UBP_AJBInGameAIRecognition_C::DebugEventReplayPushed' has a wrong offset!");
static_assert(offsetof(UBP_AJBInGameAIRecognition_C, DebugEventReplayPathPushed) == 0x000330, "Member 'UBP_AJBInGameAIRecognition_C::DebugEventReplayPathPushed' has a wrong offset!");

}

