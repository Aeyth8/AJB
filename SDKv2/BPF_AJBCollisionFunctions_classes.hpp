#pragma once

/*
* SDK generated by Dumper-7
*
* https://github.com/Encryqed/Dumper-7
*/

// Package: BPF_AJBCollisionFunctions

#include "Basic.hpp"

#include "Engine_structs.hpp"
#include "Engine_classes.hpp"
#include "AJB_structs.hpp"


namespace SDK
{

// BlueprintGeneratedClass BPF_AJBCollisionFunctions.BPF_AJBCollisionFunctions_C
// 0x0000 (0x0028 - 0x0028)
class UBPF_AJBCollisionFunctions_C final : public UBlueprintFunctionLibrary
{
public:
	static void HitCheck_Sphere_Sphere(const struct FVector& Location01, float Radius01, const struct FVector& Location02, float Radius02, class UObject* __WorldContext, bool* bHit);
	static void CalcHitLocation(class AActor* OwnActor, bool bSweep, const struct FHitResult& HitResult, class UObject* __WorldContext, struct FVector* HitImpactPoint, struct FVector* HitImpactNormal, struct FVector* HitLocation);
	static void GetHitObjectTypesByPrevTrace(class UObject* __WorldContext, TArray<EObjectTypeQuery>* NewParam);
	static void AJBMultiLineTrace(class AActor* DamageCauser, const struct FVector& Start, const struct FVector& End, class UObject* __WorldContext, bool* bTargetHit, class AActor** TargetActor, class UActorComponent** TargetComponent, struct FVector* TargetLocation);
	static void CalcHeadShot(class AActor* HitActor, const struct FVector& HitLocation, const struct FVector& Direction, float Radius, float TraceLength, class UObject* __WorldContext, bool* bHeadShot);
	static void HitCheck_ContinuedSphere_Sphere(const struct FVector& Location01, const struct FRotator& Rotation01, float Radius01, float Length01, int32 PartitionNum01, const struct FVector& Location02, float Radius02, bool bCheckUnder, float ValidGroundOffsetZ, class UObject* __WorldContext, bool* bHit);
	static void PositioningSafeLocation(const struct FVector& DesiredLocation, const struct FVector& ForwardDirection, float Radius, float HalfHeight, float SmallAmount, TArray<EObjectTypeQuery>& ObjectTypes, bool bIgnoreSelf, int32 AroundTraceNum, float AroundTraceIncScale, int32 SkyTraceNum, float SkyTraceInceScale, class UObject* __WorldContext, EPositioningSafeLocationResult* Result, struct FVector* SafeLocation, class AActor** FirstHitActor);
	static void AroundTrace(const struct FVector& Location, const struct FVector& ForwardDirection, float CapsuleRadius, float CapsuleHeight, float SmallAmount, TArray<EObjectTypeQuery>& ObjectTypes, bool bIgnoreSelf, float TraceLengthScale, class UObject* __WorldContext, bool* bFindSafeLocation, struct FVector* SafeLocation, class AActor** HitActor);
	static void SkyTrace(const struct FVector& Location, const struct FVector& ForwardDirection, float CapsuleRadius, float CapsuleHeight, float SmallAmount, TArray<EObjectTypeQuery>& ObjectTypes, bool bIgnoreSelf, float TraceLengthScale, class UObject* __WorldContext, bool* bFindSafeLocation, struct FVector* SafeLocation, class AActor** HitActor);
	static void OneDirectionTrace(const struct FVector& Location, const struct FVector& Direction, float CapsuleRadius, float CapsuleHeight, float SmallAmount, TArray<EObjectTypeQuery>& ObjectTypes, bool bIgnoreSelf, float TraceLengthScale, class UObject* __WorldContext, bool* bFindSafeLocation, struct FVector* SafeLocation, class AActor** HitActor);
	static void CalcForwardSlopeInfoByCapsule(class ABP_AJBInGameCharacter_C* CharacterBP, const struct FVector& Location, float ForwardValue, class UObject* __WorldContext, bool* bHit, float* Angle);

public:
	static class UClass* StaticClass()
	{
		return StaticBPGeneratedClassImpl<"BPF_AJBCollisionFunctions_C">();
	}
	static class UBPF_AJBCollisionFunctions_C* GetDefaultObj()
	{
		return GetDefaultObjImpl<UBPF_AJBCollisionFunctions_C>();
	}
};
static_assert(alignof(UBPF_AJBCollisionFunctions_C) == 0x000008, "Wrong alignment on UBPF_AJBCollisionFunctions_C");
static_assert(sizeof(UBPF_AJBCollisionFunctions_C) == 0x000028, "Wrong size on UBPF_AJBCollisionFunctions_C");

}

